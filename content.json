{"posts":[{"title":"[Go 01] 配置GO開發環境","text":"什麼是Go Go（又稱Golang）是Google開發的一種靜態強型別、編譯型、並發型，並具有垃圾回收功能且輕巧的程式語言． 透過三步驟設定完開發環境： 安裝官方 Go 配置開發 Go 所需要環境變數 下載IDE「推薦Visual Studio Code加上插件」 開始寫Go Go的優點以下截自:Go適合做什麼？為何這麼多人偏愛Go語言？並簡化列了以下幾點: 學習曲線因為Go語言容易學習，普通的大學生花一個星期就能寫出來可以上手的。 高效率、簡單的併發 出身名門、血統純正出自Google公司，還能說什麼 部署方便：二進位制檔案、Copy部署。想部屬windows(exe)，或是linux可執行文件都很方便喔。 Go擁有強大的編譯檢查、嚴格的編碼規範和完整的軟體生命週期工具。 1.安裝 Gogo 網站https://golang.org/ 下載直接點擊安裝預設會幫你安裝到/usr/local/go底下，這就是GOROOT位置 開啟終端機下指令確認安裝12345➜ ~ go versiongo version go1.14 darwin/amd64➜ ~ which go /usr/local/go/bin/go 2.配置環境變數MAC安裝筆記選擇的是用在使用者目錄下配置環境變數 vi ~/.bash_profile123456789//輸入a編輯export GOROOT=&quot;/usr/local/go&quot;export GOPATH=$HOME/goexport PATH=$PATH:$GOPATH/bin export PATH=$PATH:$GOROOT/bin//GOROOT表示GO安裝的目錄//GOPATH是自訂想要放置程式的地方//打完後esc輸入：wq存擋 執行 bash profile source ~/.bash_profile 3.IDE 安裝3-1 下載 Visual Studio Code3-2 打開 VScode 於 Extensions 安裝 Go (微軟官方維護) 外掛 Go 擴充功能整合了多種 Go 工具，例如 gocode(代碼自動補全), golint(代碼規範檢查)，goreturns(格式工具Format Tool) 等，可以查看https://github.com/golang/vscode-go/blob/master/docs/tools.md(有些有不同選擇，預設工具可以在設定裡改) 如果沒有安裝對應的工具，就會在編譯.go文件時跳出提示，Analysis Tools Missing ，此時可以按下 Command + Shift + p 呼叫命令列視窗，輸入 Go: Install/Update tools 安裝/更新所有的工具解決此問題。 如遇上安裝問題，也有文章推薦可直接進行3-3步驟 3-3 打開終端機執行下列指令來安裝依賴包以下工具: 1234567891011121314151617go get -u -v github.com/ramya-rao-a/go-outlinego get -u -v github.com/acroca/go-symbolsgo get -u -v github.com/mdempsky/gocodego get -u -v github.com/rogpeppe/godefgo get -u -v golang.org/x/tools/cmd/godocgo get -u -v github.com/zmb3/gogetdocgo get -u -v golang.org/x/lint/golintgo get -u -v github.com/fatih/gomodifytagsgo get -u -v golang.org/x/tools/cmd/gorenamego get -u -v sourcegraph.com/sqs/goreturnsgo get -u -v golang.org/x/tools/cmd/goimportsgo get -u -v github.com/cweill/gotests/...go get -u -v golang.org/x/tools/cmd/gurugo get -u -v github.com/josharian/implgo get -u -v github.com/haya14busa/goplay/cmd/goplaygo get -u -v github.com/uudashr/gopkgs/cmd/gopkgsgo get -u -v github.com/davidrjenni/reftools/cmd/fillstruct 配置好後在編輯ＧＯ語言就會發現有很多貼心的提示 ，同時也會出現在ＩＤ內的problems清單裡，可以進一步修改程式語法，真的是超級方便的． 補充：以下是相關工具的說明 工具 說明 dlv.exe go 語言調適工具 gocode.exe go 語言检查，自动补全 godef.exe go 語言定义和引用的跳转 golint.exe go 語言规范检查 go-outline.exe 用于在Go源文件中提取JSON形式声明的简单工具 gopkgs.exe 快速列出可用包的工具 gorename.exe 在Go源代码中执行标识符的精确类型安全重命名 goreturns.exe 类似fmt和import的工具，使用零值填充Go返回语句以匹配func返回类 go-symbols.exe 从go源码树中提取JSON形式的包符号的工具 note class_name %} # 參考文章windows 安裝Go [Go] Go 語言於 Windows 上之安裝與環境設定 用vscode开发调试golang超简单教程 Ｍac 安裝Go Mac上Go環境和VS Code的正確安裝與配置方法 IDE : VScode [Go] 使用 Visual Studio Code 上建置 Go 開發環境","link":"https://minilabmemo.github.io/2020/05/01/01-go-env/"},{"title":"[Go 02] GO 新手上路與概念筆記","text":"藍色區塊 開始寫GO 分享自己初學GO時看的教學文章，安裝完GO環境之後，就可以撰寫自己第一支GO的程式了，網路上的系列說明很多很詳細，就不重複撰文了，以下則是自己收藏很有用的網路文章。 教你撰寫第一隻 Go Go的中文指南 (Go的中文指南，只有簡體) the-little-go-book Golang — GOROOT、GOPATH、Go-Modules-三者的關係介紹 從商業利益看 Go 程式語言 進階 go 整理教學 [筆記] Golang 進階 個人筆記整理筆記 Go 的基本类型 bool,stringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名// 表示一个 Unicode 码点float32 float64complex64 complex128https://tour.go-zh.org/basics/11 匿名欄位12345678910type User struct { Name string}type Person struct { User //匿名欄位 ID string} ss := Person{User: User{Name: &quot;123&quot;}, ID: &quot;123&quot;} fmt.Print(&quot;ss&quot;, ss.Name) 筆記 Go的參數傳遞傳值的意思是：函式傳遞的總是原來這個東西的一個副本，一副拷貝。 pass by value嚴格來說，Go只有傳植方式，會複製一個新的變數，且分配新的memory位址。pass by pointer (或稱 called by reference，但其實不是)指標方式則會複製一個新的指標，但指向的memeory位址是一樣的，但是是兩個不同的指標。 通常預期參數被修改，應傳指標。 在go裡pass by value開銷很小 迷思:Map/chan等其實是指標型別，因此會被修改，是種引用型別(reference types)[不是指call by reference]，仍是pass by value 出自以下參考文章: golang-pass-by-pointer-vs-pass-by-value there-is-no-pass-by-reference-in-go 《Golang 入門系列七》Go語言引數傳遞是傳值還是傳引用Go語言中所有的傳參都是值傳遞（傳值），都是一個副本，一個拷貝。因為拷貝的內容有時候是非引用型別（int、string、struct等這些），這樣就在函式中就無法修改原內容資料；有的是引用型別（指標、map、slice、chan等這些），這樣就可以修改原內容資料。” 筆記 理解 Go 语言中的方法和接收者 值接收者，是一个副本，方法内部無法對其真正的接收者做更改； 指针接收者，是接收者的引用，對這個引用的修改可以影響真正的接收者。 理解 Go 语言中的方法和接收者 筆記 go中的資料結構介面-interfacego中的資料結構介面-interface interface gitbook 筆記 搞定Go Mock 單元測試搞定Go單元測試（二）——mock框架(gomock)","link":"https://minilabmemo.github.io/2020/05/01/02-go-start/"},{"title":"[Go 03] 包管理與模組(Module)相關","text":"Go 包管理與模組相關 import “time” imported but not used-compiler不允許引入未使用包，vscode 儲存，工具會自動幫忙移除。1234如果要引用沒有用到的import，則要使用底線(_)import ( _ &quot;github.com/go-sql-driver/mysql&quot;) import cycle not allowed執行後會出現相依錯誤 延伸閱讀: Golang中解决”import cycle not allowed”的2种方法 Go ModuleGo 1.11 之後提供go modules 可以不需要把專案程式碼放在 $GOPATH/src 中開發，此外還能管理套件相依性。 go mod init建立一個 go.mod，裡面會記錄import版本 go get xxxxxxgo get 命令可以借助代码管理工具通过远程拉取或更新代码包及其依赖包，并自动完成编译和安装。預設會下載最新，@version 可以指定版號。常見flag使用: -d 让命令程序只执行下载动作，而不执行安装动作。 -u 让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。 -v 显示执行的命令 go mod tidy移除不需要的import go mod download可以下载所需要的依赖，或是go build也會自動將 pkg 下載到 GOPATH/pkg/mod 內 延伸閱讀: go get命令——一键获取代码、编译并安装 Go 相依圖go mod graph 可视化——gmchart延伸閱讀: https://segmentfault.com/a/1190000038897207","link":"https://minilabmemo.github.io/2021/02/13/03-go-Module/"},{"title":"[Go 04] 信號處理和退出程式","text":"一般在執行go run main.go後就會馬上回到命令列，這邊實作當接收到ctrl+c或是終止程式才會停止程式 本文說明： go實作接收命令而中止程式． 會用到channel管道來進行阻塞，並接收os/signal訊號 程式碼： 1234567891011121314151617func main() { fmt.Println(&quot;start&quot;) errs := make(chan error, 1) listenForＳignal(errs) c := &lt;-errs //阻塞程式 fmt.Println(&quot;terminating:&quot;, c)}func listenForＳignal(errChan chan error) { go func() { c := make(chan os.Signal,1) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)//要終止的訊號 errChan &lt;- fmt.Errorf(&quot;%s&quot;, &lt;-c) }()} 說明：使用”os/signal”包，用來接收訊號使用，notify方法用来監聽收到的信號（stop方法則取消） * SIGINT 表示用户按下INTR字符(Ctrl+C)觸發 * SIGTERM 结束程序 kill pid的作用是向進程為pid的程序发送SIGTERM * 其他像是SIGKILL kill -9 pid則是發送立即終止 等等就先不使用 測試接收SIGINT然後執行go run main.go後，會看到服務就一直執行著，再按下ctrl+c 123&gt; go run main.gostart^Cterminating: interrupt 測試接收SIGTERM先將main.go編譯成執行檔 -o代表放在目前目錄下 取名為demo“./“執行demo這檔案 123go build -o ./demo main.go ./demo start 接下來開另一視窗 找出進程跟demo有關的pid 然後執行kill pid，確認已停止了 1234➜ ~ ps -A | grep demo 14693 ttys000 0:00.00 ./demo➜ ~ kill 14693➜ ~ ps -A | grep demo 回到程式執行視窗就會看到以下被中止的訊息了 123 ./demostartterminating: terminated 後記疑問： 不太知道到底要怎麼要在vscode debug模式去模擬ctrl+c時會跑到的地方來看程式，google未有結果，無解 在linux環境有效，win環境搜尋無解","link":"https://minilabmemo.github.io/2020/05/01/03-go-signal/"},{"title":"[Go 05] 使用 Gin 框架快速建立 http 服務","text":"如何用 Gin 框架快速建立 HTTP [ GET/POST 等方法] 效果用 Postman 工具打看看就可以得到下面結果 SEND [method url ] RESPONSE [status body ] GET http://localhost:8080/api/v1/user 200 , OK GET http://localhost:8080/api/v1/user/May 200 ,”Hello,May” POST http://localhost:8080/api/v1/user {“name”: “user1”,”age”: 33} 200 , {“name”: “user1”,”age”: 33} 程式碼1234567891011121314151617181920212223242526272829303132333435363738394041// 1.啟動服務func StartHttpServer(errChan chan error) { gin.SetMode(gin.ReleaseMode) engine := gin.New() initRoutes(engine) go func() { errChan &lt;- engine.Run(:8080) }()}// 2.設定路由組func initRoutes(e *gin.Engine) { root := e.Group(&quot;api/v1&quot;) userGroup := root.Group(&quot;user&quot;) { userGroup.GET(&quot;&quot;, apis.User) userGroup.GET(&quot;:name&quot;, apis.UserName) userGroup.POST(&quot;&quot;, apis.PostName) }}// 3. 設定回覆func User(c *gin.Context) { c.JSON(http.StatusOK, &quot;OK&quot;) //回覆status 200 &amp; body &quot;OK&quot;}//接受path參數 name := c.Param(&quot;name&quot;) c.JSON(http.StatusOK, fmt.Sprintf(&quot;%s,%s&quot;, &quot;Hello&quot;, name))}//接收 json 內容func PostName(c *gin.Context) { sc := &amp;structs.User{} if err := c.ShouldBindJSON(sc); err != nil { return } c.JSON(http.StatusOK, sc)}type User struct { Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;`} Gin 延伸 寫中間件 [控制每個 Url timeout/log 等等行為] 套 swagger [下一篇] gin.Context 還有 c.Header, c.Query, c.GetRawData() 等等使用方法，取參數非常方便 第一次去套用 Gin 真的覺得很神奇，本章純快速記錄效果，","link":"https://minilabmemo.github.io/2020/05/08/04-go-gin-http/"},{"title":"[Go 06] 寫測試並產出一目瞭然的網頁版覆蓋率報告 再也不用怕遺漏","text":"本章介紹： 為上一篇 Gin 框架的 User &amp; PostName func.寫個簡單測試 跑測試並瞭解 coverage 覆蓋率，產生測試報告(20210702 有新增vsocde用法補充) 說明：新建一個檔案ＸＸ_test.go，並為 func 取名 Test ＸＸＸ(t *testing.T) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//測試打GET /api/v1/user 去跑User() 會拿到“ＯＫ”func TestUser(t *testing.T) { engine := gin.New() initRoutes(engine)//你的路由邏輯 uri := &quot;/api/v1/user&quot; body := Get(uri, engine) fmt.Printf(&quot;response:%v\\n&quot;, string(body)) if !reflect.DeepEqual(string(body), &quot;\\&quot;OK\\&quot;&quot;) { //利用 t.Errorf 觸發錯誤 t.Errorf(&quot;Get user name need to be ok!&quot;) }}//同理測試 Post 去跑PostName() 會拿到回復的名字等於打的內容（body）func TestPostName(t *testing.T) { engine := gin.New() initRoutes(engine) uri := &quot;/api/v1/user&quot; user := structs.User{Name: &quot;user&quot;, Age: 18} body := PostUser(uri, user, engine) fmt.Printf(&quot;response:%v\\n&quot;, string(body)) response := &amp;structs.User{} if err := json.Unmarshal(body, response); err != nil { t.Errorf(&quot;Unmarshal，err:%v\\n&quot;, err) } if response.Name != &quot;user&quot; { t.Errorf(&quot;response different，user:%v\\n&quot;, response.Name) }}// GET HTTP Requestfunc Get(uri string, router *gin.Engine) []byte { req := httptest.NewRequest(&quot;GET&quot;, uri, nil) w := httptest.NewRecorder() router.ServeHTTP(w, req) result := w.Result() defer result.Body.Close() body, _ := ioutil.ReadAll(result.Body) return body}// POST HTTP Requestfunc PostUser(uri string, param structs.User, router *gin.Engine) []byte { jsonByte, _ := json.Marshal(param) req := httptest.NewRequest(&quot;POST&quot;, uri, bytes.NewReader(jsonByte)) w := httptest.NewRecorder() router.ServeHTTP(w, req) result := w.Result() defer result.Body.Close() body, _ := ioutil.ReadAll(result.Body) return body} 測試單一個 function如果用 VS code，可以在上方看到 run test | debug test 按鈕可以按，十分方便 測試單一檔案內所有測試cover 有帶的話會算出覆蓋率，並要在該目錄下去執行，這邊跑出來結果大約有 57.1% 的覆蓋 1234$go test -v -cover=true user_test.go user.goPASScoverage: 57.1% of statementsok command-line-arguments 0.297s coverage: 57.1% of statements 測試整個專案12如果是在main的目錄要往子目錄找＄go test -v ./… 產生測試覆蓋(coverage)報表-gotest1234go test -coverprofile=coverage.out ./...用gool toolgo tool cover -func=coverage.outgo tool cover -html=coverage.out 這個真的很酷，用網頁產生報告，而且非常視覺化，可以看出剛剛沒有寫到的 UserName()測試為紅色 note warning %} 20210702 補充 :其實後來發現vscode在跑完package test 後，右邊側欄就會跑出覆蓋的條線了如果只是要在測試時查看可以直接用ＩＤＥ的便利性即可． 當然寫測試還有很多判斷的條件等等，是否等於，是否不等於，各種輸出可能． 寫完之後，可以為下一次更動後確認邏輯，看跑過測試真的很有療癒的感覺！！！:grin: 覺得有疑問嗎？可以再進一步看看參考文章： 基于 golang gin 框架的单元测试 go test 提示 no test files Go: tests with HTML coverage report 使用 Go 进行单元测试","link":"https://minilabmemo.github.io/2020/05/08/05-go-test-coverage/"},{"title":"[Go 07] 使用 zap 框架印出 log","text":"本章內容： 實作使用高性能 zap log 框架 擁有 log level 配置 (常用 debug/warn/info/error)與程式碼位置 可以選擇印出在 console 或是文件（要外掛 lumberjack 去分割） zap 有 suger 函式可以增加易用性，但犧牲效能 雖然目前還未有高性能之需求，網路上也有很多不同的ＬＯＧ框架可以選擇，有興趣可以看這篇在 Github 中 stars 数最多的 Go 日志库集合，看了各框架說明介紹，這個框架實作上看來蠻容易的，今天就還試試看． 直接上實作完之程式碼 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package loggerimport ( &quot;mywork/demo/internal/config&quot; &quot;os&quot; &quot;strings&quot; &quot;time&quot; &quot;go.uber.org/zap&quot; &quot;go.uber.org/zap/zapcore&quot; &quot;gopkg.in/natefinch/lumberjack.v2&quot;)var ZapLogger *zap.Loggervar SugarLogger *zap.SugaredLoggerfunc InitLogger() { logWriter := []zapcore.WriteSyncer{zapcore.AddSync(os.Stdout)} if config.Configuration.Logger.File != &quot;&quot; { hook := setFileWriter(config.Configuration.Logger.File) logWriter = append(logWriter, hook) } encoderConfig := setEncoder() level := getLogLevel(config.Configuration.Logger.Level) core := zapcore.NewCore(encoderConfig, zapcore.NewMultiWriteSyncer(logWriter...), level) ZapLogger = zap.New(core, zap.AddCaller()) //印出log的位置 // ZapLogger.Debug(&quot;POK&quot;) // ZapLogger sample ZapLogger.Info(&quot;ZapLogger&quot;, zap.String(&quot;String&quot;, &quot;ohoh&quot;), zap.Int(&quot;Int&quot;, 3), zap.Duration(&quot;backoff&quot;, time.Second), ) SugarLogger = ZapLogger.Sugar() //SugarLogger.Infof(&quot;Success! statusCode = %s for URL %s&quot;, &quot;OK&quot;, &quot;OK&quot;) // SugarLogger sample}func setEncoder() zapcore.Encoder { encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder return zapcore.NewConsoleEncoder(encoderConfig)}func setFileWriter(filePath string) zapcore.WriteSyncer { lumberJackLogger := &amp;lumberjack.Logger{ Filename: filePath, MaxSize: 1, MaxBackups: 5, MaxAge: 30, Compress: false, } return zapcore.AddSync(lumberJackLogger)}func getLogLevel(lv string) zapcore.Level { lv = strings.ToLower(lv) if level, ok := levelMap[lv]; ok { return level } return zapcore.InfoLevel}var levelMap = map[string]zapcore.Level{ &quot;debug&quot;: zapcore.DebugLevel, &quot;info&quot;: zapcore.InfoLevel, &quot;warn&quot;: zapcore.WarnLevel, &quot;error&quot;: zapcore.ErrorLevel,} LOG 輸出範例 zap.Logger 輸出需針對 Type 去輸入，使用跟印出看起來都比較麻煩一點 zap.SugaredLogger 就像是語法糖 122021-01-31T11:46:00.954+0800 INFO log/log.go:27 ZapLogger {&quot;String&quot;: &quot;ohoh&quot;, &quot;Int&quot;: 3, &quot;backoff&quot;: 1}2021-01-31T11:46:01.012+0800 INFO http_server/httpserver.go:35 Listening on port: 56888","link":"https://minilabmemo.github.io/2020/05/18/06-go-zap-log/"},{"title":"[Go 08] 認識時間格式與golang的時區轉換寫法","text":"開發過程中，曾遇過部署到別的平台，時間就變成+0時區了（例如明明下午五點，部署平台顯示早上九點），這時才發現原來你的時間不是他的時間，而資料庫中也常常用時間戳數字來做紀錄，但顯示給使用者時又要轉成格式化顯示，本篇紀錄各種時間格式的理解與go程式對於時間的使用 理解時間的各種顯示格式時間可以以很多格式化的方式做顯示。例如最常看到的2021-04-22 17:27:44 標準時間格式國際標準格式，像是 ISO_8601 合併表示時，要在時間前面加一大寫字母T 如果時間在零時區，並恰好與協調世界時相同，那麼（不加空格）在時間最後加一個大寫字母Z例如以下這樣的顯示方式:122021-04-28T01:51:35Z2004-05-03T17:30:08+08:00 //+08:00代表比世界協調時間快8小時的時區 UNIX時間與時間戳UNIX時間代表從UTC1970年1月1日0時0分0秒起至現在的總秒數 而UTC為世界協調時間（英語：Coordinated Universal Time，法語：Temps Universel Coordonné，簡稱UTC）是最主要的世界時間標準。 這種你會看到可能是十位數的數字(s:1621999487)或是十三位數的數字(ms:1621999487377)，可以透過線上時間戳轉換器得出代表的時間。 時區的轉換世界各國位於地球不同位置上，，不同地區的人會有不同的地方時間，可以看時區轉換器 golang 時間轉換接著說明使用golang實現以上幾種常見的轉換，而2006-01-02 15:04:05-0700是一串go獨特神奇的對應順序。可以看time/format.go 大致列出四種轉換: 將時間戳轉換為時間 將時間做格式化輸出，golang語法的時間輸出跟java比較不一樣。2006-01-02 15:04:05-0700 對應到 yyyy-MM-dd HH:mm:ss Z，請見golang 與java time的對照表， 記憶順序有點像是06代表年，後面則是1,2,3,4,5,7 時區轉換: FixedZone(name,位移的秒數)，可以自訂時區命名信息，loc := time.FixedZone(“UTC-8”, -8 * 60 * 60)第二個參數轉移多少秒，可以改+8時區等等 時區轉換: LoadLocation(name)，可以輸入空值，”UTC”，”Local”，或是時區的資料庫 EX: “Asia/Taipei”，命名使用的資料庫為IANA Time Zone database，好處是不用自己輸入到底是＋8還加多久，知道時區命名就好，但是背後的定義還是會依下列順序去找尋對應資料： ZONEINFO 環境變數所指定的zip文件 Unix系统中已经安装的 $GOROOT/lib/time/zoneinfo.zip， note warning %}因此如果在windows系统上，没有安装go語言環境，time.LoadLocation會失敗，建議用time.FixedZone。 另外在docker環境裡也要注意使用的image是否已經有包含這些資料，否則會出現unknown time zone XXXX的錯誤，解決方法需要加入以下設定 1234567FROM alpine...COPY --from=0 /usr/local/go/lib/time/zoneinfo.zip /opt/zoneinfo.zipENV ZONEINFO /opt/zoneinfo.zipORRUN apk --no-cache add tzdata... 四種轉換時間格式範例程式: diff1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { var Time int64 Time = 1619083664867 //ms-&gt;2021-04-22 17:27:44 t := time.Unix(0, Time*int64(time.Millisecond)) fmt.Println(&quot;case1: timestamp to time:&quot;, t) layout1 := &quot;2006-01-02T15:04:05&quot; fmt.Println(&quot;case2: Formatlayout1:&quot;, t.Format(layout1)) zone := time.FixedZone(&quot;&quot;, +0*60*60) newTimezone0 := t.In(zone) fmt.Println(&quot;case3: Timezone at +0:&quot;, newTimezone0.Format(layout1)) // name := &quot;America/New_York&quot; name := &quot;Asia/Taipei&quot; t, err := TimeIn(t, name) if err != nil { fmt.Println(&quot;err:&quot;, err) } fmt.Println(&quot;case4: Timezone at Taipei:&quot;, t.Format(layout1))}func TimeIn(t time.Time, name string) (time.Time, error) { loc, err := time.LoadLocation(name) if err == nil { t = t.In(loc) } return t, err} 轉換結果： 12345timestamp: 1619083664867case1: timestamp to time: 2021-04-22 09:27:44.867 +0000 UTCcase2: Formatlayout1: 2021-04-22T09:27:44case3: Timezone at +0: 2021-04-22T09:27:44case4: Timezone at Taipei: 2021-04-22T17:27:44 網路參考文章 数据库存时间戳的好处 time-unix examples 1milli-&gt;1000000 nano sec Golang 時區 golang-timezone 到底是 GMT+8 還是 UTC+8 ? golang-TimeIn example Golang神奇的2006-01-02 15:04:05 Go语言标准包解析Location Golang时区设置 解决容器运行 Go 代码 unknown time zone 的正确姿势","link":"https://minilabmemo.github.io/2021/05/30/07-go-time/"},{"title":"[Go] 性能&#x2F;品質檢測","text":"當開發golang程式完成後，其實有一些工具可以查看自己的程式效能，是否有些地方佔了太大的資訊進而改進，另外也可以 透過品質檢測工具去看修改建議；最後，如果有撰寫測試案例的話，也有工具可以產生測試報告，確認測試案例涵蓋了程式多少百分比，還有沒被寫到的地方也可以透過報告顯示出來． 本章介紹: 性能分析工具-pprof 查看CPU/memory 等的瓶頸 檢視go的品質與建議-gosec 性能分析工具-pprof先在程式碼插入以下程式後執行。 123456import _ &quot;net/http/pprof&quot;func main() { go func() { http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil) }()} 開啟http://localhost:8080/debug/pprof/可以看到一個簡單的分析數字 go tool 看記憶體(heap)透過以下指令可以看到佔記憶體的前幾名 1234567891011$go tool pprof http://127.0.0.1:8080/debug/pprof/heap&lt;br&gt;-&gt; 輸入top&lt;br&gt;-&gt; 輸入web可以看到圖形&lt;br&gt;(pprof) top&lt;br&gt;Showing nodes accounting for 1.50MB, 100% of 1.50MB total flat flat% sum% cum cum%&lt;br&gt; 1.50MB 100% 100% 1.50MB 100% golang.org/x/net/webdav.(*memFile).Write&lt;br&gt; 0 0% 100% 1.50MB 100% github.com/swaggo/files.init.8&lt;br&gt; go tool 看CPU(profile)而以下幾令則是幾秒內的ＣＰＵ計算 1go tool pprof http://localhost:6060/debug/pprof/profile?seconds=60&lt;br&gt; 網頁版查看 圖表以上兩種指令其實可以透過以下指令可以開啟一個網頁更容易看到資料的圖表呈現 1234go tool pprof -http=&quot;:9099&quot; -seconds=30 http://localhost:8080/debug/pprof/profilego tool pprof -http=&quot;:9099&quot; http://localhost:8088/debug/pprof/heapgo tool pprof -http=&quot;:9099&quot; http://localhost:8088/debug/pprof/goroutine 參考文章: golang pprof 使用多年的go pprof检查内存泄漏的方法居然是错的?! 檢視go的品質與建議1.先下載 go setgo get github.com/securego/gosec/cmd/gosec@v2.2.0 2.輸出報告(可選格式) 123gosec -fmt=json -out=results.json ./...&lt;br&gt;gosec -fmt=html -out=results.html ./...&lt;br&gt; 注意是*三個點 然後打開ＨＴＭＬ檔案就可以看到程式品質分析報告了 像是以上這條處理檔案位置時，path應該清理處理過以避免輸入異常 note class_name %} ## 延伸文章 來源 摘要 新手问题 golang内存检测工具 生产环境中使用 pprof 时会遇到一些问题 go pprof与线上事故：一次成功的定位与失败的复现 很多小伙伴担心线上使用pprof会影响性能，担心安全问题。这个在我看来利大于弊，当服务出现问题的时候，资源占用多一点点与能够解决问题相比微不足道，当服务没有问题的时候使用pprof那更没有问题了~ Golang 語言的單元測試和性能測試(也叫 壓力測試) （高級測試技術） https://etcnotes.com/posts/pprof/ 生成圖","link":"https://minilabmemo.github.io/2020/09/18/13-go-pprof-gosec/"},{"title":"[純紀錄]Kubernetes基本操作","text":"學習 Kubernetes 與基本操作紀錄 Kubernetes 文章 学习 Kubernetes 基础知识官方 [Day 6] 實際環境運行的 Kubernetes - Node &amp; Architecture Overview概觀 Kubernetes 的內部運作 Kubernetes 元件介紹與 minikube 安裝教學pod/Service/Deployment介紹 适用于 Docker 用户的 kubectl提供docker與kubectl指令對應參考 [Day 5] 在 Minikube 上跑起你的 Docker Containers - Pod &amp; kubectl 常用指令pod與yaml說明與如何與 Pod 中的 container 互動 Day 4 - 部署應用程式到 Kubernetes 叢集 - Part I - 手動建立 deployment 與 Service建立deployment 與 Service/nodePort從本地開啟 Kubernetes &amp; OpenShift Java Client Kubernetes —學習好幫手minikube — 01將K8s所需的Master/Worker node封裝在一個虛擬機器中https://medium.com/@sniperbean/kubernetes-%E5%AD%B8%E7%BF%92%E5%A5%BD%E5%B9%AB%E6%89%8Bminikube-01-aedfaf8b00fe kubectl的簡單查看，新增，重開kubectl的簡單查看，新增，重開 kubectl get pod -A kubectl create 建立 後面可以直接加參數或是用yaml來建立 簡單建立deployment啟動 minikube 之後，我們可以透過 kubectl run 在 minikube 上運行一個 Google 提供的 hello-minikube docker image， 12345$ kubectl create deployment first-deployment --image=katacoda/docker-http-serverdeployment.apps/first-deployment created$ kubectl get podsNAME READY STATUS RESTARTS AGEfirst-deployment-8cbf74484-xgc4l 1/1 Running 0 25s 建立namespaces 12345678910&gt;kubectl get namespacesNAME STATUS AGEdefault Active 7m52skube-node-lease Active 7m53skube-public Active 7m53skube-system Active 7m53s //Create a new NamespacesD:\\k8syaml&gt;kubectl create namespace mynamespace/my created 建立deploymenthttps://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/D:\\k8syaml&gt;kubectl create -f my-first-pod.yaml 編輯要部屬的程式deployment.apps/my-pod created 查看所有podD:\\k8syaml&gt;kubectl get pod -A 看LOGkubectl -n eda logs my-pod-5b788d95bc-kx76k 刪除D:\\k8syaml&gt;kubectl delete deployment my-pod -n eda 先刪除deployment.apps “my-pod” deleted 重開D:\\k8syaml&gt;kubectl -n eda rollout restart deployment nginx179 執行重開指令deployment.apps/nginx179 restarted 編輯一樣可以達到重開效果kubectl edit deployment -n eda nginx179kubectl get pod -ANAMESPACE NAME READY STATUS RESTARTS AGEeda nginx179-5ddfbfccb8-76qz8 1/1 Running 0 84s//啟動成功 minikubeKubernetes —學習好幫手minikube — 01將K8s所需的Master/Worker node封裝在一個虛擬機器中https://medium.com/@sniperbean/kubernetes-%E5%AD%B8%E7%BF%92%E5%A5%BD%E5%B9%AB%E6%89%8Bminikube-01-aedfaf8b00fe1.install kubuctl你可以使用 Kubectl 命令行工具管理 Kubernetes 集群。 kubectl 在 $HOME/.kube 目录中查找一个名为 config 的配置文件。 2.Minikube Minikube 是由 Google 發布的一個輕量級工具。讓開發者可以在本機上輕易架設一個 Kubernetes Cluster，快速上手 Kubernetes 的指令與環境。Minikube 會在本機上跑起一個 virtual machine，並且在這 VM 裡建立一個 signle-node Kubernetes Cluster，本身並不支援 HA (High availability)，也不推薦在實際應用上運行。 安裝:https://minikube.sigs.k8s.io/docs/start/ *開啟docker的k8s設定docker desktop -&gt;settings-&gt; 12345678910111213&gt;kubectl get nodesNo resources found- 啟動minikube start&gt;minikube start* minikube v1.16.0 on Microsoft Windows 10 Enterprise 10.0.17763 Build 17763* Using the docker driver based on existing profile* Starting control plane node minikube in cluster minikube* Restarting existing docker container for &quot;minikube&quot; ...* Preparing Kubernetes v1.20.0 on Docker 20.10.0 ...* Verifying Kubernetes components...* Enabled addons: storage-provisioner, default-storageclass* Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default 確認kubectl version123&gt;kubectl versionClient Version: version.Info{Major:&quot;1&quot;, Minor:&quot;19&quot;, GitVersion:&quot;v1.19.3&quot;, GitCommit:&quot;1e11e4a2108024935ecfcb2912226cedeafd99df&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2020-10-14T12:50:19Z&quot;, GoVersion:&quot;go1.15.2&quot;, Compiler:&quot;gc&quot;, Platform:&quot;windows/amd64&quot;}Server Version: version.Info{Major:&quot;1&quot;, Minor:&quot;20&quot;, GitVersion:&quot;v1.20.0&quot;, GitCommit:&quot;af46c47ce925f4c4ad5cc8d1fca46c7b77d13b38&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2020-12-08T17:51:19Z&quot;, GoVersion:&quot;go1.15.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;} server version需要minikube有安裝才會出現123&gt;kubectl get nodesNAME STATUS ROLES AGE VERSIONminikube Ready control-plane,master 3d v1.20.0 PS C:&gt; minikube dashboardOpening kubernetes dashboard in default browser… 啟動 minikube 之後，我們可以透過 kubectl run 在 minikube 上運行一個 Google 提供的 hello-minikube docker image， $ kubectl create deployment first-deployment –image=katacoda/docker-http-serverdeployment.apps/first-deployment created$ kubectl get podsNAME READY STATUS RESTARTS AGEfirst-deployment-8cbf74484-xgc4l 1/1 Running 0 25s 在 minikube 上透過 kubectl get 來自 https://ithelp.ithome.com.tw/articles/10197186 D:\\k8syaml&gt;kubectl get namespacesNAME STATUS AGEdefault Active 7m52skube-node-lease Active 7m53skube-public Active 7m53skube-system Active 7m53s Create a new NamespacesD:\\k8syaml&gt;kubectl create namespace edanamespace/eda created 建立deploymenthttps://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/D:\\k8syaml&gt;kubectl create -f my-first-pod.yaml 編輯要部屬的程式deployment.apps/my-pod created D:\\k8syaml&gt;kubectl get podsNo resources found in default namespace. D:\\k8syaml&gt;kubectl get pod -ANAMESPACE NAME READY STATUS RESTARTS AGEeda my-pod-5b788d95bc-kx76k 0/1 Error 0 46s 建立不成功因為有相依kube-system coredns-74ff55c5b-wf484 1/1 Running 0 10mkube-system etcd-minikube 1/1 Running 0 10mkube-system kube-apiserver-minikube 1/1 Running 0 10mkube-system kube-controller-manager-minikube 1/1 Running 0 10mkube-system kube-proxy-skl6r 1/1 Running 0 10mkube-system kube-scheduler-minikube 1/1 Running 0 10mkube-system storage-provisioner 1/1 Running 0 10m 看LOGkubectl -n eda logs my-pod-5b788d95bc-kx76k D:\\k8syaml&gt;kubectl delete deployment my-pod -n eda 先刪除deployment.apps “my-pod” deleted D:\\k8syaml&gt;kubectl get pod -ANAMESPACE NAME READY STATUS RESTARTS AGEeda my-pod-5b788d95bc-kx76k 0/1 Terminating 5 6m20skube-system coredns-74ff55c5b-wf484 1/1 Running 0 16mkube-system etcd-minikube 1/1 Running 0 16mkube-system kube-apiserver-minikube 1/1 Running 0 16mkube-system kube-controller-manager-minikube 1/1 Running 0 16mkube-system kube-proxy-skl6r 1/1 Running 0 16mkube-system kube-scheduler-minikube 1/1 Running 0 16mkube-system storage-provisioner 1/1 Running 0 16m D:\\k8syaml&gt;kubectl get pod -ANAMESPACE NAME READY STATUS RESTARTS AGEkube-system coredns-74ff55c5b-wf484 1/1 Running 0 16mkube-system etcd-minikube 1/1 Running 0 16mkube-system kube-apiserver-minikube 1/1 Running 0 16mkube-system kube-controller-manager-minikube 1/1 Running 0 16mkube-system kube-proxy-skl6r 1/1 Running 0 16mkube-system kube-scheduler-minikube 1/1 Running 0 16mkube-system storage-provisioner 1/1 Running 0 16m D:\\k8syaml&gt;kubectl create -f my-first-nginx179.yaml //重新建立一個deployment.apps/nginx179 created D:\\k8syaml&gt;kubectl get pod -ANAMESPACE NAME READY STATUS RESTARTS AGEeda nginx179-75c6f6f5b8-bwzgm 1/1 Running 0 98s //啟動成功kube-system coredns-74ff55c5b-wf484 1/1 Running 0 20mkube-system etcd-minikube 1/1 Running 0 20mkube-system kube-apiserver-minikube 1/1 Running 0 20mkube-system kube-controller-manager-minikube 1/1 Running 0 20mkube-system kube-proxy-skl6r 1/1 Running 0 20mkube-system kube-scheduler-minikube 1/1 Running 0 20mkube-system storage-provisioner 1/1 Running 0 20m D:\\k8syaml&gt;kubectl -n eda rollout restart deployment nginx179 執行重開指令deployment.apps/nginx179 restarted 編輯一樣可以達到重開效果kubectl edit deployment -n eda nginx179kubectl get pod -ANAMESPACE NAME READY STATUS RESTARTS AGEeda nginx179-5ddfbfccb8-76qz8 1/1 Running 0 84s//啟動成功 建立statefulhttps://kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/ D:\\k8syaml&gt;kubectl apply -f my-web.yamlservice/nginx createdstatefulset.apps/web createdD:\\k8syaml&gt;kubectl get pods -ANAMESPACE NAME READY STATUS RESTARTS AGEdefault web-0 1/1 Running 0 39sdefault web-1 1/1 Running 0 27s D:\\k8syaml&gt;kubectl delete pod -l app=nginxpod “web-0” deletedpod “web-1” deleted D:\\k8syaml&gt;kubectl apply -f my-web.yamlservice/nginx unchangedstatefulset.apps/web created D:\\k8syaml&gt;kubectl edit statefulset -n eda my-webEdit cancelled, no changes made.","link":"https://minilabmemo.github.io/2020/12/31/Kubernetes/"},{"title":"[cloud]紀錄雲端儲存服務MinIO與Amazon S3開發筆記","text":"簡單紀錄雲端儲存服務MinIO與Amazon S3與使用GO SDK開發筆記” Amazon Web Services (AWS) S3*Amazon Web Services (AWS) S3，全名為亞馬遜簡易儲存服務，是亞馬遜公司利用其亞馬遜網路服務系統所提供的網路線上儲存服務。(目前可申請免費12個月)，沒有限制，就是用多少付多少錢，可以設定 Billing alert． 如果你有申請AWS帳號，可以用AWS SDK操作上傳到AWS S3，s3沒有免費開發模擬器，只能註冊使用，但有其他可替代的兼容服務。剛開始開發時因為沒有申請帳號，所以使用minIO替代． minIO MinIO是與Amazon S3兼容的服務器端存儲協議，可以處理最大對像大小為5TB的非結構化數據，例如照片，視頻，日誌文件，備份和容器映像，並附帶web ui介面。官方文檔:https://docs.min.io/cn/ minIO server1.自行建立安裝minIO server各種安裝方式:https://docs.min.io/cn/minio-quickstart-guide.html Windows系统 執行檔安裝https://dl.min.io/server/minio/release/windows-amd64/minio.exe 1234執行minio.exe server D:\\Photos預設開啟9000RootUser: minioadminRootPass: minioadmin Windows docker 1docker run -p 9000:9000 --name minio1 -v D:\\data:/data -e &quot;MINIO_ROOT_USER=AKIAIOSFODNN7EXAMPLE&quot; -e &quot;MINIO_ROOT_PASSWORD=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY&quot; minio/minio server /data 1.接著開啟:http://127.0.0.1:9000/，輸入上面的資訊就可以登入，2.新增一個bucket，3.然後上傳檔案成功，4.上傳的檔案就會出現在 D:\\data裡。 但簡單建立的版本並沒有Https，設定上教學裡的win載點已不在..，有興趣可以看這篇安裝:使用TLS安全的访问Minio服务 *HTTPS經由HTTP進行通訊，但利用SSL/TLS來加密封包 2.使用官方提供建立好的minIO server123https://play.min.io Play uses access_key_id Q3AM3UQ867SPQQA43P2F, secret_access_key zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG.GUI操作:https://play.min.io/ minIO clientmcMinIO Client (mc)为ls，cat，cp，mirror，diff，find等UNIX命令提供了一种替代方案。它支持文件系统和兼容Amazon S3的云存储服务（AWS Signature v2和v4）。 有興趣可以至MinIO客户端快速入门指南 minIO SDK自行寫程式撰寫，範例:Golang-minIO 首先使用minio-go 1go get -u github.com/minio/minio-go 加入範例自行替換以下endpoint/accessKeyID/secretAccessKey/useSSL資訊 這個範例是使用minIO的SDK的範例golang-client-quickstart-guide12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( &quot;context&quot; &quot;log&quot; minio &quot;github.com/minio/minio-go/v7&quot; &quot;github.com/minio/minio-go/v7/pkg/credentials&quot;)//1.先要建立minIO serverfunc main() { // endpoint := &quot;play.min.io&quot; // accessKeyID := &quot;Q3AM3UQ867SPQQA43P2F&quot; // secretAccessKey := &quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot; //useSSL := true endpoint := &quot;127.0.0.1:9000&quot; accessKeyID := &quot;AKIAIOSFODNN7EXAMPLE&quot; secretAccessKey := &quot;wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY&quot; useSSL := false //error http: server gave HTTP response to HTTPS client // 初使化 minio client对象。 minioClient, err := minio.New(endpoint, &amp;minio.Options{ Creds: credentials.NewStaticV4(accessKeyID, secretAccessKey, &quot;&quot;), Secure: useSSL, }) if err != nil { log.Printf(&quot;err\\n&quot;) log.Fatalln(err) } log.Printf(&quot;ok\\n&quot;) // minioClient初使化成功 // 创建一个叫mymusic的存储桶。 bucketName := &quot;test11&quot; location := &quot;us-east-1&quot; ctx := context.Background() err = minioClient.MakeBucket(ctx, bucketName, minio.MakeBucketOptions{Region: location}) if err != nil { // 检查存储桶是否已经存在。 exists, errBucketExists := minioClient.BucketExists(ctx, bucketName) if errBucketExists == nil &amp;&amp; exists { log.Printf(&quot;We already own %s\\n&quot;, bucketName) } else { log.Printf(&quot;err\\n&quot;) log.Fatalln(err) } } else { log.Printf(&quot;Successfully created %s\\n&quot;, bucketName) } // 上传一个zip文件。 objectName := &quot;ssss.zip&quot; filePath := &quot;./ssss.zip&quot; contentType := &quot;application/zip&quot; // 使用FPutObject上传一个zip文件。 n, err := minioClient.FPutObject(ctx, bucketName, objectName, filePath, minio.PutObjectOptions{ContentType: contentType}) if err != nil { log.Fatalln(err) } log.Printf(&quot;Successfully uploaded %s of size %d\\n&quot;, objectName, n)} AWS SDK如果你有用AWS S3的SDK，一樣可以使用它撰寫程式連結到minIO的server，MinIO官方範例:How to use AWS SDK for Go with MinIO Server，不過該AWS ADK已經有V2了，如果用V2版需要再改一下自行定義資訊的寫法Overriding Endpoint with Fallback，或是讀取AWS config的本地Credentials資訊。 產生Credentials組態與登入資料檔案設定 Windows 中是使用環境變數 %UserProfile% (通常是c:/users/xxx)來參考，而在 Unix 系統中是使用 $HOME 或 ~ (波狀符號) 來參考 可以下載AWS CLI 來幫你產生這些檔案 minIO server的產生方式可以看這篇AWS CLI with MinIO Server 測試用aws CLI列出buckets 12345678910111213&gt;aws configureAWS Access Key ID [****************MPLE]: Q3AM3UQ867SPQQA43P2FAWS Secret Access Key [****************EKEY]: zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TGDefault region name [us-east-1]:Default output format [None]:&gt;aws configure set default.s3.signature_version s3v4&gt;aws --endpoint-url https://play.min.io s3 ls2021-04-06 00:05:40 00dst12021-04-06 00:05:53 00dst2(略) 網路參考文章 amazon-s3開發是否有免費帳號","link":"https://minilabmemo.github.io/2021/04/28/aws-s3/"},{"title":"[Blog] 五分鐘教你使用 docusaurus 建立筆記部落格","text":"雖然說現在用的hexo技術建立的部落格就是為了寫筆記，但有時候只是為了真的純快速紀錄，之後待查或待看，但要整理成新的文章往往要一段時間，且很多不同的速記比較很難一下找出來，這時看到有另一種風格的部落格蠻適合當這樣的記錄的，適合作文檔的站點． 1.Docusaurus will help you ship a beautiful documentation site in no time.2.是由Faecbook團隊開源專案，提供的一款易於維護的靜態網站建立工具，且可以使用react技術編輯．（MIT License） 個人選擇的優點： 左側有可以開闔的側欄，且進入文章後不會不見，可以快速瀏覽． 單純作為文檔保存筆記而建立 玩玩Docusaurus ！！ （第一點雖然hexo我有試圖找過有沒有不同主題可以符合這樣的需求，但搜尋上有點困難，就當作為了切開風格而另架一種風格的網站，而且也很快速．） 建立Docusaurus馬上就進入官網 看 get started 說明流程只要三個指令： 123npx @docusaurus/init@latest init my-website classiccd my-websitenpx docusaurus start Ex 我的配置流程，我用的命名為note-blog(你可以使用自訂的命名)： 12345678910111213141516171819202122blog npx @docusaurus/init@latest init note-blog classicnpx: 40 安裝成功，花費 6.139 秒Creating new Docusaurus project ...Success! Created note-blogInside that directory, you can run several commands: npm start Starts the development server. npm run build Bundles the app into static files for production. npm deploy Publish website to GitHub pages.We suggest that you begin by typing: cd note-blog npm start 這邊最後一步啟動介紹寫的有點不同，但是都可以啟動 一些基本的畫面就出來了☼☼☼http://localhost:3000/note-blog/ 接著我先不改內容，先部署到網路上拿到正式網址． 上傳到github這邊我用的方式是用gh-pages工具的做法，跟官網deployment介紹的有點不同，（個人覺得官網寫的覺得有點難懂，但流程可能比較正式，有興趣的人可以試著做做看） 個人使用gh-pages工具流程記錄如下． 先到githu\bb新增專案名為“”note-blog 先把剛剛的專案上傳到GIT 基本上照gutbuh建立完的提示輸入就好12git remote add origin XXXgit push -u origin master 安裝gh-pages工具 1npm install --save gh-pages 在專案的 package.json 中加入 homepage與scripts 12345678910&quot;name&quot;: &quot;note-blog&quot;,+ &quot;homepage&quot;: &quot;https://minilabmemo.github.io/note-blog&quot;,scripts&quot;: {+ &quot;predeploy&quot;: &quot;npm run build&quot;,+ &quot;deploy&quot;: &quot;gh-pages -d build&quot;, &quot;docusaurus&quot;: &quot;docusaurus&quot;, &quot;start&quot;: &quot;docusaurus start&quot;, &quot;build&quot;: &quot;docusaurus build&quot;, &quot;swizzle&quot;: &quot;docusaurus swizzle&quot;,- &quot;deploy&quot;: &quot;docusaurus deploy&quot;, 接著gh-page 就可以用下列指令上傳啦 console12345678910npm run deploy略Success! Generated static files in build.Use `npm run serve` to test your build locally.&gt; note-blog@0.0.0 deploy /xxxx&gt; gh-pages -d buildPublished 成功部署到 Github 上後，會發現多了一個名為 gh-pages 的分支，教學文中說設定頁-&gt;GitHub Pages-&gt;Source要把頁面指到 gh-pages 這個分支（但我查看預設就是了） 接著打開頁面，結果發現馬上跳錯誤畫面，但有指示要更改docusaurus.config.js檔案內的 1baseUrl: '/note-blog/', 再開一次頁面會成功了！！https://minilabmemo.github.io/note-blog/ （到這邊大約就五分鐘差不多，但為了看懂它的編輯設定還是花了我一點時間．） 開始編輯網站建立完後基本畫面上就有教學了，而且覺得比官網上的說明還要清楚，可以直接查看這邊就好，我也保留了這些教學文件（-&gt;點我） 以下就簡單紀錄使用用法: 更改設定檔 docusaurus.config.js這邊可以更改網站標題與logo，看欄位一一修改應該沒什麼困難,但也有更多可以新增的欄位設定: 主設定檔說明寫在這邊 主題使用設定，可以修改導覽列的下拉清單，新增通知訊息等． 編輯的文件檔案說明文件的編輯格式檔案有兩種選擇 學過react可以用js撰寫 一般可以使用Markdown(.md)撰寫（不知道什麼是Markdown的可以先去玩玩線上編輯工具),而docusaurus可以輸入前言作為描述顯示相關位置： 相關的markdown前言 新增頁面 page可以新增一個頁面，然後對應的網址就會出現對應內容了，這通常是獨立頁面，需要另外用超連結指到這個位置． 須注意對應的網址會在 baseUrl底下喔12ex/src/pages/foo/index.js → &lt;baseUrl&gt;/foo/ 看看效果：note-blog/src/pages/markdown-page.md→https://minilabmemo.github.io/note-blog/markdown-page/ 建立文件 Document可以直接把文章放到docs資料夾裡，並在前言編輯位置與標題就會出現在側邊欄了． /docs/intro.md12345678+ ---+ sidebar_label: &quot;Hi!&quot; + sidebar_position: 3+ ---# Hello 這邊就是文章內容This is my **first Docusaurus document**! 建立blog這邊一樣方法，只是會建立在blog分頁，裡面已經有基本範本，且說明blog支援tags功能，如果不想要blog頁籤，可以把整個資料夾刪除（/your_repo/blog/2019-05-30-welcome.md）． 新增與修改插件設定插件列表 plugin-content-docs如果是有裝classic主題，就可以不用另外安裝，plugin-content-docs裡的內容可以像下面修改： editUrl：修改進入github編輯的位址 showLastUpdateTime：顯示修改日期/docusaurus.config.js12345678910111213presets: [ [ '@docusaurus/preset-classic', { docs: { editUrl: 'https://github.com/&lt;git_account&gt;/&lt;repo&gt;/edit/master/', + showLastUpdateTime: true, } }, ], ], 注意事項 - 錯誤狀況不知道為什麼有的時候能顯示，但是跑到deploy &amp; build時，如果文章中有錯誤連結，就會跑出一堆錯誤喔～！！！可以在一堆錯誤上方中找到,一不小心會以為是npm與libiary問題…. 123456Exhaustive list of all broken links found....npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! /Users/yiyin/.npm/_logs/2021-08-03T06_04_03_540Z-debug.log 網路參考文章 docusaurus 中文指南 [Day 29 - 即時天氣] 寫網頁就是要炫耀啊，不然要幹麻？發布上 Github Pages 吧！","link":"https://minilabmemo.github.io/2021/05/21/blog-docusaurus-01/"},{"title":"[Blog]使用 gitbbook 建立我的 golang 線上學習筆記","text":"GitBook 幫助你創建一個方便瀏覽撰寫好用的文件協作分享． 最近嘗試用 gitbook 來記錄學習的線上備忘錄，發現還蠻好用的！所以建了一個golang memo的gitbook專區～把自己所學都整理往裡面放． 優點 線上編輯即所見 有側邊欄與文章目錄，可以拖拉更改配置． 編輯區塊方便 表格/程式碼/heading… 等等，適合不習慣用純 markdown 語法編輯的人． 可以與github sync 做備份 發布就有網址，可以分享給別人． 開始吧～ 上gitbook官網，註冊帳號 開始新增文章，於線上編輯 點擊發布！！就可以拿到網址了 使用gitbook一切就是這麼簡單！！！ 發布網址點這裡看我的 -&gt; golang 學習備忘錄 心得","link":"https://minilabmemo.github.io/2022/09/09/blog-gitbook/"},{"title":"[Blog] 使用 Hexo 撰寫部落格 01- 建立部落格","text":"cq %} hexo 是什麼？ endcq %} Hexo 是一個快速、簡單且強大的網誌框架。Hexo 使用 Markdown 標記語言解析您的文章，並在幾秒鐘內，透過漂亮的主題產生靜態檔案。（來自 https://hexo.io/zh-tw/docs/ 說明） 本文將會知道 如何使用 Hexo 產生部落格 （超快速，只要看到這邊就建好囉！） 如何使用 markdown 撰寫文章 如何部署到 github 個人網頁 如何更改主題與內文風格 (本站用到的所有修改介紹，移到下一篇) 安裝 hexo 與初始化部落格產生基本部落格結構12345678安裝工具 （使用npm安裝 可先安裝Node：https://nodejs.org/en/）$ npm install -g hexo-cli初始資料夾$ hexo init &lt;folder&gt;進入資料夾及安裝相依$ cd &lt;folder&gt;$ npm install這邊就已經做好初始化了 啟動部落格 Run server12$ hexo server開啟瀏覽器 http://localhost:4000 就可以看到部落格了💕💕💕 More info: Server （紀錄）顯示版本資訊（有需要的話，可以查詢對應安裝版本）知道自己安裝的版本，對於之後查詢問題是很有幫助的喔！ 123456789101112131415161718192021$ hexo version(node:5190) ExperimentalWarning: The fs.promises API is experimentalINFO Validating confighexo: 5.1.1hexo-cli: 4.2.0os: Darwin 19.0.0 darwin x64http_parser: 2.8.0node: 10.16.3v8: 6.8.275.32-node.54uv: 1.28.0zlib: 1.2.11brotli: 1.0.7ares: 1.15.0modules: 64nghttp2: 1.39.2napi: 4openssl: 1.1.1cicu: 64.2unicode: 12.1cldr: 35.1tz: 2019a 開始撰寫文章新增文章12345$ hexo new &quot;My New Post&quot;(預設)會在source/＿posts 底下新增一個 .md 檔案$ hexo new draft &quot;My New Post&quot; //指定生成草稿會在source/＿draft 底下新增一個 .md 檔案 More info: Writing 撰寫文章在剛剛新增的檔案開始採用 markdown 語法開始撰寫文章． 可以找線上編輯器工具幫助撰寫及預覽，「自己習慣用這一個https://markdown-editor.github.io/」 ，編輯完再貼過來內文． 如對語法有一點熟悉，就直接用 vscode 打開檔案開始撰寫內文，並可以安裝 vscode markdown preview 插件，邊改邊預覽． 編寫完再啟動部落格並在瀏覽器查看效果． （可帶–draft 顯示草稿） 1hexo s --draft 部署網站建立與設定 Git 空間 先在 github 上新增一個專案叫與帳號一樣命名叫做“[yourname].github.io” 建立完成後會有教你如何建立commit &amp; push的語法，建議要先建立連結，之後部署才會順利． 1&gt;git push -u origin master 配置 _config.yml 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io branch: master 產生靜態文件 Generate static files123$ hexo generate 或是hexo g會在public資料夾產生網站靜態檔案這是用來部署到網站的檔案，記得每次部署前都要更新喔 More info: Generating 一鍵部署12345$ hexo deploy（略）Branch 'master' set up to track remote branch 'master' from 'https://github.com/minilabmemo/minilabmemo.github.io'.INFO Deploy done: git要看到這句才是部署成功，如果卡住可能要先檢查git連結是否正常． 其他空間部署說明(ex:heroku) More info: Deployment 註：部署會上傳至剛剛config的位置，測試發現只會上傳web檔案相關如果有上傳source/theme 檔案也會被移除．因為在開發環境時可以先開一個src branch 來控管原始檔案．branch - src (have all files)branch - master (only web files) 個人網站網址https://yourname.github.io/ 這樣就大功告成啦！🎉🎉🎉（註：有時要稍等一下才會看到更新） 清理靜態文件 Clean static files12$ hexo clean清除快取檔案 (db.json) 和已產生的靜態檔案 (public) label warning@下一篇會介紹如何更換主題及內文撰寫%} 參考文章 note warning %} 學習路上感謝網路大神們，如果你發現了我，可以查看參考文章了解更多概念👇👇👇 Quick StartWelcome to Hexo! Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub HEXO 指令","link":"https://minilabmemo.github.io/2021/01/31/blog-hexo-01-hello-world/"},{"title":"[Blog] 使用 Hexo 撰寫部落格 02- 更換主題編寫與個人化設定","text":"上一篇已經建立好基本網站架構了，這篇收集本站所有更改主題為NextT及更換的個人化設定． 主題呈現效果 更換主網站設定檔主網站設定檔位置：/your folder/_config.yml，可以在此編輯基本網站說明． 12345678title: '程式筆記subtitle: ' Ｍemo 'description: ''keywords:author: xxxlanguage: zh-TW語言可以改為繁體中文，但對應顯示語言可以在以下位置修改：/your folder/themes/next-reloaded/languages/zh-TW.yml 更換主題 Hexo 預設主題是 landscape 想要更換主題依下列步驟即可： 在 hexo 網站上挑選主題：https://hexo.io/themes/ 然後依照教學 clone 對方的主題到自己的 theme 資料夾(通常都有 git 指令，在自己資料夾照下即可) 20220405更新 使用fork對方的主題庫到自己的庫，然後用submodule進theme資料夾 修改主網站設定_config.yml 來更換 部署修改紀錄 （可跳至最後一步） 本部落格採用 Next，它是一個相當熱門的主題,且有很多中文文檔說明，我也是看了範例網站，真的太喜歡才決定架 hexo 的，紀錄操作步驟如下． (嘗試1:啟動失敗)&gt;label danger@失敗 %} 更換主題 git clone https://github.com/iissnan/hexo-theme-next themes/next: config.yml 換成 theme：next，但是啟動 hexo s 後，開啟的網站卻是亂碼參數頁面＠＠啟動畫面也出現以下訊息： 123456WARN ========================= ATTENTION! ========================== ===============================================================WARN NexT repository is moving here: https://github.com/theme-next ===============================================================WARN It's rebase to v6.0.0 and future maintenance will resume there =============================================================== 原因應該是找到的文章教學，clone 來源太舊了？改參考官方更新步驟从 NexT v5.1.x 更新 （嘗試2:啟動成功 但曾經部署網站成功後來失敗)&gt;label danger@失敗 %} 試著更換主題 Clone v7.8.0 最新的倉庫（如放在 next-reloaded）：$ git clone https://github.com/theme-next/hexo-theme-next themes/next-reloaded（v.5.1.4） 在 Hexo 的主配置文件中设置主题：theme: next-reloaded 重新開啟就正常了 嘗試3:成功) &gt;label success@現況Ｖ %} 2022 04 發現部署後 網站一直沒有更新，部署上傳後會跑部署流程，正常會有綠色勾勾，但某次之後都是紅色勾勾，點擊發現一直沒有辦法找到submoudule themes/next-reloaded 排查過程：蠻奇怪的，不太懂沒有用到submoudule，不知道是不是殘留，部署的源碼也有看到theme/next-reloaded的連接． 決定用fork方式一份自己的主題my-hexo-theme-next)，並用submoudule加入1git submodule add https://github.com/xxx/my-hexo-theme-next.git themes/my-hexo-theme-next 然後砍掉其他不要的主題，另外發現.deploy_git裡面有殘留theme/next-reloaded…等東西，就直接把.deploy_git資料夾整個砍掉，重新跑就部署成功了． （這時會發現.deploy_git跟上傳的檔案裡面都沒有theme中奇怪的next-reloaded的連接） 之後想更換別的主題也是這樣喔 主題設定主題設定位置：/hexo-web/themes/next-reloaded/_config.yml 更換 NexT 版面風格1234NextT 提供不同風格可以更換#scheme: Muse 選單在上方#scheme: Mist 選單在上方scheme: Pisces 選單在側邊 新增文章標籤與分類 新增標籤與分類頁面 123456789hexo new page tagshexo new page categories=====index.md---title: categoriesdate: 2021-01-11 17:25:08type: &quot;categories&quot; 為文章加上 Tag 與 categories在_posts/xxx.md 文章上方新增，差別在於標籤是並行的標示，而分類會有階層式關係． 1234567891011121314151617---title: 使用Ｈexo 撰寫部落格tags: - Testing - Another Tag比較特別以下這種寫法代表階層關係Web-&gt;blogcategories: - Web - blog或是多分類表示法：代表Diary-&gt;Food...categories:- [Diary, Food]- [Diary, Games]- [Life]--- 開啟menu頁面(側邊欄) _config.yml12345678# Usage: `Key: /link/ || icon`# icon 也可以自由置換 https://fontawesome.com/v4.7.0/icons/menu: home: / || fa fa-home categories: /categories/ || fa fa-th archives: /archives/ || fa fa-archive tags: /tags/ || fa fa-tags about: /about/ || fa fa-user 新增個人頁面 新增關於我頁面 1hexo new page about 編輯頁面內容[your folder]/source/about/index.md 12345---title: About Medate: 2020-09-06 13:53:06---bla bla bla bla... 開啟頁面 123456789_config.yml# Usage: `Key: /link/ || icon`# icon 也可以自由置換 https://fontawesome.com/v4.7.0/icons/menu: home: / || fa fa-home categories: /categories/ || fa fa-th archives: /archives/ || fa fa-archive tags: /tags/ || fa fa-tags about: /about/ || fa fa-user 文章中顯示引言 (標籤外掛（Tag Plugins）)12345678910111213有分號的上下引言，兩種皆可&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&gt;centerquote %}blah blah blah&gt;endcenterquote %}&lt;!-- 标签别名 --&gt;blah blah blah單純的置中引言&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;顯示效果在本文開頭喔 文章中程式碼區塊更改主題/themes/next-reloaded/_config.yml 12345678highlight_theme: night# Add copy button on codeblockcopy_button: enable: true # Show text copy result. show_result: true # Available values: default | flat | mac style: default 標籤外掛（Tag Plugins）12345678910依序為 語言 左上標題 右上網址 網址名稱&gt;codeblock lang:go terminal https://minilabmemo.github.io/ 完整程式碼 %}go xxx&gt;endcodeblock %}\\\\ Backtick Code Block```go terminal https://minilabmemo.github.io/ 完整程式碼```diff- + codeblock效果 codeblock lang:go terminal https://minilabmemo.github.io/ 完整程式碼 %}go xxxendcodeblock %} Backtick Code Block效果 terminal完整程式碼1go xxx diff效果 12- go xxx+ go xxx 文章開頭標記12&gt;note class_name %} Content (md partial supported) 其中class_name可不設或是改成下方關鍵字 note class_name %} Content (不設定) 淡灰色 note default %} 灰色 default note primary %} 紫色 primary 綠色 success 藍色 info note warning %} 黃色 warning note danger %} 紅色 danger 主題_config 文件配置关键字：note，可修改成想要的風格 1234567891011note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 標籤標注 label info@標示藍色底色 %}label warning@標示黃色底色 %}label danger@標示danger底色 %} 123&gt;label info@標示藍色底色 %}&gt;label warning@標示黃色底色 %}&gt;label danger@標示danger底色 %} 文章中貼上圖片1234567放置圖片在/your folder/themes/next-reloaded/source/images貼上相對路徑![my](/images/avatar_memo.png)或是用html寫法，可以控制大小&lt;img src=&quot;/images/avatar_memo.png&quot; width=&quot;150px&quot; /&gt; 開啟文章與網站訪問數字12345678910111213主題內建不蒜子計數器_config.ymlbusuanzi_count: enable: true total_visitors: true total_visitors_icon: fa fa-user total_views: true total_views_icon: fa fa-eye post_views: true post_views_icon: fa fa-eye本地預覽時底部訪問人數與總訪問的數字會異常大，這是正常现象只需要部署至雲端即可恢復正常 在標頭放上可愛的 git 連結1234_config.ymlgithub_banner: enable: true（本部落格右上角範例） 顯示部落格作者照片12_config.ymlavatar：圖片網址 放上個人社群連結12social可自由新增 顯示閱讀進度百分比123456back2top: enable: true # Back to top in sidebar. sidebar: false 顯示在右下角 true代表顯示在側邊欄 # Scroll percent label in b2t button. scrollpercent: true 顯示百分比 個人化設定預設新增文章模板修改 /scaffolds/post.md 新增自己預設內容 12345678---title: {{ title }}date: {{ date }}tags:categories:---blabla..... 前言&lt;!--more--&gt;\u0006 意外發現的方法，藉由這樣修改 hexo new post 時就可以把基本的設定加好了 參考文章 NextT 開始使用 NextT 主题配置 NextT 內置標籤 Hexo 个人博客 NexT 主题设置 Scheme 外观 hexo 页脚添加访客人数和总访问量 【Hexo插件系列】 常用tag deploy 在 hexo 中使用 git submodules 管理主題 用Github Pages+Hexo搭建博客之(七)如何删除一篇已经发布的文章 #成功解决：同时删除掉.deploy_git文件夹","link":"https://minilabmemo.github.io/2022/05/01/blog-hexo-02-themes/"},{"title":"[Blog] 使用 Hexo 撰寫部落格 03 - 外部資源&#x2F;插件設定","text":"外部也有一些插件與資源可以幫助部落格更加豐富，本篇記錄用到的外部插件使用方式． 外部資源/插件設定標籤雲1.安裝插件 1npm i hexo-tag-cloud --save 2.配置主網站_config.yml要注意不要改錯檔案，不然可以看到標籤雲卻改不了樣式 12345678# hexo-tag-cloud 標籤雲：see https://github.com/MikeCoder/hexo-tag-cloudtag_cloud: textFont: Trebuchet MS, Helvetica # 字体 textColor: '#869ABF' # 字體颜色 textHeight: 12 # 字體高度 outlineColor: '#FFCFAB' # 字體背景色 maxSpeed: 0.1 # 標籤雲最大移動速度 pauseOnSelected: true # true 選中時停止移動 修改主題側邊欄的語言內容以 NexT 主题為例修改 layout/_macro/sidevar.swig 文件中在 sidebar-inner 新增 123456789101112&gt;if site.tags.length &gt; 1 %}&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;{{ url_for('/js/tagcloud.js') }}&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;{{ url_for('/js/tagcanvas.js') }}&quot;&gt;&lt;/script&gt;&lt;div class=&quot;widget-wrap&quot;&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;220&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; {{ list_tags() }} &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&gt;endif %} 作者 git 上的 Readme 說明 [by version 2.1.2]建議可以關注 https://github.com/MikeCoder/ 說明動作操作 12完成安装和显示，可以通过 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 来进行本地预览, hexo clean 为必须选项。**PS:不要使用 hexo g -d 或者 hexo d -g 这类组合命令。**详情见: Issue 7 新增Google Analytics 流量分析Google分析是一個由Google所提供的網站流量統計服務。Google 分析現在是網際網路上使用最廣泛的網路分析服務。 （雖然這部落格只是用來來自己筆記的，流量應該很少，但想要用來玩玩看google的分析網站而試試） 1.註冊 google analysis這邊我註冊了一個帳戶名（yume），資源名稱為hexo_blog，名稱之後都可以更改，接著填寫一些想要分析的內容與目的等等，完成後就會得到一個資源，也會有資源ID（但這不是我們要的），點入該新建的資源後，再新增一個資源串流，就可以得到評估ＩＤ了． 代碼設定操作說明這邊提供了兩種方式說明： 1.新增網頁內代碼，全域網站內有說明如果在網站上head區塊加入代碼範例或是使用google代碼管理工具． 2.使用現有的網頁內代碼：內有提到gtag.js與你的評估ID資訊． 2.修改hexo的主題設定檔由於目前我用的主題已經有現有的相關代碼設定，因此只要在上面拿到的評估ID，貼到主題設定檔中的app_id裡就可以了． themes/next-reloaded/_config.yml123456# Google Analyticsgoogle_analytics: tracking_id: # &lt;app_id&gt; # By default, NexT will load an external gtag.js script on your site. # If you only need the pageview feature, set the following option to true to get a better performance. only_pageview: false 當然有的時候會遇到不失效的問題，網路有說有的代碼會去判斷主設定檔的hostname與github 是否123# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://minilabmemo.github.io/ 最終效果網路上可說可以在剛剛的分頁按下測試，但發現並沒有，且一直出現過去48小時並未收到資料，不過實際瀏覽可以看到分析結果喔!! 參考文章 Hexo 添加标签云 Hexo 加上 Google analysis Hexo的Next主题中配置Google Analytics之后不生效的问题 Hexo fluid 中关联 Google Anlytics 的具体方法","link":"https://minilabmemo.github.io/2022/02/03/blog-hexo-03-plug/"},{"title":"[Blog] hexo 在文章開頭加上內容目錄","text":"內容目錄\"toc“ 是代表 table of contents 目錄，上一篇透過內建的toc雖然可以長出側邊欄，但如果想要在撰寫markdown時讓他出現文章開頭，就需要安裝額外的插件來做到，以下研究了兩種插件的方式並記錄下來． 目錄 | Contents 效果介紹 方法一: use hexo-toc 方法二 use hexo-insert-toc reference 效果介紹原本這個部落格的文章，就已經具有側邊欄toc了，只要在文章標頭放上toc:true即可，但我想要的效果是在文章開頭時就放上，這樣手機瀏覽時也能看到內容，這邊有找到安裝額外插件． 方法一: use hexo-toc安裝 hexo-toc 安裝說明來自：https://github.com/bubkoo/hexo-toc12npm install hexo-toc --save安裝完之後在文章內加入 &lt;!-- toc --&gt; 即可 //注意前後有空格 但這樣加完會出現所有階層，但我並不希望階層太多，可以出現第一層就好，需要再另外安裝插件markdown-toc並修改config12345671. npm install --save markdown-toc2. _config.ymltoc: maxdepth: 2 class: toc 記得 hexo clean & hexo g 後啟動才會看到效果． 這個插件的問題：這樣做完之後，側邊欄的階層也跟著被影響了，我希望側邊欄可以多階層並隨著文章閱讀而擴展，而內文開頭就顯示第一層就好．找不到方法所以先卸載hexo-toc． 方法二 use hexo-insert-toc安裝hexo-insert-toc 插件來自：https://github.com/bennycode/hexo-insert-toc1npm i hexo-insert-toc 更改階層12hexo-insert-toc: maxdepth: 2 成功安裝完的 dependencies 版本“展開查看dependencies版本” json >folded123456789101112131415161718192021&quot;dependencies&quot;: { &quot;bulma-stylus&quot;: &quot;^0.8.0&quot;, &quot;hexo&quot;: &quot;^6.3.0&quot;, &quot;hexo-asset-image&quot;: &quot;^1.0.0&quot;, &quot;hexo-component-inferno&quot;: &quot;^2.0.2&quot;, &quot;hexo-deployer-git&quot;: &quot;^2.1.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;, &quot;hexo-insert-toc&quot;: &quot;^1.1.2&quot;, &quot;hexo-log&quot;: &quot;^3.2.0&quot;, &quot;hexo-pagination&quot;: &quot;^2.0.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-inferno&quot;: &quot;^0.1.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^3.0.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;, &quot;hexo-server&quot;: &quot;^2.0.0&quot;, &quot;hexo-theme-landscape&quot;: &quot;^0.0.3&quot;, &quot;markdown-toc&quot;: &quot;^1.2.0&quot;}, 這個插件產生出來的 toc 並不能客制class name，需要再自己加入，而且中文連結會無法跳轉，英文是正常的「尚不知如何解決，只好先練練英文了（誤）」． 後記 20230318更新 關於中文問題，後來有在這個作者的github上詢問.似乎是這個檔案 slugify.js造成，嘗試修改 replace 其實沒有什麼用，所以我就整段註解掉（後來有照作者建議修改），重新 hexo clean/hexo g ，就正常了，不太了解細節，看來是這個位置會變成％E6，但後來又變成%25E6，百分比符號又被變成%25，或許我使用的主題不需要這段，但這樣可以解決我的問題就好了，有時間再來研究． reference本篇文章內容參考如下 Photo by Milan Seitler on Unsplash","link":"https://minilabmemo.github.io/2023/02/26/blog-hexo-05-toc/"},{"title":"[Blog] 在文章底部加上 分享&#x2F;贊助&#x2F;評論 內容","text":"一開始設置完 blog，底部有幾個區塊- 分享/贊助/評論 沒有設定，是會跳出紅色框框的，這篇就來把文章底部相關的互動給補齊吧． 目錄 | Contents 分享按鈕 評論功能 贊助按鈕 網路參考文章 分享按鈕依照Icarus用户指南 - 分享按钮 選擇一個喜歡的按鈕，我是用 addthis，依照說明填入，需注意要填入正確，不然會看不見．這一個用法要先去 addthis 上面註冊，然後可以在addthis時時更改樣式． _config.icarus.yml123share:+ type: addthis+ install_url: '要填入正確' 起在本地就可以看到效果了． 評論功能依照 Icarus用户指南 - 用户评论插件 內有多種評論平台，我目前是直接使用 Facebook． _config.icarus.yml12comment:+ type: facebook 起在本地就可以看到效果了． 贊助按鈕依照 Icarus用户指南 - 赞赏按钮 說明設定，選擇可以收款的方式． 123456789101112131415161718192021donates: - type: afdian url: '' - type: alipay qrcode: '' - type: buymeacoffee url: '' - type: patreon url: '' - type: paypal business: '' currency_code: USD - type: wechat qrcode: '' 網路參考文章 本篇文章內容參考如下 AddThis 詳細的操作可以看這邊 AddThis 現已免費！一行程式碼為網站加入分享追蹤按鈕，整合電子報等行銷功能 Hey,I created a page here. You can now buy me a coffee!","link":"https://minilabmemo.github.io/2023/02/27/blog-hexo-06-share/"},{"title":"[Blog] 使用 Hugo 撰寫部落格","text":"本章介紹如何在套用 hugo 做好一個自己的部落格網站．並上傳 github 2020.09 更新： 因為找不到主題可以將文章標題透過階層式瀏覽，所以後來改用 hexo（就是現在這邊網站用的樣式），使用上部署也較 hugo 方便，本篇紀錄當時的 hugo 建立留存． 建立部落格前可以先分別上 hexo/hugo 官網查看主題效果，看自己喜歡哪一種再建立． hexo 教學文請看： 使用Ｈ exo 撰寫部落格 gohugo作者Steve Francia Step 1: 安裝 Hugo開啟終端機，依序執行下列指令： 12345678* brew install hugo//macOs 須先安裝Homebrew* hugo version//確認安裝成功版本Hugo Static Site Generator v0.69.0/extended darwin/amd64 BuildDate: unknow* hugo new site **website-hugo*** cd **website-hugo**// 新增網站，粗體可以自命名，安裝完會新增該資料夾 Step 2: 新增主題https://themes.gohugo.io/hugo 網站有很多可以選擇與查看效果進入該主題的 github/README 可以看安裝步驟執行基本執行：git submodule add https://github.com/alex-shpak/hugo-book themes/book//這樣就會在website-hugo/themes/新增主題 Step 3: 編輯 config.toml這檔案與整體網站設定有關 baseURL = “https://xxx.github.io/&quot;languageCode = “zh-tw”title = “xxx Blog” #domain 設定 xxx 改成你的 GitHub 帳號名稱 根據主題不同 這檔案也可能會有更多不同設定ex: 設定主題 theme = “ananke” Step 4: 新增文章 hugo new posts/my-first-post.md新增預設檔案在以下位置 採用 markdown 編寫content//. title: “My First Post”date: 2019-03-26T08:47:11+01:00draft: true //是草稿是否 改成 false 可被發布 可以根據主題新增：tags: [“hugo”, “web”]summary: “The summary image should be a custom one”summaryImage: “summary_2.jpg”resources: src: summary_2.jpg 圖片新增將圖片放置在 website-hugo/static/images文章內可用相對路徑新增 Step 5: 啟動本地 server hugo server -DWeb Server is available at http://localhost:1313/Press Ctrl+C to stop記得結束務必按 不然下次啟動會佔用 Step 6: 產生靜態檔案Ｄ 參數代表要不要輸出草稿文章Build static pages hugo -D 將會生成./public/ 資料夾，每次編輯完要記得更新，之後發布的時候也要上傳 Step 7:githug 網站上傳新增兩個 repoxxx.github.io (xxx 改成自己的帳號名稱)website-hugo 上述的 site 名稱 上傳 public 資料夾 cd publicgit initgit remote add origin https://github.com/xxx/xxx.github.io.gitgit add .git commit -m “Initial commit”git push -u origin master 上傳整個 website-hugo 資料夾 cd ../git initgit remote add origin https://github.com/xxx/website-hugo.gitgit add .git commit -m “Initial commit”git push -u origin master 開啟https://xxx.github.io/ 等個幾分鐘會看到結果 note class_name %} #### 參考文章 ＨＵＧＯ官網 在-github-部署-hugo-靜態網站","link":"https://minilabmemo.github.io/2020/09/01/blog-hugo/"},{"title":"[前端][✍練習][🚧進行中]紀錄有關在前端console 中debug的指令","text":"紀錄有關在 console 中 debug 的指令 [✍ 持續更新] 複製內容一般來說可以在 console 中印出陣列，但 console 會顯示階層式的物件，如果想要複製單純內物件內容，就要透過下列動作達成： Right-click an object in Chrome’s console and select Store as Global Variable from the context menu. It will return something like temp1 as the variable name. Chrome also has a copy() method, so copy(temp1) in the console should copy that object to your clipboard. 123456(9) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]temp1(9) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]copy(temp1)JSON.stringify(temp1)&quot;[{&quot;name&quot;:&quot;Cupcake&quot;,&quot;pri&quot;:1,&quot;status&quot;:&quot;OPEN&quot;,&quot;type&quot;:&quot;blog&quot;,&quot;protein&quot;:4.3},{&quot;name&quot;:&quot;Donut&quot;,&quot;pri&quot;:2,&quot;status&quot;:&quot;OPEN&quot;,&quot;type&quot;:&quot;go&quot;,&quot;protein&quot;:4.9}]&quot; Javascript / Chrome - How to copy an object from the webkit inspector as code note class_name %} # 網路參考文章","link":"https://minilabmemo.github.io/2020/10/01/console-debug/"},{"title":"[docker]常用docker指令筆記整理","text":"常用docker指令筆記整理 啟動imagedocker run使用docker有兩種方式，docker hub 有些會寫好內容 ex:mongo-docker hub 一種是直接下docker run，再下對應參數，下一次起一個程式。 ex:docker run -v D:\\home/work:/home/work –name myub -it ubuntu bash –name 替container取名 -p（小寫） hostPort對應containerPort -v 分享空間 -it 代表在執行Docker 虛擬容器環境時，開啟虛擬終端機，以互動的模式執行 –cpus=1.5 限制 CPU 使用量 –memory=300m –memory-swap=1g 限制記憶體與 swap 交換空間的用量 docker-compose 另一種是把它寫成docker-compose.yml方式，可以一次啟動多個程式。有些image會提供已編寫好的內容。 docker-compose up -d 啟動，-d detached 在背景執行 docker-compose stop 停止容器 docker-compose down 刪除容器 其他常用指令基本操作 $docker –versionDocker version 18.09.2, build 6247962 查看簡易docker版本 docker ps 查看正在啟動的CONTAINER與ID docker stop ‘CONTAINER_ID’ 停止 Docker 容器 docker kill ‘CONTAINER_ID’ 強制停止 Docker 容器 docker restart ‘CONTAINER_ID’ 重新啟動 Docker 容器 docker ps -a -a :顯示所有的容器，包括未運行的 docker search ‘ubuntu’ docker search ‘xxx’ 查詢可下載 image docker pull ‘ubuntu’ docker pull ‘xxx’ 下載 image docker images 查看下載image與ID docker system df 查看使用的磁盘空间 -v more detail 查看個別container docker stats 查看容器使用的系统资源 每隔 1 秒刷新 docker stats –no-stream 查看容器當前的系統資源 docker stats ‘CONTAINER ID or name’… 指定查看特定容器 備份系列 docker cp ‘CONTAINER ID’:/xx local Ex: docker cp 9e701a5209fe:/data/db C:/test_temp 複製CONTAINER內資料出來本地 docker save 備份 Docker Image 清理指令系列清理指令系列另外寫:因為image都有一定的大小，使用完不用要記得清除。 docker rm ‘CONTAINER_ID’ 刪除 container docker rmi ‘image_ID’ 刪除 image docker rm $(docker ps -a -q) 刪除所有容器(container)//在powershell下才有用 docker stop $(docker ps -a -q) 停止所有容器 //在powershell下才有用 參考文章1.Docker 常用指令與容器操作教學2.谁用光了磁盘？Docker System命令详解3.清理Docker，删除没用的文件4.查看 docker 容器使用的资源","link":"https://minilabmemo.github.io/2020/10/31/docker-cli/"},{"title":"[docker] 建立elasticSearch儲存資料與kibana呈現使用","text":"本章介紹使用elasticSearch儲存資料與kibana呈現使用 本文內容： 自行建立elasticSearch/kibana [docker] 建立elasticSearch index與傳送資料 使用kibana查詢資料 1.啟動docker-elasticSearch/kibana 先備知識:docker &amp; docker-compose 先將網路上找到的docker-compose.yml內容編輯好，然後在一樣的目錄下開啟指令docker-compose up -d 1234$docker-compose up -dWARNING: Some services (elasticsearch, kibana) use the 'deploy' key, which will be ignored. Compose does not support 'deploy' configuration - use `docker stack deploy` to deploy to a swarm.Starting elasticsearch-624 ... doneStarting kibana-624 ... done 需要一點時間，可以用Kitematic之類的工具查看有沒有成功 GET localhost:9200 確認elasticSearch是否啟動成功會回版號等資訊 “number”: “6.2.4” 開啟瀏覽器，確認kibana有無成功http://127.0.0.1:5601/app/kibana#/home?_g=() 2.準備資料與index 先設計資料內容，假設今天要收集一個使用者每天的運動紀錄這是一個有array的紀錄內容，內容可長可短。1234567891011121314151617181920{ &quot;user&quot;: &quot;user01&quot;, &quot;timestamp&quot;: 1583734521000, &quot;records&quot;: [ { &quot;record_name&quot;: &quot;heart_rate&quot;, &quot;data_number&quot;: 80, &quot;data_txt&quot;: &quot;avg&quot; }, { &quot;record_name&quot;: &quot;Calories&quot;, &quot;data_number&quot;: 200 }, { &quot;record_name&quot;: &quot;time_duration&quot;, &quot;data_number&quot;: 30, &quot;record_unit&quot;: &quot;min&quot; } ]} 接著新增必須欄位的屬性index user是一般text,timestamp是date records先建立nested巢狀，在建立裡面的record_name等欄位。 建立index: PUT localhost:9200/{index}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172PUT localhost:9200/event{ &quot;mappings&quot;: { &quot;_doc&quot;: { &quot;properties&quot;: { &quot;user&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } }, &quot;id&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } }, &quot;timestamp&quot;: { &quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;epoch_millis&quot; }, &quot;records&quot;: { &quot;type&quot;: &quot;nested&quot;, &quot;properties&quot;: { &quot;record_name&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } }, &quot;data_number&quot;: { &quot;type&quot;: &quot;long&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } }, &quot;data_txt&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } }, &quot;record_unit&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } } } } } } }} 送資料進去 接著把上述資料先送一筆進去 http://localhost:9200/{index}/{type}POST http://localhost:9200/event/_doc kibana建立index 建立indexManagement頁面-&gt;create index-&gt;填入event-&gt;選擇可以做時間分割的欄位名稱{上述是用timestamp}-&gt;按下create index pattern Discover頁面搜尋資料再送一次資料，這次把 “timestamp”: {改成現在時間戳}-&gt;線上有很多工具可以做轉換回到Discover頁面，query最近15分鐘的資料-&gt;就可以看到時間軸了 Visualize 建立感興趣的圖表展示ex: table顯示/長條圖顯示等/或是特定filter資料。然後替圖表存檔。 Dashboard 頁面這邊把剛剛建立的圖表拉好顯示在這邊。 dev tools 頁面透過條件指令搜尋特定資料，如有程式需要可以用搜尋API試著找出自己想搜尋的內容 size/page/sort 分頁與排序依據 bool query 條件-filter時間/range/match/wildcard等搜尋 所有 must 必须匹配，所有 must_not 都必须不匹配 minimum_should_match 參數控制需要匹配的 should 語句的數量 範例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394GET /event/_search{ &quot;size&quot;: 1000, &quot;query&quot;: { &quot;bool&quot;: { &quot;filter&quot;: { &quot;range&quot;: { &quot;timestamp&quot;: { &quot;from&quot;: 159132465000, &quot;include_lower&quot;: true, &quot;include_upper&quot;: true, &quot;to&quot;: 1591324650099 } } }, &quot;must&quot;: [ { &quot;exists&quot;: { &quot;field&quot;: &quot;user&quot; } }, { &quot;match&quot;: { &quot;user&quot;: { &quot;operator&quot;: &quot;AND&quot;, &quot;query&quot;: &quot;user01&quot; } } }, { &quot;nested&quot;: { &quot;path&quot;: &quot;records&quot;, &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: [ { &quot;match&quot;: { &quot;records.record_name&quot;: { &quot;operator&quot;: &quot;AND&quot;, &quot;query&quot;: &quot;heart_rate&quot; } } }, { &quot;wildcard&quot;: { &quot;records.data_txt&quot;: &quot;*a*&quot; } }, { &quot;range&quot;: { &quot;records.data_number&quot;: { &quot;from&quot;: 2, &quot;include_lower&quot;: false, &quot;include_upper&quot;: true, &quot;to&quot;: null } } } ] } } } } ], &quot;minimum_should_match&quot;: &quot;1&quot;, &quot;should&quot;: [ { &quot;match&quot;: { &quot;user&quot;: { &quot;operator&quot;: &quot;AND&quot;, &quot;query&quot;: &quot;user01&quot; } } }, { &quot;match&quot;: { &quot;user&quot;: { &quot;operator&quot;: &quot;AND&quot;, &quot;query&quot;: &quot;user02&quot; } } } ] } }, &quot;sort&quot;: [ { &quot;timestamp&quot;: { &quot;order&quot;: &quot;desc&quot; } } ]} 網路參考文章 note warning %} 學習路上感謝網路大神們，如果你發現了我，可以查看參考文章了解更多概念👇👇👇 elastic-組合查詢 中文","link":"https://minilabmemo.github.io/2021/04/24/docker-elastic-kibana/"},{"title":"[docker&#x2F;mongo]使用docker啟動mongo與操作","text":"什麼是mongo MongoDB是NoSQL的資料庫，以文件儲存資料，一般資料庫開Table須定義欄位(大小、型別、名稱等)，但是Collection完全不事先定義欄位，每筆document可以有不等數量的欄位 本文將會知道： 使用docker-compose 快速啟動mongodb 須先下載docker並具docker-compose知識 簡單的工具操作與MongoDB Shell 更新批量資料 與關聯式資料庫名詞對應： MongoDB RDBMS 意思 db DB 資料庫 collection Table 表格 document record 一筆紀錄 1.啟動mongo docker這邊直接用編輯docker-compose.yml 貼上網路找到的內容 123456789101112version: '3.1'services: mongo: image: mongo ports: - &quot;27017:27017&quot; restart: always environment: MONGO_INITDB_ROOT_USERNAME: root MONGO_INITDB_ROOT_PASSWORD: example 啟動 123➜ mongo git:(master) ✗ docker-compose up -d Creating network &quot;mongo_default&quot; with the default driverCreating mongo_mongo_1 ... done 2.操作資料內容以下可用透過一些網上mongo工具 ex Robo3T操作 先進行連線進入介面host: localhost, port: 27017 CreateDB”test”，新增一筆Collection”user”，與新增Documanet如下(Json格式) 1234567{ &quot;profile&quot; : { &quot;name&quot; : &quot;user1&quot;, &quot;gender&quot; : &quot;F&quot;, &quot;age&quot; : 18 }} 新增完會自動產生唯一的objectID，透過工具也可以對資料做簡單的修改動作。 3.mongo shell 可以再有提供shell指令視窗的工具上下指令去做更新進階的搜尋， 例如mongo 3T上方就有視窗可以使用． 搜尋指令搜尋全部1db.getCollection('user').find({}) 搜尋by_id1db.getCollection('user').find({_id:ObjectId(&quot;5eaa780f3dfac43981e4412c&quot;)}) 限制顯示的欄位: 1可見,0不可見12345db.getCollection('user').find({},{profile.name:1})有一點像是SELECT profile.name FROM user_id預設顯示，可以關掉_id:0 搜尋內容值1db.getCollection('user').find({&quot;profile.name&quot;:&quot;user1&quot;}) 搜尋範圍 數字型態12[gt大於，gte大於等於，lt小於，lte小於等於]db.getCollection('user').find({&quot;profile.gender&quot;:&quot;F&quot;,&quot;profile.age&quot;:{$gt:2,$lte:18}}) 搜尋範圍 字串型態12按UTF-8進行字典排序 表搜尋字母A~Z間db.getCollection('user').find({&quot;profile.name&quot;:{$gt:&quot;a&quot;,$lte:&quot;z&quot;}}) 排序12依命名排序，其中 1 为升序排列，而 -1 是用于降序排列db.getCollection('user').find({}).sort({name:1}) 顯示筆數(limit)與開始(skip)12可以用他來做分頁讀取db.getCollection('user').find({}).sort({name:1}).skip(0).limit(2) 計算總數1db.getCollection('user').find().count() 批次更新一般來說工具就可以做內容更新，但如果需要透過指令， 更新欄位將性別欄位“F”全改成“woman” 12345678db.getCollection('user').find().forEach( function(d) { if(d.profile.gender==&quot;F&quot;){ d.profile.gender=&quot;woman&quot; db.getCollection('user').update({&quot;profile.name&quot;:d.profile.name},d); print(d.profile.name+&quot; process change done&quot; ); };}); 新增欄位合併內容12345db.getCollection('user').find().forEach( function(d) {d.description= d.profile.name+&quot;,&quot;+d.profile.gender;db.getCollection('user').update({&quot;profile.name&quot;:d.profile.name},d); print(d.profile.name+&quot; process change done&quot; ); }); 刪除欄位12345db.getCollection('user').find().forEach( function(d) {delete d.descriptiondb.getCollection('user').update({&quot;profile.name&quot;:d.profile.name},d); print(d.profile.name+&quot; process change done&quot; ); }); 如果是要在mongo的docker環境上面下指令需要把指令包成js，檔案丟進去docker裡面，然後下指令12load(&quot;script/Change.js&quot;) //檔案位置mongo 127.0.0.1:27017/test Change.js 執行結果與上述內容一樣 本章對mongo的簡單操作到此結束，之後再介紹如何用golang程式去對mongo CRUD操作．","link":"https://minilabmemo.github.io/2020/09/12/docker-mongo/"},{"title":"[Docker]快速啟動可用VNC進去連線之ubuntu","text":"一般來說docker可以快速去建立一個ubuntu環境，但如果習慣畫面操作，還需要再安裝VNC設定，不知道有沒有人做好的VNC版本呢? 網路上找到一個docker image專案可以做到這件事-&gt;docker-ubuntu-vnc-desktop 遵照git readme指示啟動:網頁版本連線Quick Start Run the docker container and access with port 6080 docker run -p 6080:80 -v /dev/shm:/dev/shm dorowu/ubuntu-desktop-lxde-vncBrowse http://127.0.0.1:6080/ VNC 版本連線docker run -p 6080:80 -p 5900:5900 -v /dev/shm:/dev/shm dorowu/ubuntu-desktop-lxde-vnc 下載VNC工具realvnc 啟動之後連VNC(local:127.0.0.0)就可以一樣看到畫面了","link":"https://minilabmemo.github.io/2020/09/14/docker-ubuntu-vnc/"},{"title":"[command]使用內建指令快速產生大黨","text":"開發時有時會需要測試大檔案的上傳，因此需要先準備大檔案，而系統內建就有一些指令可以快速產生虛胖的檔案． windows環境 Fsutil 是用於執行與檔案配置表 (FAT) 和 NTFS 檔案系統相關的工作，例如管理重新剖析點、管理稀疏檔案或卸載磁片區。必須以系統管理員身分執行，才能使用 fsutil。 更多功能請見microsoft fsutil fsutil file createnew 用法 fsutil file createnew 位置 &lt;FileName.txt&gt; &lt;FileSize(size in bytes)&gt;12345C:\\WINDOWS\\system32&gt; fsutil file createnew /?使用方法 : fsutil file createNew &lt;filename&gt; &lt;length&gt; 例如 : fsutil file createNew C:\\testfile.txt 1000C:\\WINDOWS\\system32&gt;fsutil file createnew C:\\testfile.txt 1000檔案 C:\\testfile.txt 已經建立 自行計算一下產生不同大小的檔案1234fsutil file createnew C:\\1kb.txt 1000 //產生1kb檔案至指定位置fsutil file createnew large_10m.txt 10485760 //10*1024*1024fsutil file createnew large_500m.txt 524288000 //500*1024*1024fsutil file createnew large_1g.txt 1073741824 //1*1024*1024*1024 Mac 環境在Ｍac環境使用更方便，不需計算大小，使用內建的 mkfile 指令就可以輕鬆建立了： mkfile -n size[b|k|m|g] filename1mkfile -n 20m 20mb.txt 網路參考文章Quickly Generate Large Test Files in Windows[Mac] 使用 mkfile 指令，快速建立測試用的大檔","link":"https://minilabmemo.github.io/2021/04/20/fake-file/"},{"title":"GitHub 建立首頁個人頁面介紹","text":"GitHub創立完帳號之後 其實可以產生profile 個人頁面，就可以在自己的首頁加上更多介紹！ 如何建立自己的 GitHub 個人頁面： 建立帳號同名 Repository 修改 README.md 完成! 到首頁看看效果 看看我的效果＝&gt;https://github.com/minilabmemo 網路上還有更多很酷的個人介面介紹與產生器，可以參考以下文章: 如何建立獨一無二的 GitHub Profile！與三個很酷的設計及應用 🚀 profile Generator這工具幫你產出介紹還有技能樹圖示!!!","link":"https://minilabmemo.github.io/2021/01/11/github-profile-page/"},{"title":"[deploy]將網頁程式部署到heroku運行","text":"Heroku是一個支援多種程式語言的雲平台即服務，免費版提供每個月平台550小時時間，但每 30 分鐘未使用都會休眠一次，需等待他從休眠時間中甦醒，時間大約 30 秒左右． 註冊 heroku 先上官網註冊一個帳號 安裝 heroku CLI參考：https://devcenter.heroku.com/articles/heroku-cli#download-and-install 安裝 123456789 ➜ testmemooo git:(master) heroku version › Warning: heroku update available from 7.40.0 to 7.43.0.heroku/7.40.0 darwin-x64 node-v12.16.2➜ testmemooo git:(master) npm install -g heroku/usr/local/bin/heroku -&gt; /usr/local/lib/node_modules/heroku/bin/run+ heroku@7.43.0added 788 packages from 316 contributors in 54.332s➜ testmemooo git:(master) heroku versionheroku/7.43.0 darwin-x64 node-v10.16.3 登入heroku login 查看每個月使用多少時間 Account Setting-&gt;Billing-&gt; Free Dyno Usage 部署 React方式一：兩分鐘 0 配置快速部署 官方已先配置好並照說明指令輸入即可Deploying React with Zero Configuration 123456789npm install -g create-react-appcreate-react-app '自命名專案'cd '自命名專案'git initheroku create -b https://github.com/mars/create-react-app-buildpack.gitgit add .git commit -m &quot;react-create-app on Heroku&quot;git push heroku masterheroku open 其中中間那一句 heroku create 會在剛剛的網站上新增一個 damp-stream-02723 專案最後一句是開啟網站：https://damp-stream-02723.herokuapp.com/這樣就看到網站了，命名應該是隨機的，但實際測試可以透過以下方式改名 更換專案名稱登入該網站後直接在專案上改名字之後要回到專案上改 git 上傳的位置update git remote 1234567891011使用指令git remote rm heroku刪除舊有的 remote ‘heroku’➜ demomemooo git:(master) git remote rm heroku使用heroku指令綁定heroku git:remote -a newname➜ demomemooo git:(master) heroku git:remote -a demomemooo › Error: Couldn't find that app. › Error ID: not_found這邊會失敗是因為當時還沒有在網站上更名➜ demomemooo git:(master) heroku git:remote -a demomemoooset git remote heroku to https://git.heroku.com/demomemooo.git https://demomemooo.herokuapp.com/ 小提醒：之後如果要更新記得先在本地起看看，並且照一般在 vscode 操作 git 上傳即可． 部署設定： 保護源代碼設定GENERATE_SOURCEMAP環境變數可以使得源代碼不會出現在dev tool中顯示add into package.json:1234&quot;scripts&quot;: { &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;GENERATE_SOURCEMAP=false react-scripts build&quot;,} 現有專案上傳1234567cd '現有專案'heroku create -b https://github.com/mars/create-react-app-buildpack.git專案內容看不到有什麼變化＠＠ 但本地專案會多連接一個heroku遠端git連結遠端heroku網站上一樣會多一個隨機命名的專案被建立．git push heroku master上傳，會直接執行build/deploy，等待它完就可以了．heroku open 方法二 自行建立設定 先建立 React 命名 testdemooo 1create-react-app testdemooo 進入後 按 New-&gt;Create New App 輸入命名新增一個專案(ex testdemooo) 產生完會有部署指令，照做即可 12345678910新的 Git repository 需做$ cd my-project/$ git init$ heroku git:remote -a testmemooo針對已存在Git repository，簡單新增“ heroku remote$ heroku git:remote -a testmemooo 但這樣做打開網站會錯誤，以下面文章的最佳解答照做即可React 專案佈署 heroku 問題大致上做法是自行建立 server.js 與產生 build，只需要推 build 檔案上去即可（記得 gitignor 要拿掉 build folder） note class_name %} ## 網路參考文章 Deploying create-react-app project isn’t uglifying my code React Create Script 2.0 減少維護環境配置","link":"https://minilabmemo.github.io/2020/09/18/heroku-deploy/"},{"title":"[JAVA]有關java之OutOfMemory檢測等相關問題文章整理","text":"有關java之OutOfMemory檢測等相關問題文章整理 關於JVM1234-Xms = 初始值，預設是實體記憶體的1/64-Xmx = 最大值，預設是實體記憶體的1/4-Xmn = 最小值預設空餘堆記憶體小於40%時，JVM 就會增大堆直到-Xmx 的最大限制。 一图解千愁，jvm内存从来没有这么简单过！ 該文建議使用操作系统的2/3作为堆空间，是比较合理的。这是一个经验值。比如6GB的内存，你分配给JVM的，最好不要超过4GB。 淺談 JVM PermGen space 的解決方法 調整JVM可以透過以下的參數來修改它，不過應該不要刻意去加大給它的分配記憶體，因為遇到需要大量的請求不多，怕造成記憶體的浪費，應該是從程式面下手修正程式效能(又是一課題了Orz)。 開發時 IDE 設定 12IDE JAVA_OPTS=&quot;-Xmx900m -Xms900m&quot; 修改jvm.cfg調整JVM虛擬機器記憶體大小 執行jar包的時候參數調整1java -Xmx900m -Xms900m jar app.jar tomcat/Resin/weblogic 等設定完美解決java.lang.OutOfMemoryError處理錯誤的問題 調整JVM參數說明 深入理解JVM內幕之JVM簡單調優參數 Xmx和Xms設置一樣大，MaxPermSize和MinPermSize設置一樣大 關於OutOfMemoryError追查專案出現記憶體溢位的原因及解決方案重點: 修改JVM啟動引數，直接增加記憶體。(-Xms，-Xmx引數一定不要忘記加。) 檢查錯誤日誌，檢視“OutOfMemory”錯誤前是否有其它異常或錯誤。 對程式碼進行走查和分析，找出可能發生記憶體溢位的位置。 使用記憶體檢視工具動態檢視記憶體使用情況 Eclipse開啟Show Heap Status IntelliJ IDEA 可開啟Memory Indicator &amp; debugger Memory頁籤(可參考下方檢測工具@IDEA標題) 程式面與錯誤訊息範例 關於集合物件未清除的範例List、MAP等集合对象是否有使用完后,未清除造成内存溢出 Map &amp;Java heap space 無限迴圈Java記憶體溢位(OOM)異常排查指南 內含更多錯誤示例解說OutOfMemoryError: Java heap spaceOutOfMemoryError: GC overhead limit exceededOutOfMemoryError:Permgen spaceOutOfMemoryError:MetaspaceOutOfMemoryError:Unable to create new native threadOutOfMemoryError:Out of swap space?OutOfMemoryError:Requested array size exceeds VM limitOut of memory:Kill process or sacrifice child 檢測工具@IDEAIntelliJ IDEA 可開啟Memory Indicator &amp; debugger Memory頁籤 (可參考說明開啟: show-heap-memory-size-in-intellij Analyze objects in the JVM heap) 關於IDEA如何设置JVM参数IDEA如何设置JVM参数菜鸟学习IntelliJ IDEA之如何设置JVM运行参数 關於IDEA debugger Memory頁籤用來查看目前堆中類的個數的情况，右邊的diff會顯示跳轉類的變化 過去看來是透過plugin去安裝JVM Debugger Memory View，但我在plugin 已找不到這個，且官網支援的版本也沒有了，但在IEDA 2020.1 debugg時多出的Memory tab，似乎與這功能一模一樣。說明網站:神兵利器－内存调试插件IDEA中很有用的內存調試插件使用多年的go pprof检查内存泄漏的方法居然是错的?! 使用jvm監控工具命令一般用於檢視服務執行時狀態的主要命令包括：jstat、jmap、top、jstack 基本工具介紹 Java內存泄露監控工具","link":"https://minilabmemo.github.io/2020/11/14/java-jvm-memory/"},{"title":"[JAVA] spring 非同步事件","text":"spring 加上 Fire and forget，非同步處理，發出處理後就不用等待回復繼續做其他事情 1.找到@Configuration 的地方加上@EnableAsync 1234@Configuration@EnableAsyncpublic class XxxConfig {} 2.找到想要執行非同步的方法上方加上 @Async 1234567@Componentpublic class MyComponent { @Async void doSomething() { // this will be executed asynchronously }} 如果想要拿到回傳的地方可以在 Future拿到結果。 12345678@Componentpublic class MyComponent { @Async Future&lt;String&gt; doSomething(String s, int i, long l, Object o) { // this will be executed asynchronously return new AsyncResult&lt;&gt;(&quot;result&quot;); }} 3.異常處理 TBD這塊自己是用 restTamplate 發出訊息，但無奈可以 catch 到錯誤，卻無法做錯誤輸出整理。留下文章待做研究。 note class_name %} 網路參考文章 spring-background-fire-and-forget-processing Spring Boot(5) @Async 非同步執行緒池詳解 Spring 中@Async 用法與異常處理Spring 中@Async 用法","link":"https://minilabmemo.github.io/2021/01/30/java-spring-asnc/"},{"title":"整合測試工具 jmeter 初體驗","text":"什麼是 JMeter **Apache JMeter™** 是開源軟件，是一個 100% 純 Java 應用程序，旨在加載測試功能行為和測量性能， /div> 使用時機當需要對 API 做整合測試並驗證回覆時使用． 本文將會知道： 使用測試工具 JMeter 做一連串 API 測試 解析回覆json與驗證 啟動在windows下使用 下載並開啟時執行黨 (jmeter=”5.2.1”) 如果需要解析json，需自行放入lib,xxx.jar 範例：Get APIs以下這個範例是根據詢問一個Http [list]，再根據回覆去一個個問另一支API，最終希望檢視結果 API 都回覆 200 OK． 請依序新增對應設定，可以右鍵disable/enable該群組 按下執行就可以從檢視結果樹看到結果 測試計畫 使用者自訂變數; 執行緒群組 簡易控制器: 簡易命名 HTTP 標頭管理員 Authorization:Bearer ${token} HTTP 要求 arrays BeanShell PostProcessor JSON Extractor disabled ForEach 控制器 HTTP 要求 by id 驗證回覆 Debug Sampler 檢視結果樹 這個測試檔案：sample.jmx 處理器細節：自訂變數/引用變數當自訂toekn=xxx時就可以用${token}拿到變數． HTTP 要求 arrays這是一個API 會直接回覆 arrays 如下： 1234567891011[ { &quot;id&quot;:&quot;1&quot;, &quot;name&quot;:&quot;123&quot; }, { &quot;id&quot;:&quot;2&quot;, &quot;name&quot;:&quot;233&quot; }] BeanShell PostProcessor (java語法)處理json資料，並透過vars.put（key,value）設定資料給下一步使用 這邊會需要debug比較麻煩，可以另外從上方視窗叫出log來查看問題出在哪裡1234567891011121314151617181920212223import org.json.JSONObject;import org.json.JSONArray;try{ String response = &quot;&quot;;response = prev.getResponseDataAsString();log.info(&quot;responsessss：&quot; + response);JSONArray jsonArray = new JSONArray(response);for (int i=0; i &lt; jsonArray.length(); i++) { JSONObject o= jsonArray.getJSONObject(i); String name = o.getString(&quot;name&quot;); String id = o.getString(&quot;id&quot;); log.info(&quot;name：&quot; + name); vars.put(&quot;data_&quot;+i,id);}catch (Throwable ex) {log.error(&quot;Error in Beanshell&quot;, ex);throw ex;} ForEach 控制器在使用之前必須有資料是[data_1:xxx,data_2:xxx….]  變數前置字串為data，start index:-1，輸出變數名稱，d  這時下一層的HTTP 要求 by id就可以引用${d} 驗證回覆可以驗證回復，如果要驗證的是500，可以勾選Ignore status。 Debug Sampler 可以查看過程中變數內容 （未完待續） 壓力測試網路參考文章 Jmeter断言中判断请求失败的响应代码问题 找不到斷言，但有驗證回復 Meter - JSON variable in a ForEach Controller","link":"https://minilabmemo.github.io/2022/07/01/jmeter/"},{"title":"[JS 筆記 02] 同步與非同步","text":"延續學習ＪＳ的同步與非同步概念 ☝☝本記錄為個人學習整理，如有誤還請您不吝指教，也有引用文章位置，如有問題也請告知． 同步 vs 非同步 同步 一個線程是一個基本的處理過程，程序用它来完成任務。每個線程一次只能執行一个任務 JavaScript 是一種同步的、阻塞的、單線程的语言。即使有多個ＣＰＵ，也只能在單一線程上運行多個任務，此線程稱為主線程 異步/非同步 用法 很多網頁API都使用異步代码，特别是從外部的設備來或許資源，譬如，抓取網路上文件，訪問DB，獲取影片流等等，在瀏覽器端只有一個使用者，但事件或網路要求(AJAX)要求不能阻塞其他程式的進行，通常需要等待一段時間後才會返回，所以需要讓使用者可以繼續進行目前的畫面操作． JS有分為同步及異步callback，setTimeout與setinterval是種異步函數。 label warning@而所有的同步回調函式都執行完成了，才會開始依順序執行異步的回調函式 %}。 異步 callbacks異步callback(回調)其实就是函数，只不過是作為參數傳遞给那些後台执行的其他函数. 讓會造成阻塞的程式組成一個異步回調函式，先丟往一個任務佇列(task queue)先丟，當某個時間後台運行的代碼结束，就调用callbacks函数，通知你工作已经完成， 什麼是callback function？ callback 將函數作為參數作為傳遞 讓函式控制參數函式的執行時機 ex 有的情境是當A作完再作B 使用上會有問題在於callback hell回呼地獄，不易閱讀 –&gt;老派callbacks(會有回呼地獄)，新派promise Promises Promises 是新派的异步代码 具有fetch(來源黨或url) 可以有多個then(func 回乎，當前一個成功後呼叫) 其中任何一个then()块失败，则在末尾运行catch() –&gt;避免callback hell，錯誤不是在“金字塔”的每一层单独处理。 還有其他.all()…等func，Promise.all 等到全部實現（或一個拒絕）。詳細請見：MDN-Promise aync/await ECMAScript 2017 JavaScript版 基于promises的语法糖，使异步代码更易于编写和阅读，讓非同步的程式碼讀起來更像在寫「同步程式碼」 async function 回傳的一樣是 Promise 物件，可以混合使用.then 語法 await 關鍵字 等待這個非同步的作業完成 Promises寫法123456789fetch('test.json') .then(response =&gt; response.json()) .then(myData =&gt; { console.log(myData.name); }) .catch(e =&gt; { console.log('catch a problem: ' + e.message); }); await/aync 寫法1234567891011async function myFetch() { let response = await fetch('test.json'); let myData = await response.json(); console.log(myData.name); } myFetch() .catch(e =&gt; { console.log('catch a problem: ' + e.message); }); Promises & await/aync混合用法12345678910async function myFetch2() { let response = await fetch('test.json'); return await response.json();}myFetch2().then((myData) =&gt; { console.log(myData.name);}).catch(e =&gt; { console.log('catch a problem: ' + e.message);});; 網路參考文章 MDN-异步JavaScript简介 你懂 JavaScript 嗎？#23 Callback MDN-async和await:让异步编程更简单 MDN-response","link":"https://minilabmemo.github.io/2021/02/20/js-start-02/"},{"title":"[linux][紀錄]在linux環境下指令操作","text":"紀錄在linux環境下使用command line如何下指令操作 如果曾經維護管理過linux介面環境，或是管理部署，都會需要在命令列介面環境下操作，所以需要了解基礎的指令操作，本篇純記錄用過的linux CLI指令．如果沒有linux環境可以參考另一篇 [Docker]快速啟動可用VNC進去連線之ubuntu，就可以快速練習喔． ＊命令列介面（英語：Command-Line Interface，縮寫：CLI）是在圖形使用者介面得到普及之前使用最為廣泛的使用者介面，它通常不支援滑鼠，使用者通過鍵盤輸入指令，電腦接收到指令後，予以執行。也有人稱之為文字使用者介面（character user interface, CUI）- 維基百科。 系統相關資訊ref:linux查詢作業系統資訊，CPU物理個數，CPU核心數，邏輯CPU數，記憶體資訊查詢，硬碟資訊查詢 查詢記憶體大小123456789可以用下述指令:free free -m //單位cat /proc/meminfoaaaa@el1000:~$ free -m total used free shared buff/cache availableMem: 31985 17605 3437 71 10941 15137Swap: 0 0 0 查詢CPU資訊 查看 CPU 物理個數aaaa@el1000:~$ grep ‘physical id’ /proc/cpuinfo | sort -u | wc -l1 查看 CPU 核心數量aaaa@el1000:~$ grep ‘core id’ /proc/cpuinfo | sort -u | wc -l8 查看 CPU 執行緒數aaaa@el1000:$ cat /proc/cpuinfo| grep “processor”|wc -l16aaaa@el1000:$ grep ‘processor’ /proc/cpuinfo | sort -u | wc -l16 查看 CPU 型號aaaa@el1000:~$ cat /proc/cpuinfo | grep name | sort | uniqmodel name : Intel(R) Xeon(R) CPU D-1548 @ 2.00GHz 基本路徑操作12345678pwd 目前位置mkdir folder 創建資料夾mkdir -p folder 如果目錄已存在則不會報錯mkdir -p Project/a/src 创建多级目录 mkdir -ptouch 檔名.txt 新增空白檔案ls 列出 -a 含隱藏檔案cd 進入cat filename 直接檢視檔案內容 檔案文件權限查看 ls -l 123-l 參數可以顯示檔案與目錄的詳細資訊。-h 參數可以讓輸出的資訊以比較容易閱讀的格式呈現。 -rwxr-xr-x 意思1234第一位表示文件的類型，-爲文件，d爲目錄之後每三位代表即用戶、組用戶、其他用戶其中r表示讀、w表示寫、x表示可執行-表示沒有權限 Linux 系统中采用三位十进制数表示权限，如0755， 0644. 一般赋予目录0755权限，文件0644权限。123456789101112131415161718190755ABCDA- 0， 表示十进制B－用户C－组用户D－其他用户 --- -&gt; 0 (no excute , no write ,no read)--x -&gt; 1 excute, (no write, no read)-w- -&gt; 2 write -wx -&gt; 3 write, excuter-- -&gt; 4 readr-x -&gt; 5 read, excuterw- -&gt; 6 read, write , rwx -&gt; 7 read, write , excute 0755-&gt;即用户具有读/写/执行权限，组用户和其它用户具有读写权限；0644-&gt;即用户具有读写权限，组用户和其它用户具有只读权限； Ref: ls 參數說明 vi 文書處理軟體1234567vi test.txt//輸入i進入編輯模式//按下ESC回到一般模式:wq存檔:q!不存檔離開 http://linux.vbird.org/linux_basic/0310vi/0310vi.php 刪除12345678910rm filenamerm -r dirname/要刪除目錄, 需要加入 -r 代表 recursive 遞迴刪除, 使用時要格外小心, 會把目錄內所有檔案及目錄一同刪除．-f：force=&gt;強制，不會出現警告訊息，會自動忽略不存在的檔案。$ rm -r dirname/ 刪除空目錄,內有檔案或副目錄便不能刪除各發行版為了安全起見,強制刪除整個根目錄會不能生效，如果真的想刪請見參考用法：Ref:https://www.opencli.com/linux/rm-delete-files-directory-command 查看檔案大小1234567du &quot;File&quot;du --block-size=1G &quot;File&quot; 後面不加檔案則是當前目錄-s, --summarize 只顯示總計-h, --human-readable 以 K, M, G 為計量單位du -shc /ftp/*https://clay-atlas.com/blog/2020/01/11/linux-chinese-tutorial-command-du-check-file-size/https://blog.xuite.net/cadmus.lin/yo/39567921 tar123456789壓縮tar zcvf FileName.tar.gz-z ：透過 gzip 的支援進行壓縮/解壓縮：此時檔名最好為 *.tar.gz-c ：建立打包檔案，可搭配 -v 來察看過程中被打包的檔名(filename)-f filename：-f 後面要立刻接要被處理的檔名解壓縮tar zxvf FileName.tar.gz -C /xxx/xxx-x ：解打包或解壓縮的功能，可以搭配 -C (大寫) 在特定目錄解開 wgetwget 是 linux 中除了 curl 外另一個檔案下載的好用工具。若要下載網路上的檔案，可執行 wget 加上檔案的網址即可立即下載， 123456wget http://xxxx/xxxxx.tar.gz //也支援ftp://協定-c //檔案續傳，如果下載大型檔案中途斷線，-c 參數從上次中斷的地方繼續下載-i urls.txt //如果要下載的檔案非常多，可以將網址放進txt裡more:https://blog.gtwang.org/linux/linux-wget-command-download-web-pages-and-files-tutorial-examples/ Ubuntu內建的apt-get指令來完成更新Update the package list first: 1sudo apt-get update sshpass 安裝sshpass 1apt-get install sshpass 使用 scp 與 sshpass 即可複製檔案至遠端 SSH 伺服器. 1$ sshpass -p [使用者密碼] scp -v [本地檔案路徑] [使用者帳號]@[遠端 SSH 伺服器 IP 位址]:[遠端 SSH Server 目錄] Ref:How to install sshpass on ubuntu?https://www.codeproject.com/Questions/1179693/How-to-install-sshpass-on-ubuntuSSH 檔案傳輸https://artistehsu.pixnet.net/blog/post/257353906 更多參考，待讀看似比較簡單的Linux推坑教學 Linux CLI 基本教學","link":"https://minilabmemo.github.io/2020/12/27/linux-CLI/"},{"title":"[監控]使用Prometheus+Grafana監控電腦與程式效能","text":"使用Prometheus+Grafana監控效能 介紹Prometheus 普羅米修斯是開源的免費應用程序。可以很容易建立不同維度的 metrics及資訊視覺化圖表的監控與查詢，也有告警設定，Kubernetes的核心組件也可以找到它的身影，許多知名公司如：Uber也有導入。 Grafana Grafana是一個跨平台、開源的資料視覺化網路應用程式平台。使用者組態連接的資料來源之後，Grafana可以在網路瀏覽器里顯示資料圖表和警告。該軟體的企業版本提供更多的擴充功能。擴充功能通過外掛程式的形式提供，終端使用者可以自訂自己的資料面板介面以及資料請求方式。Grafana被廣泛使用，包括維基百科專案。 必備安裝與設定下載Prometheus下載網址https://prometheus.io/download/ 個人是用windows 所以下載的是zip檔，內含prometheus.exe執行程式與prometheus.yml設定檔。點擊prometheus.exe 啟動預設9090port，即可查看http://localhost:9090/已運作。如欲更改port 123//start.bat prometheus.exe --web.listen-address=:9999cmd 但這時並未監控任何程式，待後面範例會用到，可先關閉。 下載grafana下載網址 https://grafana.com/grafana/download個人是docker啟動 1docker run -d --name=grafana -p 3000:3000 grafana/grafana 即可開啟http://localhost:3000/ 預設帳號密碼：admin 設定 grafana連結prometheus進入後尋找data sources-&gt;設定連接prometheus新增Url:http://localhost:9999 Access:Browser，Save &amp; Test確認連接目前還沒有設定圖表，僅先設定待用。 監控windows電腦CPU/Network/Memory1.windows_exporter 用來監控windows下載地址： https://github.com/martinlindhe/wmi_exporter/releases下載MSI，下載後在需要監控的目標主機上雙擊執行安裝，安裝完成後會以服務的形式自動執行，預設監聽9182埠。 如須關閉可以在電腦中服務找到windows_exporter關閉之。 其他Node Exporter Full by Instance ID 2.修改prometheus.yml12345- job_name: 'windows_exporter' static_configs: - targets: ['localhost:9182'] labels: instance: Windows 3.於grafana 新增圖表於grafana的網站上搜尋做好的圖表，這邊有找到兩種： windows_exporter for Prometheus Dashboard Windows Node (fixed for v0.13.0+)就可以監控了 監控Go程式效能1.在Go程式代碼中加入監控代碼ex: GIN的prometheus用法 123456789101112131415161718192021222324252627282930import ( &quot;log&quot; &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;+ &quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;)func main() {+ StartMonitoring(&quot;0.0.0.0:8000&quot;) select {}}func StartMonitoring(port string) { var p string if port == &quot;&quot; { p = &quot;:8080&quot; } else { p = port } go func() { log.Println(&quot;Listening on&quot;, p)+ http.Handle(&quot;/metrics&quot;, promhttp.Handler()) log.Fatal(http.ListenAndServe(p, nil)) }()}+ func prometheusHandler() gin.HandlerFunc { h := promhttp.Handler() return func(c *gin.Context) { h.ServeHTTP(c.Writer, c.Request) }} 已開啟一個listen 8000的程式 2. 編輯prometheus.yml，把監控的web服務localhost:8000加入，這邊可以編輯多組。 12345678- job_name: 'prometheus' # metrics_path defaults to '/metrics' # scheme defaults to 'http'. static_configs: - targets: ['localhost:8000','localhost:8011'] 3. 啟動這時可以打開localhost:9999就可以看到Prometheus的簡易歷史圖表記錄了。metrics available for this monitor prometheus-go 4. import Go Metrics 圖表於grafana的網站上搜尋做好的圖表 例如可以套入這個Go Metrics 範例 網路參考文章 Prometheus（二）：Prometheus 監控Windows機器 Promethus叢集部署筆記：（四）安裝並配置windows_exporter 使用 Prometheus 和 Grafana 打造 Flask Web App 監控預警系統Grafana | 將資料視覺化？簡易的介紹與操作！","link":"https://minilabmemo.github.io/2021/04/28/monitor-promethus-grafana/"},{"title":"[分享] 修改依賴源碼超省時的補丁套件","text":"有的時候，因為一些個人因素，或是依賴庫的檔案有問題，使你不得不去修改 node_modules 裡某個套件的源碼，或許你修正了，也發出 PR 正在等待合併，可是如果你重新使用 npm install 可能還是會拉到尚未修正的源碼，而這個補丁工具 patch-package 可以快速解決你的問題. 目錄 | Contents 起源 安裝 patch-package 修正源碼 創建補丁 部署 實際應用 網路參考文章 起源因為我去改了node_modules 裡某個套件的源碼，看了網路上說明為了避免下次拉依賴庫又會被修改回來，所以你可能要自己把修正拉進自己的庫，但修改起來看了有點麻煩，文章內有提到另一個補丁工具，索性就用用看，這工具實在好用，記錄下使用過程，如果有看不懂的地方可以看這篇最下方的參考文章． 安裝 patch-package1npm install patch-package --save-dev 修正源碼接著你可以去改 node_modules/xxx/xxx 的檔案 創建補丁12// npx patch-package package-namenpx patch-package xxx package-name 就是你依賴的node_modules/xxx 的名字 執行完成會發現生成patches文件夾，裡面有修改過的文件 diff 紀錄 部署 修改package.json，新增命令 postinstall123&quot;scripts&quot;: {+ &quot;postinstall&quot;: &quot;patch-package&quot; } 之後再下`npm install` 就會發現它幫你下載相依庫時又修正更改了，這真是太神奇了！ （你可以刪掉相依在讓它載回來看看，記得備份） 12345678910+ $npm install&gt; hexo-site@0.0.0 postinstall xx/blog/minilabmemo.github.io&gt; patch-package+ patch-package 6.5.1+ Applying patches... //下面的檔案進行修改hexo-insert-toc@1.1.2 ✔audited 543 packages in 2.279s 實際應用hexo主題魔改之後曾有提過我有針對主題底層更改魔改-theme-主題樣式，後來又備份自己修改的地方，想一想或許可以用這個套件修補． 原本架構 12themes/icarus //不會上傳 install from source git clone來的themes/icarus_fix_record //自己的修改備份紀錄 改用 install from NPM 1234npm install -S hexo-theme-icarus專案出現相依庫&quot;hexo-theme-icarus&quot;: &quot;^5.2.1&quot;, 接著移除掉themes/icarus 資料夾原本修改的地方就被恢復成原主題了 接著再把我備份的修改紀錄去修改node_modules/hexo-theme-icarus 12345themes/icarus_fix_record/include/style/base.stylthemes/icarus_fix_record/include/style/card.stylthemes/icarus_fix_record/include/style/helper.stylthemes/icarus_fix_record/layout/common/article.jsx... 創建補丁 npx patch-package hexo-theme-icarus 因為檔案會有點多，所以也可以再加上 –include “.include.“ 讓他針對部分去修改就好 完成後去生成的檔案夾確認diff，這邊也可以記錄你的修改123456789101112$ npx patch-package hexo-theme-icaruspatch-package 6.5.1• Creating temporary folder• Installing hexo-theme-icarus@5.2.1 with npm• Diffing your files with clean files✔ Created file patches/hexo-theme-icarus+5.2.1.patch💡 hexo-theme-icarus is on GitHub! To draft an issue based on your patch run npx patch-package hexo-theme-icarus --create-issue$ npx patch-package hexo-theme-icarus --include &quot;.*include.*&quot;$ npx patch-package hexo-theme-icarus --include &quot;.*(?:include|common).*&quot; 重新安裝確認你可以刪除相依再次下 npm install確認，但似乎用 npm install -S hexo-theme-icarus是沒有作用的 網路參考文章 本篇文章內容參考如下，如有引用錯誤或須加註問題，歡迎提出喔． 修改nodejs项目中node_modules的代码，不能生效吗？ 配置webpack alias 的方法介紹 （沒用過） 使用 patch-package 修改第三方模块 更多選項介紹 Super Easy NPM Package Patching with ‘patch-package’ Photo by Webstacks on Unsplash Photo by Sincerely Media on Unsplash","link":"https://minilabmemo.github.io/2023/03/18/node-modules-fix/"},{"title":"[HTML &amp; CSS][✍ 筆記] 初學 HTML &amp; CSS 與練習","text":"[✍ 持續更新] 練習CSS &amp; HTML 操作相關筆記． HTMLHtml 基礎 HTML 文件 (HTML document) 標籤 (tag)…包圍著語意 (semantic) 內容(Content)區塊稱作 HTML 元素 (HTML element)，不同標籤表達不同語意 空元素 (Empty Element / Void Element)有些 HTML 元素是不允許有內容的，稱之為空元素。沒有結束標籤常見包括1&lt;br&gt;換行 &lt;hr&gt; &lt;img&gt;圖片 &lt;input&gt;輸入 &lt;link&gt; &lt;meta&gt; HTML 標籤中還有屬性 (Attribute)，來提供該標籤的額外資訊 撰寫規則 屬性值用單引號雙引號都可以 標籤與屬性大小寫都可以，常見且建議是固定使用小寫 (lowercase)。 雙引號間的屬性值不能空白什麼是HTML 標籤Tag - HTML 語法教學Tutorial - Fooish 程式技術https://www.fooish.com/html/tag.html 語意標籤HTML5中新增了語意化標籤(Semantic Elements)，目的是為了讓標籤(Tag)更具意義，以加強文件的結構化，讓搜尋引擎更清楚了解 123456789101112131415161718Header 可於body內或是article或是section代表頁首或是首要區塊Nav 導覽區塊Main 主要區塊，整頁只有一個Article 包覆文章Section 區塊Div 無意義為包裹區塊排版用Aside 用來代表主內容的附加內容，未必是側邊欄，廣告等等都可以用Footer 頁尾Time 時間Mark 似螢光筆重點details 文章的細節Figure /figcaption區塊 引用與標題&lt;hgroup&gt; 當內容有主標題及次標題等多個標題的狀況下使用。&lt;cite&gt; 引用其他文獻或作品(例如書籍、歌曲、電影、繪畫、雕塑等）的標題&lt;String&gt; 粗體相對於&lt;b&gt;&lt;/b&gt;更有強烈意思&lt;i&gt;&lt;/i&gt;italic(斜體)的字首。em 的完整名稱則是 emphasized(強調/注重)s 原文是 strikethrough(刪除線)，del 這個標籤一看就會明白：delete(刪除)。 好文參考： 快速了解HTML語意化標籤 [HTML5]b,i,s 跟 strong,em,del 這些看起來一樣，但意義不同的標籤們 CSS區塊計算 Box Model Box Model 預設 box-sizing: content-box content 內容 1width: 寬度值;height: 高度值; padding 內距12padding:上 右 下 左; padding:上下 左右; padding:上 左右 下; padding:四邊同値; border 邊框1border: 邊框粗細 邊框顏色 邊框樣式 ; margin 物件與物件間距離12margin:上 右 下 左;margin:上下 左右;margin:上 左右 下;margin:四邊同値; 該物件整體的大小會是content+padding+border，不要以為真的是width; height大小 然後margin是占空間但不可視的地方。 可以改變屬性 box-sizing: border-box; 就會幫你把整體物件大小設定為width+height 但這樣表示content內容只有width/height-padding-border(看左右/上下設定多少) 然後margin還是占空間但不可視的地方。 範例：可以用開發模式查看它的設定 css reset撰寫時會發現元素與視窗有空隙，css reset可以清楚，還有其他一些效果 React + @emotion/css 套用範例1234import reset from 'react-style-reset';import { injectGlobal } from '@emotion/css';injectGlobal(reset, {}); 排版display隱藏元素 display預設為none 123display: none; //空間消失visibility:hidden //空間仍存在 w3schools Hide an Element 區塊元素 display預設為block，區塊元素排列都會另起一行，除非被改變 可設置寬高 width hight 默認情况下，其寬度自動填满其父元素寬度，即寬度100% 高度，行高以及頂和底邊距都可控制； 123456常見包括 div、p、h1~h6、ul、ol、li、dl、dt、dd、form、table、hr、blockquote 、address、menu、pre.....等等 行內元素 display預設inline，除非被改變 設置寬高無效，只能由内容撑起来，行內元素會依照物件內容的大小決定占用的版面 行内元素会排列在同一行，直到一行排不下，才會換行，其寬度隨元素的内容而變化。 設置上下margin、padding无效，左右padding 、margin有效1234常見包括span、em、i、b、strong、a、img、input、br、select、textarea、q、bdo、sub、sup...等等 行內不能包含區塊元素 *可變元素 依上下文決定 Ref:https://www.jianshu.com/p/9fa96ece88f1 行內區塊 display：inline-block 以inline的方式呈現，但同時擁有block的屬性 PositionStatic：默認值，沒有定位。 固定定位fixed 不管滾軸移動，依然在一樣位置 空間不佔據，會蓋住別人 固定他在原本寫的位置上 有寫上右下左就會定位在視窗頂端的相對位置（非自身） 應用： 蓋版廣告（左右上下置中 設立五個 為什麼） 頂置導覽列top0 回到上面 bottom 0 relative 空間會佔據，也會蓋住沒有設定定位的物件 相對於原本的位置上 兩個都有定位物件，後面蓋前面 可以設定z-index 設定優先，預設0 absolute 空間不佔據，資料會在原本資料的位置 設定完上下左右它會往有定位的父層找 如果找不到會定位在視窗上，不是body(如果想要定在body上，body需要設定定位，往上還有html,有一點差別 ) 應用在不想與人排列的情況，通常父層會用relative,父層想要有排列 應用： 特賣標籤absolute,父層項目relative 改版廣告的(X) float Flex 父層設定可以控制子層的排列方式 關於置中margin“margin:0 atuo;”所代表的的意思是水平居中，區塊元素的容器水平置中。關於margin:0 atuo;”是什么意思？不要告訴我你懂margin ＴＢＤ1.align-content2.延伸設定3. default: align-items: stretch; 上下高度自動滿版時有出現空白問題 範例版面與物件互動式視窗 Modal window原理：製作一置中視窗，然後先隱藏起來，該位置距離上方可以百分比設定． margin: 15% auto; / 15% from the top and centered /w3schools=How TO CSS/JS Modal *My React版練習Add: Model input 欄位 一般的輸入數字框，可以看到預設會有上下箭頭出現 1&lt;input type=&quot;number&quot; value=&quot;5&quot;&gt; 如果要隱藏上下箭頭可以這樣寫：howto_css_hide_arrow_number css-in-js 版- Hiding input spinner using styled-component","link":"https://minilabmemo.github.io/2020/09/15/note-css-html/"},{"title":"[python 02]初學 python 筆記","text":"初學 python 筆記 python 學習收藏文[Day - 03] - Python 基礎語法教學 Part 1https://ithelp.ithome.com.tw/articles/10200505 Python 資料型態 常见的 immutable objectsNumeric types: int, float, complexstringtuplefrozen set參數傳遞行為同 pass-by-value。 常见的 mutable objects:listdictsetbyte array參數傳遞行為同 pass-by-reference，但是不允許 re-assignment(會指向新的object，跟之前物件無關)。 參考文章: 理解 Python object 的 mutable 和 immutablehttp://wsfdl.com/python/2013/08/14/%E7%90%86%E8%A7%A3Python%E7%9A%84mutable%E5%92%8Cimmutable.html Python資料型態，可變與不可變物件http://changlt.blogspot.com/2017/04/python_29.html Python 函式的參數傳遞方式：Passed by assignmenthttps://blog.hitripod.com/python-function-passed-by-assignment/ python 並不會因為 data 是可變還是不可變的因素去決定是傳值還是傳參 (很多人都有這種誤解), 因為他都不是, 他自有其特殊的傳遞方式， python 是完完全全的 call by sharing!http://dokelung.me/category/python/python-evaluation-strategy/ 延伸:JS的call by sharing [JS基本觀念：call by value 還是reference 又或是 sharing?]https://medium.com/@mengchiang000/js%E5%9F%BA%E6%9C%AC%E8%A7%80%E5%BF%B5-call-by-value-%E9%82%84%E6%98%AFreference-%E5%8F%88%E6%88%96%E6%98%AF-sharing-22a87ca478fc","link":"https://minilabmemo.github.io/2021/02/13/python-note/"},{"title":"[python 01]安裝與執行python","text":"純紀錄python與在vscode快速執行python pythonPython 的安裝有分兩種：一種到Python官網下載後安裝即可，另一種便是使用 Anaconda 安裝，Anaconda 會幫你管理 Python 的環境及函式庫，是一個 all-in-one 的 Python 開發環境，很適合初學者。 Python 3.8.5 (default, Sep 3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32 安裝完就會有Anaconda-Navigator應用中也會有Jupyter，可以在網頁上執行 Python 程式碼還有Spyder等等，你也可以從中看到安裝 pip的基本功能就是安裝套件The Python Package Installer （下面再詳細介紹） pip –versionpip 20.2.4 from D:\\ProgramData\\Anaconda3\\lib\\site-packages\\pip (python 3.8) ref:Python教學第0章-Anaconda 完整安裝教學及搭建 vscode 開發環境 vscodevscode1.plugin 安裝python2.新增檔案xxx.py 12print(&quot;Hello world! Python&quot;)print(&quot;By Eyelash&quot;) 這時就可以對他按下Run，就會在終端機執行了。*如果沒裝1的話第二步也會跳出建議喔 pip安裝模組$ pip install 模組名移除模組$ pip uninstall 模組名搜尋模組$ pip search 模組名開發時將已安裝模組名稱和版本號存成列表，以便下次安裝使用$ pip freeze &gt; requirements.txt根據 requirements.txt 列表安裝模組$ pip install -r requirements.txt Ref:https://blog.techbridge.cc/2017/06/03/python-web-flask101-tutorial-introduction-and-environment-setup/","link":"https://minilabmemo.github.io/2021/02/10/python-vscode/"},{"title":"[✍練習][🚧進行中][react] 使用ramda整理資料","text":"ramda 一款實用的 JavaScript 函數编程库 安裝 ramda$ npm install ramda 使用import * as R from “ramda”; 過濾資料1234567891011121314151617181920const datas = [ { name: &quot;Cupcake&quot;, pri: 1, status: &quot;OPEN&quot;, type: &quot;blog&quot;, protein: 4.3 }, { name: &quot;Donut&quot;, pri: 2, status: &quot;OPEN&quot;, type: &quot;go&quot;, protein: 4.9 },]找出所有datas.name=&quot;Cupcake&quot;的資料let f = R.filter(R.propEq(&quot;name&quot;, &quot;Cupcake&quot;), datas); 延伸用法介紹JavaScript 的 map() functionArray.prototype.map()map() 方法會建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。Array.prototype.map() react 列表與 Key含index 輸出介紹範例react lists-and-keys 👇👇👇未完待續 您可以拉到底部先看參考文章👇👇👇 練習區 ✍ 持續練習並更新 note class_name %} ## 網路參考文章 官方文檔中文官方文黨Display JSON Data in React JSRamda,从开始到重构","link":"https://minilabmemo.github.io/2020/10/01/react-ramda/"},{"title":"[React][✍練習]套用 css-in-js (Emotion 庫)撰寫 CSS","text":"[✍練習ing] 練習React JS寫法與 css-in-js( Emotion 庫) 撰寫 CSS 一般要在 React 中撰寫 CSS 有幾種做法1.撰寫在.CSS 檔案,再 import 套用。 把css寫在不同檔案中12import &quot;./styles.css&quot;;&lt;div className=&quot;App&quot;&gt; 可定義 className 不便性：會需要考慮CSS優先度問題2.直接在對應地方用style={JS寫法} 撰寫 直接用 Inline-style 在屬性中加入style12&lt;h2 style ={{color:'red', backgroundColor: &quot;#3f51b5&quot;}}&gt;JS寫法&lt;/h2&gt;裡面是 JS 寫法，值需加''，且-需改成駱駝式寫法(不能含-字元) 不便性：會需要轉成ＪＳ寫法，有插件工具可以幫忙轉 3.套用css-in-js 庫 直接撰寫 CSS，不用再改 JS 寫法啦 而 css-in-js 庫的主要有: styled-components, emotion, glamorous。 練習用emotion庫撰寫CSS Emotion 是一個旨在使用 JavaScript 編寫 CSS 樣式的庫 - 加上兩個反引號，之間就可以直接撰寫 CSS ，有styled 寫法，本篇主要用這個練習看看。 styled 寫法要建立 &lt; div&gt; 標籤樣式時，使用 styled.div；如果要建立的是 &lt; button&gt; 則是使用 styled.button 以此類推。 套用emotion庫撰寫基礎使用方法： 安裝 npm install –save emotion 引入用className屬性套用123456import { css } from &quot;emotion&quot;;const myStyle = css` color: rebeccapurple;` &lt;div className=&quot;myStyle &quot;&gt;myStyle樣式&lt;/div&gt; 更多範例可以看NPM上的emotion庫介紹emotion 套用@emotion/styled基礎使用方法： 引入npm i @emotion/styled 撰寫標籤tag123456789const Container = styled.div` //外面 background-color: skyblue;`;...return ( &lt;Container &gt; &lt;/Container &gt; ); 變數修改方法12345let displayNone = &quot;block&quot;const Modal = styled.div`display: ${displayNone}; `; 套用@emotion/core庫撰寫官方推薦＠＠ 但使用上有一些限制 基礎使用方法： 引入npm i @emotion/core 引入後用css屬性套用12345678910111213/** @jsx jsx */ import { css, jsx } from &quot;@emotion/core&quot;; //在無法配置babel配置（create-react-app，codesandbox等）的項目中一定要加前述/** @jsx jsx */ 才有效果喔！！！ 之前漏了查好久＠＠定義常數， CSS 區塊要用css`` 包起來 const TextRed = css` color: red; `;然後在要套用的地方加上css={xxx} &lt;h2 css={TextRed}&gt;emotion css 寫法&lt;/h2&gt; 更多介紹範例： emotion Introduction 練習區✍持續練習其他進階套用法並更新在範例檔案中 ex: 多重套用，階層樣式，標籤樣式… *可側邊開啟程式碼（如有更好的寫法介紹還請多多指教，謝謝🙏） 開發插件 in vscodevscode中有一些針對css-in-js的插件可以幫助開發效率． Css-in-js可以透過指令將 CSS 選取後切換 css &amp; css-in-js 寫法，不用再自己改半天啦！！ vscode-styled-components可以自動完成在css-in-js區塊裡面的css補全提示． 網路參考文章 連結 摘要與大致內容 【Day 10】CSS &amp;&amp; Inline-style React CSS &amp;&amp; Inline-style 介紹，JS 物件寫法。 https://github.com/rtsao/csjs/wiki/How-to-apply-multiple-classnames-to-an-element 多重classnames寫法 谈一谈在 React 项目中使用 css-in-js 方案 鉴于 emotion 已经支持了 styled 模式，可以优先选择 emotion。內涵 emotion 用法示例(進階 待看 ☐👈) [Day 14 - 即時天氣] 把 CSS 寫在 JavaScript 中！？ - CSS in JS 的使用 使用 emotion 撰寫 styled components 介紹撰寫 React CSS 的神套件 Styled Components Styled Components sample emotion Composition 套用兩個樣式寫法 https://stackoverflow.com/questions/53803466/what-does-the-comment-jsx-jsx-do-in-the-emotion-css-in-js-library 解釋要在import前加上/ ** @jsx jsx * /的原因 https://emotion.sh/docs/css-prop#jsx-pragma 在文件頂部設置jsx編譯指示才可以使用css prop。尤其在無法配置babel配置（create-react-app，codesandbox等）的項目中。 change-style-of-material-ui-textfield 更改material-ui樣式的發問 Why you shouldn’t use @emotion/core 有一篇文章分析不應使用emotion/core的原因","link":"https://minilabmemo.github.io/2021/04/18/react-css/"},{"title":"[React][✍練習][🚧進行中] 使用recharts進行圖表繪製","text":"練習 Reactc 畫圖套件 recharts Reactc 畫圖套件 recharts導入1$ npm install recharts 使用123456789101112131415161718192021import { LineChart, Line, XAxis, YAxis, Tooltip } from 'recharts';function RenderLineChart() { const data = [ { name: 'Page A', uv: 400, pv: 2400, amt: 2400 }, { name: 'Page B', uv: 800, pv: 1200, amt: 2400 }, { name: 'Page C', uv: 900, pv: 3000, amt: 2400 }, ]; return ( &lt;LineChart width={400} height={250} data={data}&gt; &lt;XAxis dataKey=&quot;name&quot; /&gt; &lt;YAxis /&gt; &lt;Tooltip /&gt; &lt;Line type=&quot;monotone&quot; dataKey=&quot;uv&quot; stroke=&quot;#8884d8&quot; /&gt; &lt;Line type=&quot;monotone&quot; dataKey=&quot;pv&quot; stroke=&quot;#3f51b5&quot; /&gt; &lt;Line type=&quot;monotone&quot; dataKey=&quot;amt&quot; stroke=&quot;#666666&quot; /&gt; &lt;/LineChart&gt; );}//在對應要放入的位置放入&lt;RenderLineChart /&gt; note class_name %} ## 網路參考文章 recharts","link":"https://minilabmemo.github.io/2020/11/14/react-recharts/"},{"title":"[React][🚧進行中]做to-do list頁面","text":"練習用 React 做 to-do list 頁面 功能： 可自由新增代辦任務/選擇優先度/預設類型/日期 新增列表後預設為OPEN，可更改為進行中（inprogress）-&gt;完成（Done) 列表可以依Tab顯示不同狀態 選取後可以刪除，或是右上角有全部清空按鈕 [✍ 修改 ing] 本篇用到套件與關鍵技術： Material-ui table ＆新增修改資料 Material-ui tab Material-ui Icon Material-ui 可輸入下拉選項框 + class 切換動畫 ramba for filter json 整理資料 線上 CodeSandBox","link":"https://minilabmemo.github.io/2020/10/02/react-todo/"},{"title":"[React筆記 01] 初始開發環境設定","text":"快速安裝 React 專案與建置開發環境，創建React App是創建單頁React應用程序的官方支持方式。 它提供了無需配置的現代化構建設置。 安裝node.js (npm) Node.js是能執行JavaScript 的執行環境，讓JS可以在伺服器(瀏覽器以外)運作 npm（全稱 Node Package Manager，即「node包管理器」）是Node.js預設的、用JavaScript編寫的軟體套件管理系統 使用 npm 安裝create-react-app12345npm install -g create-react-app/usr/local/bin/create-react-app -&gt; /usr/local/lib/node_modules/create-react-app/index.js+ create-react-app@3.4.1~ create-react-app --version3.4.1 -g 代表全局安裝 create-react-app 是適合學習 React 的環境及單頁（single-page）應用程式，不需再安装或配置 Webpack 或 Babel 等工具， 它們是預先配置好並隐藏的 create-react-app –version 確認版本的指令- 使用create-react-app 建立專案12～create-react-app 01-create-react-appCreating a new React app in /Users/xxx/front/01-create-react-app. 啟動專案1npm start 就會看到一個網頁介面啟動囉！！！！！！ *註：當重新下載專案時需要先下npm install後才能npm start*在本地可以看到node_modules的資料夾 create-react-app 內容架構 123456README.md package.json //和設定打包工具(webpack)有關node_modules publicpackage-lock.json src public/index.html基本的HTML架構，內有 1&quot;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&quot; 而在/src/index.js 則有渲染DOM的程式碼 123456ReactDOM.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 完成開發生成靜態與部署1npm run build 當編譯結束時，專案目錄底下會出現build資料夾，裡面的檔案就是所需要的靜態檔案(可以點開index.html試試看)，其他檔案在部署時不用上傳。 實作直接打開ＨＴＭＬ或是用live server都會一片空白？？ 但實際起python web server可以看到 (待釐清) vscode 外掛 ESlint 插件 -&gt; 一個Javascript Linter，是一種靜態代碼分析工具，用於識別在JavaScript代碼中發現的有問題的模式，可以定義和加載自定義規則。ESLint涵蓋了代碼質量和編碼風格問題。 JS JSX Snippets 插件 -&gt;程式碼快速鍵 延伸閱讀 [wait]有看沒懂的npx方式","link":"https://minilabmemo.github.io/2020/05/16/react01-create-react-app/"},{"title":"[React筆記 02] react JSX 基本語法","text":"上一篇已建立一個基本專案，開始可以對index.js做一些改寫練習，並使用JSX語法 JSX看起來是html與ＪＳ混合使用，比較接近 JavaScript 而不是 HTML，ＪＳＸ允許你使用 JavaScript 所有的功能。 Ref :https://zh-hant.reactjs.org/docs/introducing-jsx.html html 區域剛剛產生的public/index.html，含有基本HTML範本id=”root”的div區塊 1&quot;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&quot; React 中的 JSX 區域接著看一下src/index.js裡的程式碼 基本範例: 直接撰寫html123456ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));或是改成ReactDOM.render( &lt;h1&gt; Hello world!&lt;/h1&gt;,document.getElementById('root')); 解說： 由 React DOM 函式將元素渲染 ROOT 這個DOM 節點中 而將 html當參數傳遞是使用一種Javascript語法: JSX12345678const name = 'Josh Perez'; //一般javascriptconst element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;//混和的html與字串 特殊JSX語法ReactDOM.render( element, document.getElementById('root')); 關於Babel 是JavaScript 前處理器，編譯器，主要能轉換JSX與ES6成各瀏覽器支持的ＪＳ 12345const element = ( &lt;h1 className=&quot;text&quot;&gt; Hello, World! &lt;/h1&gt;); Babel 將 JSX 編譯為呼叫 React.createElement() 的程式。 12345const element = React.createElement( 'h1', {className: 'text'}, 'Hello, World!'); 範例: 在html中可以用{JS} 表達式崁入變數12345678910111213141516171819202122//js函式宣告或是變數宣告區const styleRed = { color: 'red' };const pic=()=&gt;{ //html語法可以當作參數傳遞 return ( &lt;div&gt;&lt;img src=&quot;https://picsum.photos/200/200?image=229&quot; alt=&quot;&quot; class=&quot;circle-profile&quot;/&gt;&lt;/div&gt;);}var arr = [ &lt;h1&gt;REACT學習&lt;/h1&gt;, &lt;h2&gt;如何使用JSX！&lt;/h2&gt;,];ReactDOM.render(&lt;React.StrictMode&gt; &lt;h1 style = { styleRed } &gt; Hello, world! &lt;/h1&gt; &lt;div&gt;{ pic()} &lt;/div&gt; {/*註解這樣寫*/} &lt;div&gt;{arr}&lt;/div&gt;,{/*可以放入數組*/} &lt;/React.StrictMode&gt;, document.getElementById('root'));- 可在 html 標籤中利用 {} 寫 javascript 表示式- 其中style = {{ color: 'red' }} 這樣的表示也可以。 範例: 帶入屬性命名與Event1234567891011const getValue=(event)=&gt;{ console.log(event.target.value)}ReactDOM.render(&lt;React.StrictMode&gt; &lt;h1 className = &quot;title&quot; &gt; Hello, world! &lt;/h1&gt; &lt;button value onClick={getValue}&gt;按下以取得數值 &lt;/button&gt; &lt;button value={true} onClick={getValue}&gt;按下以取得數值 &lt;/button&gt;&lt;/React.StrictMode&gt;, document.getElementById('root')); 駱駝式命名 class 要用 className 然後可以在 style.css中更改樣式 onclick 也要改onClick{函數名稱} 駱駝式命名 實測命名打錯 console 會出現報 Warning: Invalid DOM property class. Did you mean className? 輸入類的元件button/input/textarea互動事件觸發時，函式只會接收到一個event類別的參數，並不能傳遞其他參數 布林=true 的屬性值可以不寫 範例 JSX引入Inline-style123456789export default function App() { return ( &lt;div className=&quot;App&quot; style={{ color: 'blue',fontSize:'19px' }}&gt; &lt;/div&gt; );} 在style內的是ＪＳ物件也可以把他們只給一個const變數 內容與css不同的是必須是小寫駱駝且去除’-‘ 這種寫法的缺點是不行用hover等特殊效果，需利用其他模組化stylr寫法 網路參考文章 note warning %} 學習路上感謝網路大神們，如果你發現了我，可以查看參考文章了解更多概念👇👇👇 【React.js入門 - 06】 JSX React篇: JSX語法撰寫指引","link":"https://minilabmemo.github.io/2020/05/30/react02-jsx/"},{"title":"[React筆記 03] React 組件、函式與生命週期","text":"整理react學習“個人筆記” 本文內容： React component (組件)語法 props 是什麼 ES6箭頭函式組件 State的用法 生命週期 React component (組件)語法 component 就像是 JavaScript 的 function ReactDOM.render 中{函式名稱}變成了&lt;函式名稱/&gt; see:Render Element Component 命名首字必須大寫，大寫駝峰的方式，否則 React 會把它當作一般的 HTML 元素處理，並跳出Warning提示，看到大寫駝峰命名變數時，可以知道是 React 組件而非一般函式。 其他 HTML 屬性、CSS 樣式屬性或一般的函式來說，則會遵行 JavaScript 以小寫駝峰來命名變數的慣例，例如在 className、maxLength、backgroundColor 等等。 props 是什麼 component 就像是 JavaScript 的 function，它接收任意的參數（稱之為「props」）並且回傳畫面的 React element。 props 通常是不可變的(唯獨Immutable)，不能修改自己的 Ref:[Components 與 Props] (https://zh-hant.reactjs.org/docs/components-and-props.html) function component vs class component接著看看兩種寫法轉換 Function 成 Class ： 使用function 來做 component 如果需要向component傳参数，可以使用 props 對象， 用return (html) function component12345678910function HelloName(props) { return &lt;h1&gt;Hello {props.name}!&lt;/h1&gt;;}ReactDOM.render( &lt;React.StrictMode&gt; &lt;HelloName name=&quot;May&quot;/&gt; &lt;/React.StrictMode&gt;, document.getElementById('example')); 使用ES6 class來做 component 也可以使用ES6 class來 來定義 繼承React.Component且在用render(){}包一層 props 要改用 this.props 用render(){return html} class來 component123456789101112class HelloName extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; }}ReactDOM.render( &lt;React.StrictMode&gt; &lt;HelloName name=&quot;May&quot; /&gt;;, &lt;/React.StrictMode&gt;, document.getElementById('example')); 組件裡面可以再包組件，透過這樣可以重新利用範例練習: USER info React組件 ES6箭頭函式組件 寫法接著看看箭頭函式語法可以簡潔,少打很多字元 const App: () =&gt; JSX.Element //大寫駱駝命名 縮寫：如果裡面只有return 可以去掉{}與return，但通常會有一些變數存在，個人習慣保留． 箭頭函式不可以使用於建構式，可以見[JS 01] javascript 新手上路與概念筆記 使用插件快速鍵 rafc - ReactArrowFunctionComponent紀錄123const Hello = () =&gt; { return ( &lt;div&gt;hello&lt;/div&gt; )} State的用法Props 是唯讀的(Immutable)，State 類似於 prop，但它是私有且由 component 完全控制的。當state被改變時，會進入re-render的update程序，更新畫面 class(setState) vs function(useState)1. 使用class來改state（setState） 使用 ES6 class來 來定義 繼承React.Component且在用render(){}包一層 props 要改用 this.props 如果想要更改props ，要改用setState 根據React 與 bind this 範例練習:透過一個新的按鈕去改變時間 Refresh Time 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import App from &quot;./App&quot;;const rootElement = document.getElementById(&quot;root&quot;);class Clock extends React.Component { constructor(props) { super(props); this.state = { date: new Date() }; // this.changeTime=this.changeTime.bind(this); } // changeTime(){ // this.setState({date: new Date()}) // } //根據React 與 bind this //以上可以簡化 改箭頭含式寫法 changeTime = () =&gt; { this.setState({ date: new Date() }); }; render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;button onClick={this.changeTime}&gt;刷新 &lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;React.StrictMode&gt; &lt;Clock /&gt;, &lt;/React.StrictMode&gt;, rootElement); 2.使用function component更改state（用useState） 沒有內部狀態（State），是 Stateless Components。 沒有 Lifecycle Hooks 和 refs。 如果想要更改props 要改用useState，useState-是一個基礎的Hook，是可以在function component中使用設定state，而不需要轉換成class。 hook意思是“鈎子”，在音樂上，指的是一首歌曲中最能鈎人的部分。Hook 是 React 16.8 增加的新功能。讓你不必寫 class 就能使用 state 以及其他 React 的功能。使用hook可以更簡化且被推崇使用。 useState它回傳了一對值：目前的 state 跟一個可以更新 state 的 function。 範例改寫練習 Refresh_Time_useState 123456789101112131415161718192021222324252627//1.加上useState引入import React, { useState } from 'react';import ReactDOM from &quot;react-dom&quot;;const Clock=()=&gt;{ // 2.宣告一個 state 變數，命名date。 // 傳入 useState() 的參數就是 state 起始值 const [date, changeTime] = useState(new Date());// 3-1 return中直接寫上state變數-在 function 中可以直接使用 state// 3-2 當使用者點擊，我們就呼叫 函式 並傳入新的值。 return( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 {date.toLocaleTimeString()}.&lt;/h2&gt; &lt;button onClick={()=&gt;{changeTime(new Date())}}&gt;刷新 &lt;/button&gt; &lt;/div&gt; );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render( &lt;React.StrictMode&gt; &lt;Clock/&gt; &lt;/React.StrictMode&gt;, rootElement); （延伸說明）hooks 與 Function Component使用 State Hook 用 Function Component 代替 Stateless Component 的说法，原因是：自从 Hooks 出现，函数式组件功能在不断丰富，函数式组件不再需要强调其无状态特性，因此叫 Function Component 更为恰当。 從精读《Function VS Class 组件》中可以看的使用class component,會因為使用this問題而需要修復，要follow class結構與巢狀太過雜亂，再者，而function component沒有this,如果希望拿到稳定的 props，使用 Function Component 是更好的選擇。而 Function Component + Hooks 可以实现 Class Component 做不到的 capture props、capture value，而且 React 官方也推荐 新的代码使用 Hooks 编写。 生命週期元件被安裝時(Mount)、元件被更新時(Update)、元件被移除時(Unmount)*註：原本想要一樣比較一下class 原本的用法，但還是直接介紹function component(useEffect)更簡潔． useEffect hook12345678useEffect(() =&gt; { /* componentDidMount 和 componentDidUpdate */ return () =&gt; { /* componentWillUnmount */ //在 component unmount 時，React 會執行清除。 }; }, [dependencies參數]); /* 是用來限定當哪些變數被改變時useEffect要觸發 */ Ref: 官方-hooks-effect 重點： 內有使用class與hook 的範例對比說明 很多待細讀 ＴＢＤ 我們建議使用 exhaustive-deps 規則作為我們 eslint-plugin-react-hooks package 的一部分。當不正確地指定依賴時，它會發出警告，並提出修改建議。 網路參考範例:React State(状态) @runoob基礎與線上範例**State 和生命週期 @React中文React解說【React.js入門 - 11】 開始進入class component @IT邦幫忙的系列文React 與 bind this @medium React hook @React 中文解說Hook系列使用 State Hook @React 中文解說State Hook中寫法對比","link":"https://minilabmemo.github.io/2021/02/27/react03-component-props/"},{"title":"[✍持續更新中] [vscode] 使用與插件分享","text":"cq %} 什麼是 vscode endcq %} Visual Studio Code（簡稱vscode）是一個由微軟開發，同時支援Windows 、 Linux和macOS等操作系統的免費程式碼編輯器，它支援測試，並內建了Git 版本控制功能，同時也具有開發環境功能，例如代碼補全、代碼片段和代碼重構等。 （維基百科） 本篇記錄自身常用設定與插件紀錄．[✍持續更新中] 開啟命令面板F1 或 Ctrl+Shift+P 開啟命令面板，再輸入想使用什麼內容，結合後續說明使用． Git 版本控制其實在 vscode 中操作 Git 真的非常方便，以下動作都是自己摸索就找到對應功能了，直接紀錄幾個常用動作． commit change File切換到 git 頁籤-&gt;會出現你有更動過的檔案，點擊可以看到差異點-&gt;按下+ 可以新增至 change 列表-&gt;上方輸入 commit Message-&gt;上方有一個勾勾按下及 commit 上傳 change File Push點擊左下角分支圖右方會有上傳按鈕 新增 branch點擊左下角分支圖-&gt;Create branch -&gt;輸入名稱 切換 branch點擊左下角分支圖-&gt;選擇分支 刪除分支Ctrl+shift+p-&gt;git delete branch-&gt;選擇分支 gitmoji在git提交上加入表情符號gitmoji Code Snippet這個是 vscode 內建就有的程式碼內建設定， 開啟終端機你不用跳到 VS Code 工具外來執行，直接按下【Ctrl+、】即可開啟終端機畫面，。Ctrl+` Show integrated terminal 安裝插件側邊欄中有一項 Extensions 可以在這邊搜尋插件與插件使用介紹． 代碼格式化 prettier - code formatter ESLint Path Intellisense自動補齊程式中的路徑和文件名。 Task Kill有時候程式發生意外終止或是不小心關閉，會需要使用終端機查出進程ＩＤ並終止．這個插件很好用，安裝完後 cmd+shift+p 可以叫出對話 輸入task kill…by port 再輸入要砍的網路 port即可． TODO TREE有時候開發過程中有未能完成或是要稍後完成的地方，可以加上TODO/FIXME等註解．這一個插件安裝完之後，側邊會出現新的icon，點擊後可以快速找出這些註解的地方． Quokka.js (沒用過先記著)Quokka.js 会在你输入时自动计算结果，并在 IDE 中打印结果。 Auto rename TagCss-in-js可以透過指令將 CSS 選取後切換 css &amp; css-in-js 寫法，不用再自己改半天啦！！ vscode-styled-components可以自動完成在css-in-js區塊裡面的css補全提示． Git Graph可以看到分支圖 後端語言相關 Go 套件新增 task 設定F1 或 Ctrl+Shift+P 開啟命令面板 12345678910111213141516171819202122232425262728tasks.json{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;echo&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;echo Hello&quot;, &quot;problemMatcher&quot;: [] }, { &quot;label&quot;: &quot;rungo&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;go&quot;, &quot;options&quot;: { &quot;cwd&quot;: &quot;${workspaceRoot}\\\\&quot;, &quot;env&quot;: { &quot;GOPATH&quot;: &quot;D:\\\\go&quot; } }, &quot;args&quot;: [ &quot;run&quot;, &quot;main.go&quot; ], &quot;problemMatcher&quot;: [] } ]} 新增 debug 設定123456789101112131415161718192021222324252627D:\\go\\src\\xxx\\.vscode\\launch.json{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Launch&quot;, &quot;type&quot;: &quot;go&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;mode&quot;: &quot;auto&quot;, &quot;program&quot;: &quot;${fileDirname}&quot;, &quot;env&quot;: {}, &quot;args&quot;: [] }, { &quot;name&quot;: &quot;LaunchRoot&quot;, &quot;type&quot;: &quot;go&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;mode&quot;: &quot;debug&quot;, &quot;program&quot;: &quot;${workspaceRoot}&quot;, &quot;env&quot;: {}, &quot;args&quot;: [] } ]} - 客製化設定根據插件會有對應的設定(快速鍵 Command+ ,) 開啟 settings.json 使用者設定檔 files1234&quot;files.autoSave&quot;: &quot;onFocusChange&quot;, 當焦點移開自動儲存 &quot;files.associations&quot;: { &quot;*.js&quot;: &quot;javascriptreact&quot; 新增檔案後綴連接的檔案類型 （React用） }, editor自動存檔格式化與更改預設格式化工具 1234&quot;editor.tabCompletion&quot;: &quot;on&quot;,//type a snippet prefix (trigger text), and press Tab to insert a snippet.&quot;editor.formatOnSave&quot;: true,&quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; React JSX 自動格式化設定搭配 editor 根據檔案格式做設定 12345678&quot;[javascriptreact]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;},&quot;eslint.codeAction.showDocumentation&quot;: { &quot;enable&quot;: true}, React Hooks SnippetsReact Hooks Snippets - React Hooks程式碼區段快速產生 prettier1234'prettier.singleQuote': true,使用單引號，這個打開，格式化會幫你把&quot;&quot;變成單引號'prettier.semi': false,結束是否加分號 note class_name %} ## 網路參考文章 連結 摘要 偏好的 Visual Studio Code 設定檔 非常詳細 vscode 如何自動格式化代碼？ 編輯器默認的格式化工具 How do I enable automatic prettier formatting for .jsx files in VS Code? each file type has to be individuallyNote javascriptreact as the identifier for JSX VScode Golang 编译任务 Task.json 在終端機的指令可以透過 task 安裝 Visual Studio Code 極速上手指南 vscode 插件推荐 todo-tree 15 款好用的 VS Code 插件 Visual Studio Code 之常備快捷鍵 Visual Studio Code 之常備快捷鍵","link":"https://minilabmemo.github.io/2020/09/18/vscode-plugin/"},{"title":"[Blog] 使用 Hexo 撰寫部落格-04更換ICARUS主題","text":"2023年新的一年，突然想要來幫部落格換個新主題，這陣子看到 ICARUS 主題，覺得蠻喜歡它的版面配置的，於是就把主題換一下，目前的環境已經裝好hexo了，這篇就直接從更換主題開始～< 更換主題注意事項：原本有一些主題特殊的標籤或是插件及文章內容有可能會發生失效或排版混亂，更換後需要再花時間修正過去的功能． 目錄 hexo 版本 與相依設定 更換主題 替換配置 魔改 theme 主題樣式 [後記] 過程中處理問題 網路參考文章 hexo 版本 與相依設定使用 hexo version 可以查詢版本 “點我查看hexo version ” >folded123456789101112131415161718192021222324252627282930313233+ $ hexo -vINFO Validating configInferno is in development mode.INFO ======================================= ██╗ ██████╗ █████╗ ██████╗ ██╗ ██╗███████╗ ██║██╔════╝██╔══██╗██╔══██╗██║ ██║██╔════╝ ██║██║ ███████║██████╔╝██║ ██║███████╗ ██║██║ ██╔══██║██╔══██╗██║ ██║╚════██║ ██║╚██████╗██║ ██║██║ ██║╚██████╔╝███████║ ╚═╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚══════╝=============================================INFO === Checking package dependencies ===INFO === Checking theme configurations ===INFO === Registering Hexo extensions ===hexo: 6.3.0hexo-cli: 4.3.0os: darwin 22.2.0 13.1node: 14.17.0v8: 8.4.371.23-node.63uv: 1.41.0zlib: 1.2.11brotli: 1.0.9ares: 1.17.1modules: 83nghttp2: 1.42.0napi: 8llhttp: 2.1.3openssl: 1.1.1kcldr: 38.1icu: 68.2tz: 2020dunicode: 13.0 “點我查看package.json ” >folded123456789101112131415161718192021222324252627282930313233343536{ &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;server&quot;: &quot;hexo server&quot; }, &quot;hexo&quot;: { &quot;version&quot;: &quot;6.3.0&quot; }, &quot;dependencies&quot;: { &quot;bulma-stylus&quot;: &quot;^0.8.0&quot;, &quot;hexo&quot;: &quot;^6.3.0&quot;, &quot;hexo-asset-image&quot;: &quot;^1.0.0&quot;, &quot;hexo-component-inferno&quot;: &quot;^2.0.2&quot;, &quot;hexo-deployer-git&quot;: &quot;^2.1.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;, &quot;hexo-log&quot;: &quot;^3.2.0&quot;, &quot;hexo-pagination&quot;: &quot;^2.0.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-inferno&quot;: &quot;^0.1.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^3.0.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;, &quot;hexo-server&quot;: &quot;^2.0.0&quot;, &quot;hexo-tag-cloud&quot;: &quot;^2.1.2&quot;, &quot;hexo-theme-landscape&quot;: &quot;^0.0.3&quot; }, &quot;devDependencies&quot;: {}} 更換主題執行安裝指令 - 安裝位置安裝時有兩種安裝方式 see Getting Started with Icarus install from source12git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus --depth 1 install from NPM1npm install -S hexo-theme-icarus hexo-renderer-inferno Note:一開始我是用第二種安裝方式就裝起來了，不過看起來hexo-theme-icarus會出現在node_modules裡，不是在自己的themes/icarus 兩種方式都可以正確套用到主題效果，不過考慮到之後可能自己會想改主題底層效果當作自己的部分，後來改用第一種方式安裝． 20230319 更新，後來使用補丁，又改用第二種方式，這邊就依使用習慣即可． 執行 12$ hexo config theme icarus然後執行hexo s 就可以了 成功啟動後的初始畫面 可以看到這邊很多介紹都還沒有更改，接下來可以開始更改內容． 替換配置修正 ＿config 檔案 基本設定這裡面的設定就改成自己的資料，另外可以預設語言與時區 _config.yml123+ language: zh-TW+ timezone: 'Asia/Taipei' 修正 config.icarus 檔案 配置版面“點我查看config.icarus.yml細節” >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221version: 5.1.0variant: default- logo: /img/logo.svghead:- favicon: /img/favicon.svg manifest: name: short_name: start_url: theme_color: background_color: display: standalone icons: - src: '' sizes: '' type: open_graph: title: type: blog url: image: site_name: author: description: twitter_card: twitter_id: twitter_site: google_plus: fb_admins: fb_app_id: structured_data: title: description: url: author: publisher: publisher_logo: image: meta: - '' rss: navbar: menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about links:- Download on GitHub:- icon: fab fa-github- url: https://github.com/ppoffice/hexo-theme-icarusfooter: links: Creative Commons: icon: fab fa-creative-commons url: https://creativecommons.org/ Attribution 4.0 International: icon: fab fa-creative-commons-by url: https://creativecommons.org/licenses/by/4.0/ Download on GitHub: icon: fab fa-github url: https://github.com/ppoffice/hexo-theme-icarusarticle: highlight:- theme: atom-one-light+ theme: atom-one-dark clipboard: true fold: unfolded readtime: true update_time: true licenses: Creative Commons: icon: fab fa-creative-commons url: https://creativecommons.org/ Attribution: icon: fab fa-creative-commons-by url: https://creativecommons.org/licenses/by/4.0/ Noncommercial: icon: fab fa-creative-commons-nc url: https://creativecommons.org/licenses/by-nc/4.0/search: type: insight index_pages: truecomment: type: disqus shortname: ''donates: - type: afdian url: '' - type: alipay qrcode: '' - type: buymeacoffee url: '' - type: patreon url: '' - type: paypal business: '' currency_code: USD - type: wechat qrcode: ''share: type: sharethis install_url: ''sidebar: left: sticky: false right: sticky: falsewidgets: - position: left type: profile author: Your name author_title: Your title location: Your location avatar: avatar_rounded: false gravatar: follow_link: https://github.com/ppoffice social_links: Github: icon: fab fa-github url: https://github.com/ppoffice Facebook: icon: fab fa-facebook url: https://facebook.com Twitter: icon: fab fa-twitter url: https://twitter.com Dribbble: icon: fab fa-dribbble url: https://dribbble.com RSS: icon: fas fa-rss url: / - position: left type: toc index: true collapsed: true+ depth: 4 - position: left type: links links: Hexo: https://hexo.io Bulma: https://bulma.io - position: left type: categories - position: left type: recent_posts - position: left type: archives - position: left type: tags order_by: name amount: show_count: true - position: left type: subscribe_email description: feedburner_id: '' - position: left type: adsense client_id: '' slot_id: '' - position: left type: followit description: action_url: '' verification_code: ''plugins: animejs: true back_to_top: true baidu_analytics: tracking_id: bing_webmaster: tracking_id: + busuanzi: true cnzz: id: web_id: cookie_consent: type: info theme: edgeless static: false position: bottom-left policyLink: https://www.cookiesandyou.com/ gallery: true google_analytics: tracking_id: hotjar: site_id: katex: false mathjax: false outdated_browser: false progressbar: true statcounter: project: security: twitter_conversion_tracking: pixel_id: providers: cdn: jsdelivr fontcdn: google iconcdn: fontawesome logologo可以放置自己的圖片，svg檔案或png檔案都可以． highlight 代碼區塊我改成深色主題atom-one-dark，從它們提供的 styles 檔案位置 中找到的，預覽可以從highlight.js demo 看到效果． sidebar left/right.sticky: true 這設定可以固定左右側邊欄，閱讀時到下方時才會不會看不到 toc 這個是設定出現在部落格側邊的文章目錄，需配合文章開啟Front-Matter才能用，預設是顯示三層，我習慣改成四層． plugins busuanzi: true 這是開啟網站底部及和每篇文章頭部，顯示共多少訪客的開關，上線後數字才會正常． 新增文章文章的 Front-Matter设置1234567891011121314151617181920212223242526272829---title: &quot;[Blog] 使用 Hexo 撰寫部落格-04更換ICARUS主題&quot;+ //文章封面cover: /img/posts/dariusz-sankowski-3OiYMgDKJ6k-unsplash.jpg + //文章縮圖thumbnail: /img/posts/dariusz-sankowski-3OiYMgDKJ6k-unsplash.jpg+ // 文章目錄導覽toc: true+ // 文章標籤tags: - blog+ // 文章目錄categories: - [技術工具,blog]date: 2023-01-22 16:31:36+ 更改某篇文章的代码高亮主题article: highlight: theme: atom-one-dark---+ 這邊可以加入一些引言Post content...&lt;!--more--&gt;Post content... Tip 默認文章都是不開啟toc的，要手動添加在文章開頭，但網路上有教學使之預設開啟．或者你也可以加入到文章模板中． 文章插入圖片根據這篇說明Asset Folders，有兩種方式，一種是放在/source/images，一種是依文章分類放置． 123456789101112// 第一種方法 一定要取名images資料夾 不知道為什麼不能隨便命名&lt;img src=&quot;/images/icarus_init_ui.png&quot; width=&quot;auto&quot; /&gt;// 第二種方法 hexo new xxx 時會有一個獨立資料夾可以放圖片不知道為什麼我這邊是開啟post_asset_folder: true permalink: ':year/:month/:day/:title/'![icarus_init](icarus_init.png)update link as:--&gt;/.io//icarus_init.png但是發現無法找到資料，推判可能是我的插件有什麼插件無法對應到日期 待查 文章插入代碼12345678//第一種可以簡單用```diff “hexo version” &gt;folded //第二種放入codeblock {% codeblock &quot;config.icarus.ym&quot; lang:diff &gt;folded %}{% endcodeblock %}//可以指定是否折疊,沒指定就照預設黨 魔改 theme 主題樣式有時候套用主題，可能會有些地方格式想要調整，就要去更改底層主題的檔案，另外，這邊的更改發布之後，可能會需要清除 cache 才能看到效果． 更改 header logo 高度 因為自己的logo 內容較多，上傳時發現會被自動縮小，為了清楚顯示，所以我把高度調高了，1$logo-height ?= 5rem Warning 這邊要注意圖片是否會模糊（雖然在電腦檔案中看來正常），要設定適當的大小，或是換成svg檔案試試． 更改卡片懸浮效果這個教學是來自 挂件卡片增加浮动效果 include/style/card.styl 當滑鼠移到卡片上時添加陰影及上移效果1234.card+ &amp;:hover+ box-shadow: 0 6px 15px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1)+ transform: translateY(-3px); source/js/animation.js 加上陰影漸變動畫效果1234567.card- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; });- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; }, i * 100); [後記] 過程中處理問題 這個段落是用來記錄過程中遇到的問題，如果你沒有遇上問題可以直接跳過這個章節． 安裝啟動錯誤123註：因為我是從NextT轉換過來的，才發現有些特殊標籤在這邊啟動會爆錯&gt; ：``` Error [Nunjucks Error]: about/index.md [Line 7, Column 4] unknown block tag: note```&gt; 因此我把文章中的找到`{% `與`{% endnote %}`。移除． 再次啟動還是爆錯12345const { Component } = require('inferno'); const classname = require('hexo-component-inferno/lib/util/classname'); const Head = require('./common/head'); const Navbar = require('./common/navbar'); const Widgets = require('./common/widgets'); const Footer = require('./common/footer'); const Scripts = require('./common/scripts'); const Search = require('./common/search'); module.exports = class extends Component { render() { const { site, config, page, helper, body } = this.props; const language = page.lang || page.language || config.language; const columnCount = Widgets.getColumnCount(config.widgets); return ; } };// 解法因為官網github 少了hexo-renderer-inferno 用另一個月再次安裝即可- $ npm install hexo-theme-icarus+ $ npm install -S hexo-theme-icarus hexo-renderer-inferno 刪除舊的NextT主題預設產生位置如果下hexo clean hexo g 會發現文章會產生在public資料夾裡，以前舊的主題先刪除 >folded12345678- 2020- 2021+ .....+ public+ 2020+ 2021 插入圖片時不知道為什麼不能用與文章放置一起的設定(尚未解)12345678// 第一種方法 hexo new xxx 時會有一個獨立資料夾可以放圖片不知道為什麼我這邊是開啟post_asset_folder: true permalink: ':year/:month/:day/:title/'![icarus_init](icarus_init.png)update link as:--&gt;/.io//icarus_init.png但是發現無法找到資料，推判可能是我的插件有什麼插件無法對應到日期 待查 highlight 主題部分無效果 不知道為什麼除了atom-one-dark，換成別的都沒有效果． hexo 版本升級一開始用的hexo版本是5.4.2，但是啟動時噴ERRROR 提示要升至hexo: 6，還有其他錯誤…，於是就一步步照著指令安裝就啟動成功了． 主題備份自己有開了一個 src 分支用來記錄所有原生檔案，因為上傳只會紀錄 public 檔案，但是theme這個資料夾裡面是 git clone 別人的（theme作者），所以其實是不會出現在自己分支內的，如果有魔改theme的要記得自己在備份一下．我自己是開了一個icarus_fix_record來記錄，雖然有點麻煩，但以後要更新比較方便（或許會更新ＸＤ），如果改得太多可以考慮解除git綁定上傳整個theme． 20230319更新：改用補丁更新，可以看最新文章． 部署時卡住 1.檢查token有沒有過期 2.檢查上傳使用者是否錯誤12345git config --global -luser.name=xxxuser.email=xxx@gmail.comcredential.username=xxxcredential.helper=osxkeychain 未完待續 待研究中…12345678910111213141516多語言多階層Submenuhttps://github.com/ppoffice/hexo-theme-icarus/issues/527看板娘留言區魔改SEObuymecoffeeOpen GraphIcarus用户指南 - 主题配置 Google Structured Data 你可以在head配置中设置Google Structured Data。 你应该在配置文件中将绝大部分配置留空。 仅在需要的时候在文章的front-matter中为这些设置赋值。https://ppoffice.github.io/hexo-theme-icarus/Widgets/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E6%8C%82%E4%BB%B6/添加404公益页面中文分類或標籤 tag_map 網路參考文章 hexo-theme-icarus github Icarus快速上手 Icarus用户指南 - 主题配置 Icarus的默认主题配置文件为_config.icarus.yml。 此文件定义了站点全局的布局与样式设置，同时也控制了例如插件与挂件等外部功能的配置。 本文详细介绍了本主题的一般配置，并且解释了Icarus使用哪些配置文件和它是如何生成并验证这些配置。 Hexo-Icarus主题配置建议 活用 Bulma 美化 Icarus 文章 Hexo博客指南|第十二篇:Icarus配置 - 网站分析插件 不蒜子网页计数器 及其他統計插件 圖片來源：https://unsplash.com/","link":"https://minilabmemo.github.io/2023/01/22/blog-hexo-04-theme-icarus/"},{"title":"[JS 筆記 01] javascript 新手上路與概念","text":"本章由MDN-JavaScript開始著手練習，並筆記學習概念． JS歷史- ES6 2015ECMAScript是一種由Ecma國際定義的手稿語言規範，它往往被稱為JavaScript或JScript (維基) ES6為ECMAScript2015，是大幅度的更新，討論度較高， 宣告與各用法概念命名規則 小寫駱駝 大小寫相異(敏感) 有意義的名字 ref:关于变量命名的规则 變數 宣告變數但不賦值=undefined null常見於宣告後面定義成沒有值或找不到 全域屬性 NaN 表示「非數值」（Not-A-Number）的數值 NaN 不等於（==、!=、===、!==）任何值，包括 NaN 本身。請使用 Number.isNaN() 或 isNaN() 來確認某個數值是否為 NaN。 ref:var 与 let 的区别 | let | NaN 操作比對嚴格相等（===）先比較型別 一般相等（==）一般相等會先將比較值轉換成同型別後比較。轉換後（可能一個或兩個都被轉換），接著進行的幾乎和嚴格比較（===）一樣。 1234console.log(123 === &quot;123&quot;); falseconsole.log(false === 0);falseconsole.log(false == 0);trueconsole.log(123 == &quot;123&quot;);true 部分開發者認為最好別用一般相等。嚴格比較更容易預測，且因為不必轉型，因此效率更好。 同值相等 label info@ES6%} 提出同值相等演算法，用來解決這個問題。Object.is就是部署這個演算法的新方法。同值相等解決了最後一個情況：比較兩個值是否功能相同 。Object.is 會和嚴格相等做同樣的事，但會將 NaN、-0 和 +0 獨立處理，因此這三個不會相等 零值相等和同值相等一樣，但將 +0 和 -0 視為相同。 12console.log(-0 == +0); trueconsole.log(-0 === +0); true 更多比較表可以看 Equality_comparisons_and_sameness 陣列比較more 如何在 JavaScript 中比較兩個陣列 二元邏輯運算子JavaScript 中的真假值在判斷會自動作轉型，像是 null、NaN、0、空字串（””、’’）、undefined 都會被轉型並判斷為「false」。 &amp;&amp;a= 條件式 ＆＆“”12a5 = 'Cat' &amp;&amp; 'Dog' // t &amp;&amp; t returns &quot;Dog&quot;a6 = false &amp;&amp; 'Cat' // f &amp;&amp; t returns false ||123456const a = 0 || 'hidden'; // 因為 0 被轉型後為 false，所以 a 會是 'hidden'const b = 26900 || 24900; // 因為 26900 會轉型為 true，所以 b 會是 26900 &gt;label info@ES6%} - 展開語法（spread syntax）&amp; 其餘語法（rest syntax）展開運算子(…) 允許可迭代的陣列或字串展開成０到多個參數 字符操作 一個字符串和一個数字可以直接相加變成字串 把字串當作對象，或許長度或大小寫轉換去處理字符串123456&lt;script&gt; let s = 19 + '67'; console.log(&quot;s:&quot;+s+&quot; type:&quot;+typeof s); //鍵入s.可以找到很多以字符為對象的操作&lt;/script&gt;s:1967 type:string Number()对象将把传递给它的任何东西转换成一个数字 123let myString = '123';let myNum = Number(myString);typeof myNum; toString()每个数字都有一个名为 toString() 的方法，它将把它转换成等价的字符串。 ref:JavaScript中的字符串 樣板字面值 label info@ES6%} 樣板字面值（Template literals）是允許嵌入運算式的字串字面值（string literals）。 被反引號（back-tick，重音符號 )字元封閉，代替了雙或單引號。 可以包含由錢字元及花括號所構成（${expression}）的佔位符（placeholders） 1234567`string text line 1 string text line 2``string text ${expression} string text`tag `string text ${expression} string text` 標籤樣板字面值是一種更高級的樣板字面值形式，允許你透過&gt;label warning@自訂命名標籤函數 %}操作樣板字面值的輸出。 巢狀的樣板字面值的應用Javascript 進階 10-3 巢狀結構 物件屬性名稱縮寫（Shorthand property names） Key 與 Value 名稱相同，可進行縮寫 物件內可直接省略 function 關鍵字進行縮寫 &gt;label info@ES6%} - 解構賦值 Destructuring assignment可以把陣列或物件中的資料解開擷取成為獨立變數詳細請見:MDN-解構賦值 123456789101112const o = {p: 42, q: true};const {p, q} = o;console.log(p); // 42console.log(q); // true///const o = {p: 42, q: true};const {p: foo, q: bar} = o;console.log(foo); // 42console.log(bar); // true 函式宣告 可用函式宣告（Function Declaration）（ES5） 函式運算式(表達式)（Function Expressions）（ES5） 宣告一個函數，或匿名函數 (anonymous function / function literal) 當作值指定給一個變數 箭頭函式運算式（arrow function expression）（&gt;label success@ES6 %}） 它沒有自己的 this、arguments、super、new.target 等語法。 function 建構子說明 JavaScript 使用稱為建構子函式（constructor function）的特殊函式，定義物件與功能。123456789101112131415161718// 自己的一些東西function Person(first, last, age, gender, interests) { this.name = { first, last }; this.age = age; this.gender = gender; this.interests = interests; this.bio = function() { alert(this.name.first + ' ' + this.name.last + ' is ' + this.age + ' years old. He likes ' + this.interests[0] + ' and ' + this.interests[1] + '.'); }; this.greeting = function() { alert('Hi! I\\'m ' + this.name.first + '.'); };};var person1 = new Person('Bob', 'Smith', 32, 'male', ['music', 'skiing']); Ref:初學者應知道的物件導向 JavaScript 箭頭函式不可作為建構式使用；若使用於建構式，會在使用 new 時候拋出錯誤。 沒有 arguments “引數”參數,當需要使用 arguments 請維持使用 function。[-&gt;參數引數的概念請先知道] 宣告 ＸＸＸ等於 (參數1, 參數2, …, 參數N) =&gt; { return 表示式; }1234567//箭頭 宣告 ＸＸＸ等於 (參數1, 參數2, …, 參數N) =&gt; { return 表示式; }const Pet_Arr = (color) =&gt; { this.color = color;}// ini_constructor_proto.html:99 Uncaught TypeError: Pet_Arr is not a constructor//箭頭函式不可作為建構式使用；若使用於建構式，會在使用 new 時候拋出錯誤。const PetA = new Pet_Arr('yellow'); // Ref: 箭頭函式 MDN 宣告練習使用及細節可以看下方 (js_func.html)123456789101112131415161718192021222324252627282930313233343536&lt;script&gt; // ES5 函式宣告（Function Declaration） //function 函式名稱(參數) { function Add(A, B) { return A + B; } /* 或 */ // ES5 函式運算式(表達式)（Function Expressions） // var 函式名稱 = function (參數) { var Add2 = function (A, B) {//匿名函式 return A + B; } var Add3 = function add3(A, B) {//#1 非匿名函式 console.log(typeof add3);//#1 但只在自身有效 return A + B; } console.log(Add(1, 2))//3 console.log(Add2(1, 2))//3 console.log(Add3(1, 2))//3 //console.log(add3(1, 2))//#1 ReferenceError: add3 is not defined //ES6 宣告型態 函式名稱 = (參數) =&gt; { var Add4 = (A, B) =&gt; { return A + B; } //縮寫 如果只有return 可以去掉{}與return var Add5 = (A, B) =&gt; A + B; //縮寫 如果只有一個參數 可以去掉（） var AddS1 = (A) =&gt; A; var AddS2 = A =&gt; A; console.log(&quot;ES6:&quot; + Add4(1, 2))//3 console.log(&quot;ES6:&quot; + Add5(1, 2))//3&lt;/script&gt; this的問題與箭頭函數的出現箭頭函式有兩個重要的特性：更短的函式寫法與 this 變數的非綁定。 使用及細節可以看下方 (js_func_this.html)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;script&gt; //ES5 函示內this會指向windows而非Person，因此要像PersonSolve寫法 function Person() { // Person() 建構式將 this 定義為它自己的一個實體 this.age = 0; console.log(&quot;Person():&quot; + this.constructor.name); setTimeout(function growUp() { // 在非嚴格模式下, growUp() 函式把 this 定義為全域物件 // (因為那是 growUp()執行的所在)， // 與 Person() 建構式所定義的 this 有所不同 this.age++; console.log(&quot;Person.setTimeout():&quot; + this.constructor.name); console.log(&quot;Person.setTimeout():&quot; + this.age) }, 1000); } function PersonSolve() { var self = this; // 有些人喜歡 `that` 而不是 `self`. // 選好一種取法後始終如一 self.age = 0; console.log(&quot;PersonSolve():&quot; + this.constructor.name); setTimeout(function growUp() { // 這個 callback 參考 `self` 變數，為預期中的物件。 self.age++; console.log(&quot;PersonSolve.setTimeout():&quot; + self.constructor.name); console.log(&quot;PersonSolve.setTimeout():&quot; + self.age) }, 1000); } var p1 = new Person(); var p2 = new PersonSolve(); //--------- //ES6 箭頭函示------------------------------ function Person_Arr() { this.age = 0; console.log(&quot;Person_Arr():&quot; + this.constructor.name); setTimeout(() =&gt; { this.age++; // |this| 適切的參考了Person建構式所建立的物件 console.log(&quot;Person_Arr.setTimeout():&quot; + this.constructor.name); console.log(&quot;Person_Arr.setTimeout():&quot; + this.age) }, 1000); } var p3 = new Person_Arr(); //ES6 箭頭函示------------------------------ // OUTPUT // js_func_this.html: 17 Person(): Person // js_func_this.html: 31 PersonSolve(): PersonSolve // js_func_this.html: 47 Person_Arr(): Person_Arr // js_func_this.html: 23 Person.setTimeout(): Window --&gt;發現竟然指向Window // js_func_this.html: 24 Person.setTimeout(): NaN --&gt;內容不見！！ // js_func_this.html: 35 PersonSolve.setTimeout(): PersonSolve --&gt;workaround解法 // js_func_this.html: 36 PersonSolve.setTimeout(): 1 // js_func_this.html: 50 Person_Arr.setTimeout(): Person_Arr --&gt;ES6 arrow解法 // js_func_this.html: 51 Person_Arr.setTimeout(): 1&lt;/script&gt; 箭頭函式並沒有原型（prototype）屬性。more ref: this不分家 ＴＢＤno this newhttps://developer.cdn.mozilla.net/zh-TW/docs/Web/JavaScript/Reference/Functions/Arrow_functions#this_%E4%B8%8D%E5%88%86%E5%AE%B6 JS的 Hoisting (提升)顶置特性 變數(var hoisting)與函數都可以先使用再宣告 但提升操作不再适用于 let 并引起一个错误(Uncaught ReferenceError)ref:JavaScript Hoisting (提升) &gt;label info@ES6%} - 使用module分檔 (import &amp; export)閉包（Closure）閉包是函式以及該函式被宣告時所在的作用域環境的組合。 閉包的好處能把變數隱藏在裡面讓外部存取不到 閉包在 callback 上的應用尤其常見 在迴圈建立閉包：一個常見錯誤在 ECMAScript 2015 (&gt;label info@ES6%} )導入 let 前，迴圈內建立的閉包，常會發生問題。範例請見： simple_js_demo-closure Ref: MDN-閉包 [你懂 JavaScript 嗎？#15 閉包（Closure）]（https://cythilya.github.io/2018/10/22/closure/） 探討：JavaScript OOPOOP （(Object-oriented programming）物件導向/對象編程，在 JavaScript 中，大多数事物都是对象, 从作为核心功能的字符串和数组。你甚至可以自己创建对象，在调用函数前加一个 new ，它就会返回一个这个函数的实例化对象，. 然后，就可以在这个对象上面添加一些属性．JavaScript 对象入门 舉例： 用new func()來建構新的物件，func內部this可以指項新屬性 透過建構子（constructor）所建立出來的物件，我們稱為實例（instance） 如果忘記打new，變數會出現undifined1234567891011121314151617181920212223//this 指向了代码所在的对象(其实代码运行时所在的对象)。function Pet(first,last, age) { this.name= { 'first': first, 'last': last }; this.interests = ['food', 'sleep'], this.age = age; this.walk = function () { console.log(this.name.first + &quot; walk...&quot;); } //這樣寫會佔用不同的對象空間}//函数的实例化对象var cat1 = new Pet('dotdot','wu', 11);var dog1 = new Pet('lucky','wu', 9);//通过简单的语法访问他们console.log(cat1.name.first)//点表示法访问console.log(cat1['name']['first']) //括号表示法console.log(cat1.interests[1])//数组属性的一个子元素console.log(cat1.walk())//对象的方法调用 ref:[筆記] 談談 JavaScript 中的 function constructor 和關鍵字 new Prototype 原型鏈的原理上述的寫法，cat1.walk()與dog1.walk()是兩個不同對象的方法，為解決這問題． walk指定在 Pet.prototype 上面，所有 Pet 的 instance 都可以共享這個方法 123Pet.prototype.walk = function() { console.log(this.name.first + &quot; walk...&quot;);} 因為 cat1 這個 instance 本身並沒有 walk 這個 function， 找不到，它會試著從Pet.prototype去找，一直往上找，直到找到Object，如果還是沒有，就會回傳undefined 而這個連接的方式，就是__proto__。 同时也有一些其他成员—— watch、valueOf 等等——这些成员定义在 Person() 构造器的原型对象、即 Object 。 ref:該來理解 JavaScript 的原型鍊了 proto 和 prototype 到底有什麼區別 JavaScript 中的繼承 (prototypal inheritance) call()函数。基本上，这个函数允许您调用一个在这个文件里别处定义的函数。 设置 Teacher() 的原型和构造器引用 create()这意味着Teacher.prototype现在会继承Person.prototype的所有属性和方法 prototype的constructor属性指向的是Person(),要改指向 Teacher 可重寫Teacher的greeting1234567891011121314151617181920212223242526//定义 Teacher() 构造器函数 function Teacher(first, last, age, gender, interests, subject) { Person.call(this, first, last, age, gender, interests); this.subject = subject; } //这意味着Teacher.prototype现在会继承Person.prototype的所有属性和方法 Teacher.prototype = Object.create(Person.prototype); Teacher.prototype.constructor = Teacher;//原本的是指向Ｐerson Teacher.prototype.greeting = function () {//重開改寫 var prefix; if (this.gender === 'male' || this.gender === 'Male' || this.gender === 'm' || this.gender === 'M') { prefix = 'Mr.'; } else if (this.gender === 'female' || this.gender === 'Female' || this.gender === 'f' || this.gender === 'F') { prefix = 'Mrs.'; } else { prefix = 'Mx.'; } alert('Hello. My name is ' + prefix + ' ' + this.name.last + ', and I teach ' + this.subject + '.'); }; var teacher1 = new Teacher('Dave', 'Griffiths', 31, 'male', ['football', 'cookery'], 'mathematics'); teacher1.greeting() ref:JavaScript 中的继承 探討何時使用與參考網站練習 TBD:https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain &gt;label info@ES6%} 類別 (class)ECMAScript 6 中引入了類別 (class) 作為 JavaScript 現有原型程式(prototype-based)繼承的語法糖。類別語法並不是要引入新的物件導向繼承模型到 JavaScript 中，而是提供一個更簡潔的語法來建立物件和處理繼承。 ref:Classes 類別宣告 (class declaration) 使用關鍵字 class1234567class Polygon { constructor(height, width) { this.height = height; this.width = width; }} var p = new Polygon(); 相較函數宣告有Hoisting，類別宣告則否。 你需要先宣告類別，然後存取它，否則就會丟出 ReferenceError: note danger %} var p = new Polygon(); // ReferenceErrorclass Polygon {} 類別敘述(class expressions) 類別敘述是定義類別的另一種方法。類別敘述可以有名稱或是無名稱。賦予一個有名稱類別敘述的名稱只在類別主體(class’s body)中有作用。（✍ 其實跟之前提到的Function Expressions一樣概念）123456789101112131415// unnamedvar Polygon = class { constructor(height, width) { this.height = height; this.width = width; }};// namedvar Polygon = class Polygon { constructor(height, width) { this.height = height; this.width = width; }}; 使用JSON JSON要求在字符串和属性用雙引號， 但引號無效。 我们使用 . 或 [] 訪問对象内的数据 JSON.parse用於將文字轉成json object12request.responseType = 'text';var superHeroes = JSON.parse(superHeroesText); JSON.stringify用於將json object轉成json string123var myJSON = { &quot;name&quot;: &quot;Chris&quot;, &quot;age&quot;: &quot;38&quot; }; console.log(myJSON)var myString = JSON.stringify(myJSON);console.log(myString)//string:{&quot;name&quot;:&quot;Chris&quot;,&quot;age&quot;:&quot;38&quot;} 事件(Event) 好得寫法是找到(select)button並添加事件，避免汙染HTML。 關於button.onclick vs addEventListener on會覆蓋上一个事件 addEventListener事件，可以多次绑定同一个事件并且不会覆盖上一个事件 ref:JS裡addEventListener和on的區別 延伸：Lint 工具在電腦科學中，lint是一種工具程式的名稱，它用來標記原始碼中，某些可疑的、不具結構性（可能造成bug）的段落。它是一種靜態程式分析工具 JSLintJSLint 幫你檢查未定義的變數、函數、陳述式結尾有沒有加分號(;)、變數使用之前要先用 var 宣告、使用非數字的變數要用 === 或 !== 讓比對的時候不要自動進行轉型(Casting)、盡量不要使用 eval 函數、… 好多好多 ESLint包括格式檢驗及質量效驗（未使用變量、三等號、全局變量聲明等問题）自由選擇要使用哪些規則，對 &gt;label info@ES6%} 還有 JSX 的支援度跟其他 linter 相較之下也是最高的 註： prettier 只是格式的檢驗（空格 格式化），不会對代码质量进行校验。但有些檢驗，ESLint沒有，所以可以ESLint＋prettier一起使用，也可以視使用情況不使用 Prettier。 其他練習上述概念練習simple_js_demo JS 與 canvas 元素基礎繪製說明Canvas 是H5新出來的標籤 元素需要有闭合标签 基本上現今所有主流的瀏覽器都有支援 所有元素定位皆相對於此左上角原點 HTML 123&lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt; JS 圓形ctx.arc(x, y, 半徑, 開始弧度, 結束弧度 )0~2 pi =360°更多弧度示意圖：弧度 1234var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d');ctx.fillStyle = 'green';ctx.fillRect(10, 10, 100, 100);//畫矩形 x start,y start,width,height 利用漸變色及貝斯曲線或是填入圖案，繪製文字，可做出很多豐富的圖案，還有動畫行星/時鐘，滑鼠動畫，像素控制等，詳請見下方文件 ref:Canvas 教學文件 彈跳彩球範例Ｒef: 物件建構實作 破撞說明1234567891011https://developer.mozilla.org/zh-CN/docs/Games/Techniques/2D_collision_detectionvar circle1 = {radius: 20, x: 5, y: 5};//radius半徑及座標var circle2 = {radius: 12, x: 10, y: 5};var dx = circle1.x - circle2.x;var dy = circle1.y - circle2.y;var distance = Math.sqrt(dx * dx + dy * dy);//平面兩點之間距離公式if (distance &lt; circle1.radius + circle2.radius) { //原形半徑相加=兩圓碰撞時的距離 // collision detected!} 動畫操控範例說明https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial/Basic_animations 排程更新第一種作法是利用window.setInterval()與window.setTimeout()方法。 Note: 針對新版瀏覽器建議採用window.requestAnimationFrame()方法。方法為動畫提供更順暢更有效率的方式來執行,當系統準備好繪製畫面時,藉由呼叫動畫andmation frame()的callback函數。 requestanimationframe-with-react深入理解requestAnimationFrame的動畫迴圈Web 計時與動畫 [javascript] requestAnimationFrame 優化動畫效率與資源 Event操控範例說明https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Advanced_animations這邊的話可以看到，Event滑鼠控制只能針對整個畫布做操作，每次更新都是更新畫布，內容物件是不存在的。 延伸:Canvas和SVGCanvas是點陣圖，受解析度影響，SVG是向量圖。使用svg有好有壞:好處是方便操作dom元素, 可操作元素。壞處是渲染效率不高, 在數據量較大時頁面易掉幀, 卡頓，不適合遊戲。 D3 操控SVG或是Canvashttp://blog.infographics.tw/2015/07/optimize-d3-with-canvas/","link":"https://minilabmemo.github.io/2021/02/20/js-start-01/"}],"tags":[{"name":"test","slug":"test","link":"https://minilabmemo.github.io/tags/test/"},{"name":"golang","slug":"golang","link":"https://minilabmemo.github.io/tags/golang/"},{"name":"vscode","slug":"vscode","link":"https://minilabmemo.github.io/tags/vscode/"},{"name":"cleanCode","slug":"cleanCode","link":"https://minilabmemo.github.io/tags/cleanCode/"},{"name":"Kubernetes","slug":"Kubernetes","link":"https://minilabmemo.github.io/tags/Kubernetes/"},{"name":"CLI","slug":"CLI","link":"https://minilabmemo.github.io/tags/CLI/"},{"name":"cloud","slug":"cloud","link":"https://minilabmemo.github.io/tags/cloud/"},{"name":"storage","slug":"storage","link":"https://minilabmemo.github.io/tags/storage/"},{"name":"aws-s3","slug":"aws-s3","link":"https://minilabmemo.github.io/tags/aws-s3/"},{"name":"MinIO","slug":"MinIO","link":"https://minilabmemo.github.io/tags/MinIO/"},{"name":"blog","slug":"blog","link":"https://minilabmemo.github.io/tags/blog/"},{"name":"docusaurus","slug":"docusaurus","link":"https://minilabmemo.github.io/tags/docusaurus/"},{"name":"gitbook","slug":"gitbook","link":"https://minilabmemo.github.io/tags/gitbook/"},{"name":"hexo","slug":"hexo","link":"https://minilabmemo.github.io/tags/hexo/"},{"name":"google_analytics","slug":"google-analytics","link":"https://minilabmemo.github.io/tags/google-analytics/"},{"name":"hugo","slug":"hugo","link":"https://minilabmemo.github.io/tags/hugo/"},{"name":"debug","slug":"debug","link":"https://minilabmemo.github.io/tags/debug/"},{"name":"ing","slug":"ing","link":"https://minilabmemo.github.io/tags/ing/"},{"name":"docker","slug":"docker","link":"https://minilabmemo.github.io/tags/docker/"},{"name":"elasticSearch","slug":"elasticSearch","link":"https://minilabmemo.github.io/tags/elasticSearch/"},{"name":"kibana","slug":"kibana","link":"https://minilabmemo.github.io/tags/kibana/"},{"name":"mongo","slug":"mongo","link":"https://minilabmemo.github.io/tags/mongo/"},{"name":"file","slug":"file","link":"https://minilabmemo.github.io/tags/file/"},{"name":"command","slug":"command","link":"https://minilabmemo.github.io/tags/command/"},{"name":"GitHub","slug":"GitHub","link":"https://minilabmemo.github.io/tags/GitHub/"},{"name":"heroku","slug":"heroku","link":"https://minilabmemo.github.io/tags/heroku/"},{"name":"deploy","slug":"deploy","link":"https://minilabmemo.github.io/tags/deploy/"},{"name":"GUI","slug":"GUI","link":"https://minilabmemo.github.io/tags/GUI/"},{"name":"java","slug":"java","link":"https://minilabmemo.github.io/tags/java/"},{"name":"Memory","slug":"Memory","link":"https://minilabmemo.github.io/tags/Memory/"},{"name":"IDEA","slug":"IDEA","link":"https://minilabmemo.github.io/tags/IDEA/"},{"name":"spring","slug":"spring","link":"https://minilabmemo.github.io/tags/spring/"},{"name":"jmeter","slug":"jmeter","link":"https://minilabmemo.github.io/tags/jmeter/"},{"name":"qa","slug":"qa","link":"https://minilabmemo.github.io/tags/qa/"},{"name":"javascript","slug":"javascript","link":"https://minilabmemo.github.io/tags/javascript/"},{"name":"ES6","slug":"ES6","link":"https://minilabmemo.github.io/tags/ES6/"},{"name":"callback","slug":"callback","link":"https://minilabmemo.github.io/tags/callback/"},{"name":"Promises","slug":"Promises","link":"https://minilabmemo.github.io/tags/Promises/"},{"name":"aync&#x2F;await","slug":"aync-await","link":"https://minilabmemo.github.io/tags/aync-await/"},{"name":"linux","slug":"linux","link":"https://minilabmemo.github.io/tags/linux/"},{"name":"Prometheus","slug":"Prometheus","link":"https://minilabmemo.github.io/tags/Prometheus/"},{"name":"Grafana","slug":"Grafana","link":"https://minilabmemo.github.io/tags/Grafana/"},{"name":"monitor","slug":"monitor","link":"https://minilabmemo.github.io/tags/monitor/"},{"name":"tool","slug":"tool","link":"https://minilabmemo.github.io/tags/tool/"},{"name":"modules","slug":"modules","link":"https://minilabmemo.github.io/tags/modules/"},{"name":"note","slug":"note","link":"https://minilabmemo.github.io/tags/note/"},{"name":"css","slug":"css","link":"https://minilabmemo.github.io/tags/css/"},{"name":"html","slug":"html","link":"https://minilabmemo.github.io/tags/html/"},{"name":"python","slug":"python","link":"https://minilabmemo.github.io/tags/python/"},{"name":"call by sharing","slug":"call-by-sharing","link":"https://minilabmemo.github.io/tags/call-by-sharing/"},{"name":"react","slug":"react","link":"https://minilabmemo.github.io/tags/react/"},{"name":"ramda","slug":"ramda","link":"https://minilabmemo.github.io/tags/ramda/"},{"name":"map","slug":"map","link":"https://minilabmemo.github.io/tags/map/"},{"name":"css-in-js","slug":"css-in-js","link":"https://minilabmemo.github.io/tags/css-in-js/"},{"name":"recharts","slug":"recharts","link":"https://minilabmemo.github.io/tags/recharts/"},{"name":"Material-ui","slug":"Material-ui","link":"https://minilabmemo.github.io/tags/Material-ui/"},{"name":"lint","slug":"lint","link":"https://minilabmemo.github.io/tags/lint/"},{"name":"npm","slug":"npm","link":"https://minilabmemo.github.io/tags/npm/"},{"name":"JSX","slug":"JSX","link":"https://minilabmemo.github.io/tags/JSX/"},{"name":"Babel","slug":"Babel","link":"https://minilabmemo.github.io/tags/Babel/"},{"name":"IDE","slug":"IDE","link":"https://minilabmemo.github.io/tags/IDE/"},{"name":"閉包","slug":"閉包","link":"https://minilabmemo.github.io/tags/%E9%96%89%E5%8C%85/"},{"name":"解構賦值","slug":"解構賦值","link":"https://minilabmemo.github.io/tags/%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC/"}],"categories":[{"name":"技術工具","slug":"技術工具","link":"https://minilabmemo.github.io/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/"},{"name":"Backend","slug":"Backend","link":"https://minilabmemo.github.io/categories/Backend/"},{"name":"golang","slug":"Backend/golang","link":"https://minilabmemo.github.io/categories/Backend/golang/"},{"name":"devOps","slug":"技術工具/devOps","link":"https://minilabmemo.github.io/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/devOps/"},{"name":"cloud","slug":"技術工具/cloud","link":"https://minilabmemo.github.io/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/cloud/"},{"name":"blog","slug":"技術工具/blog","link":"https://minilabmemo.github.io/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/blog/"},{"name":"Frontend","slug":"Frontend","link":"https://minilabmemo.github.io/categories/Frontend/"},{"name":"測試","slug":"技術工具/測試","link":"https://minilabmemo.github.io/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/%E6%B8%AC%E8%A9%A6/"},{"name":"未分類","slug":"技術工具/未分類","link":"https://minilabmemo.github.io/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/%E6%9C%AA%E5%88%86%E9%A1%9E/"},{"name":"java","slug":"Backend/java","link":"https://minilabmemo.github.io/categories/Backend/java/"},{"name":"Linux&#x2F;Mac","slug":"技術工具/Linux-Mac","link":"https://minilabmemo.github.io/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/Linux-Mac/"},{"name":"效能","slug":"技術工具/效能","link":"https://minilabmemo.github.io/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/%E6%95%88%E8%83%BD/"},{"name":"modules","slug":"技術工具/modules","link":"https://minilabmemo.github.io/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/modules/"},{"name":"python","slug":"Backend/python","link":"https://minilabmemo.github.io/categories/Backend/python/"},{"name":"IDE","slug":"技術工具/IDE","link":"https://minilabmemo.github.io/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/IDE/"},{"name":"tips","slug":"Frontend/tips","link":"https://minilabmemo.github.io/categories/Frontend/tips/"},{"name":"js","slug":"Frontend/js","link":"https://minilabmemo.github.io/categories/Frontend/js/"},{"name":"css&#x2F;html","slug":"Frontend/css-html","link":"https://minilabmemo.github.io/categories/Frontend/css-html/"},{"name":"react","slug":"Frontend/react","link":"https://minilabmemo.github.io/categories/Frontend/react/"}],"pages":[{"title":"關於 About","text":"關於 小研究式小研究式｜Mini Lab 或又稱小研備忘室|Mini Lab Memo 是用來記錄學習或是生活相關的個人部落格，大部分是程式相關，自己不是很厲害的人，這些文章談不上教學，只是記錄自己學習的備忘筆記，學習過程中受過很多網路上大神的幫助，跌跌撞撞走到現在，持續分享與紀錄，如果這些可以意外幫助到某一個人，我也會很開心的． 關於我 後端IT工程師，Go經歷兩年 & 正在學習 React。 喜歡貓狗． 透過實作紀錄與搜集整理資料來做比較理解 本部落格持續紀錄自學筆記，如有誤還請您不吝指出與指教 部落格大多是自己學習時記錄下來的內容，有些流程中較少說明與圖片，如果不清楚的地方最後都有附上參考連結，請自行再深入研究，有時間也會再將文章補完整的． 基本資訊： 🌱 I’m currently learning React,Golang,Python 📝 I regulary write articles on https://minilabmemo.github.io/ 📫 How to reach me minilabmemo@gmail.com 經歷與技能: 後端 golang 開發經歷兩年 熟悉開發 Restful Web API 基礎網頁 HTML,CSS,JS,JQUERY 概念，正在學習前端技能:React 其他 Transfer Protocol : WebSocket、MQTT 開發經歷 資料庫 RDBMS SQL &amp; NoSQL(Mongo) 操作與使用經驗 版本控制: 基礎 Git 操作，對 Git flow 有概念 會使用 docker/docker compose 啟動服務 ＆ 撰寫 dockerfile 基礎 Kubernetes 操作 Languages and Tools: Connect with me:","link":"https://minilabmemo.github.io/about/index.html"},{"title":"categories","text":"","link":"https://minilabmemo.github.io/categories/index.html"},{"title":"tags","text":"","link":"https://minilabmemo.github.io/tags/index.html"}]}