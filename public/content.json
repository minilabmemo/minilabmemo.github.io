{"posts":[{"title":"[Go 01] 配置GO開發環境","text":"什麼是Go Go（又稱Golang）是Google開發的一種靜態強型別、編譯型、並發型，並具有垃圾回收功能且輕巧的程式語言． 透過三步驟設定完開發環境： 安裝官方 Go 配置開發 Go 所需要環境變數 下載IDE「推薦Visual Studio Code加上插件」 開始寫Go Go的優點以下截自:Go適合做什麼？為何這麼多人偏愛Go語言？並簡化列了以下幾點: 學習曲線因為Go語言容易學習，普通的大學生花一個星期就能寫出來可以上手的。 高效率、簡單的併發 出身名門、血統純正出自Google公司，還能說什麼 部署方便：二進位制檔案、Copy部署。想部屬windows(exe)，或是linux可執行文件都很方便喔。 Go擁有強大的編譯檢查、嚴格的編碼規範和完整的軟體生命週期工具。 1.安裝 Gogo 網站https://golang.org/ 下載直接點擊安裝預設會幫你安裝到/usr/local/go底下，這就是GOROOT位置 開啟終端機下指令確認安裝12345➜ ~ go versiongo version go1.14 darwin/amd64➜ ~ which go /usr/local/go/bin/go 2.配置環境變數MAC安裝筆記選擇的是用在使用者目錄下配置環境變數 vi ~/.bash_profile123456789//輸入a編輯export GOROOT=&quot;/usr/local/go&quot;export GOPATH=$HOME/goexport PATH=$PATH:$GOPATH/bin export PATH=$PATH:$GOROOT/bin//GOROOT表示GO安裝的目錄//GOPATH是自訂想要放置程式的地方//打完後esc輸入：wq存擋 執行 bash profile source ~/.bash_profile 3.IDE 安裝3-1 下載 Visual Studio Code3-2 打開 VScode 於 Extensions 安裝 Go (微軟官方維護) 外掛 Go 擴充功能整合了多種 Go 工具，例如 gocode(代碼自動補全), golint(代碼規範檢查)，goreturns(格式工具Format Tool) 等，可以查看https://github.com/golang/vscode-go/blob/master/docs/tools.md(有些有不同選擇，預設工具可以在設定裡改) 如果沒有安裝對應的工具，就會在編譯.go文件時跳出提示，Analysis Tools Missing ，此時可以按下 Command + Shift + p 呼叫命令列視窗，輸入 Go: Install/Update tools 安裝/更新所有的工具解決此問題。 如遇上安裝問題，也有文章推薦可直接進行3-3步驟 3-3 打開終端機執行下列指令來安裝依賴包以下工具: 1234567891011121314151617go get -u -v github.com/ramya-rao-a/go-outlinego get -u -v github.com/acroca/go-symbolsgo get -u -v github.com/mdempsky/gocodego get -u -v github.com/rogpeppe/godefgo get -u -v golang.org/x/tools/cmd/godocgo get -u -v github.com/zmb3/gogetdocgo get -u -v golang.org/x/lint/golintgo get -u -v github.com/fatih/gomodifytagsgo get -u -v golang.org/x/tools/cmd/gorenamego get -u -v sourcegraph.com/sqs/goreturnsgo get -u -v golang.org/x/tools/cmd/goimportsgo get -u -v github.com/cweill/gotests/...go get -u -v golang.org/x/tools/cmd/gurugo get -u -v github.com/josharian/implgo get -u -v github.com/haya14busa/goplay/cmd/goplaygo get -u -v github.com/uudashr/gopkgs/cmd/gopkgsgo get -u -v github.com/davidrjenni/reftools/cmd/fillstruct 配置好後在編輯ＧＯ語言就會發現有很多貼心的提示 ，同時也會出現在ＩＤ內的problems清單裡，可以進一步修改程式語法，真的是超級方便的． 補充：以下是相關工具的說明 工具 說明 dlv.exe go 語言調適工具 gocode.exe go 語言检查，自动补全 godef.exe go 語言定义和引用的跳转 golint.exe go 語言规范检查 go-outline.exe 用于在Go源文件中提取JSON形式声明的简单工具 gopkgs.exe 快速列出可用包的工具 gorename.exe 在Go源代码中执行标识符的精确类型安全重命名 goreturns.exe 类似fmt和import的工具，使用零值填充Go返回语句以匹配func返回类 go-symbols.exe 从go源码树中提取JSON形式的包符号的工具 參考文章windows 安裝Go [Go] Go 語言於 Windows 上之安裝與環境設定 用vscode开发调试golang超简单教程 Ｍac 安裝Go Mac上Go環境和VS Code的正確安裝與配置方法 IDE : VScode [Go] 使用 Visual Studio Code 上建置 Go 開發環境","link":"/2020/05/01/01-go-env/"},{"title":"[Go 02] GO 新手上路與概念筆記","text":"藍色區塊 開始寫GO 分享自己初學GO時看的教學文章，安裝完GO環境之後，就可以撰寫自己第一支GO的程式了，網路上的系列說明很多很詳細，就不重複撰文了，以下則是自己收藏很有用的網路文章。 教你撰寫第一隻 Go Go的中文指南 (Go的中文指南，只有簡體) the-little-go-book Golang — GOROOT、GOPATH、Go-Modules-三者的關係介紹 從商業利益看 Go 程式語言 進階 go 整理教學 [筆記] Golang 進階 個人筆記整理筆記 Go 的基本类型 bool,stringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名// 表示一个 Unicode 码点float32 float64complex64 complex128https://tour.go-zh.org/basics/11 匿名欄位12345678910type User struct { Name string}type Person struct { User //匿名欄位 ID string} ss := Person{User: User{Name: &quot;123&quot;}, ID: &quot;123&quot;} fmt.Print(&quot;ss&quot;, ss.Name) 筆記 Go的參數傳遞傳值的意思是：函式傳遞的總是原來這個東西的一個副本，一副拷貝。 pass by value嚴格來說，Go只有傳植方式，會複製一個新的變數，且分配新的memory位址。pass by pointer (或稱 called by reference，但其實不是)指標方式則會複製一個新的指標，但指向的memeory位址是一樣的，但是是兩個不同的指標。 通常預期參數被修改，應傳指標。 在go裡pass by value開銷很小 迷思:Map/chan等其實是指標型別，因此會被修改，是種引用型別(reference types)[不是指call by reference]，仍是pass by value 出自以下參考文章: golang-pass-by-pointer-vs-pass-by-value there-is-no-pass-by-reference-in-go 《Golang 入門系列七》Go語言引數傳遞是傳值還是傳引用Go語言中所有的傳參都是值傳遞（傳值），都是一個副本，一個拷貝。因為拷貝的內容有時候是非引用型別（int、string、struct等這些），這樣就在函式中就無法修改原內容資料；有的是引用型別（指標、map、slice、chan等這些），這樣就可以修改原內容資料。” 筆記 理解 Go 语言中的方法和接收者 值接收者，是一个副本，方法内部無法對其真正的接收者做更改； 指针接收者，是接收者的引用，對這個引用的修改可以影響真正的接收者。 理解 Go 语言中的方法和接收者 筆記 go中的資料結構介面-interfacego中的資料結構介面-interface interface gitbook 筆記 搞定Go Mock 單元測試搞定Go單元測試（二）——mock框架(gomock)","link":"/2020/05/01/02-go-start/"},{"title":"[Go 03] 包管理與模組(Module)相關","text":"Go 包管理與模組相關 import “time” imported but not used-compiler不允許引入未使用包，vscode 儲存，工具會自動幫忙移除。1234如果要引用沒有用到的import，則要使用底線(_)import ( _ &quot;github.com/go-sql-driver/mysql&quot;) import cycle not allowed執行後會出現相依錯誤 延伸閱讀: Golang中解决”import cycle not allowed”的2种方法 Go ModuleGo 1.11 之後提供go modules 可以不需要把專案程式碼放在 $GOPATH/src 中開發，此外還能管理套件相依性。 go mod init建立一個 go.mod，裡面會記錄import版本 go get xxxxxxgo get 命令可以借助代码管理工具通过远程拉取或更新代码包及其依赖包，并自动完成编译和安装。預設會下載最新，@version 可以指定版號。常見flag使用: -d 让命令程序只执行下载动作，而不执行安装动作。 -u 让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。 -v 显示执行的命令 go mod tidy移除不需要的import go mod download可以下载所需要的依赖，或是go build也會自動將 pkg 下載到 GOPATH/pkg/mod 內 延伸閱讀: go get命令——一键获取代码、编译并安装 Go 相依圖go mod graph 可视化——gmchart延伸閱讀: https://segmentfault.com/a/1190000038897207","link":"/2021/02/13/03-go-Module/"},{"title":"[Go 04] 信號處理和退出程式","text":"一般在執行go run main.go後就會馬上回到命令列，這邊實作當接收到ctrl+c或是終止程式才會停止程式 本文說明： go實作接收命令而中止程式． 會用到channel管道來進行阻塞，並接收os/signal訊號 程式碼： 1234567891011121314151617func main() { fmt.Println(&quot;start&quot;) errs := make(chan error, 1) listenForＳignal(errs) c := &lt;-errs //阻塞程式 fmt.Println(&quot;terminating:&quot;, c)}func listenForＳignal(errChan chan error) { go func() { c := make(chan os.Signal,1) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)//要終止的訊號 errChan &lt;- fmt.Errorf(&quot;%s&quot;, &lt;-c) }()} 說明：使用”os/signal”包，用來接收訊號使用，notify方法用来監聽收到的信號（stop方法則取消） * SIGINT 表示用户按下INTR字符(Ctrl+C)觸發 * SIGTERM 结束程序 kill pid的作用是向進程為pid的程序发送SIGTERM * 其他像是SIGKILL kill -9 pid則是發送立即終止 等等就先不使用 測試接收SIGINT然後執行go run main.go後，會看到服務就一直執行著，再按下ctrl+c 123&gt; go run main.gostart^Cterminating: interrupt 測試接收SIGTERM先將main.go編譯成執行檔 -o代表放在目前目錄下 取名為demo“./“執行demo這檔案 123go build -o ./demo main.go ./demo start 接下來開另一視窗 找出進程跟demo有關的pid 然後執行kill pid，確認已停止了 1234➜ ~ ps -A | grep demo 14693 ttys000 0:00.00 ./demo➜ ~ kill 14693➜ ~ ps -A | grep demo 回到程式執行視窗就會看到以下被中止的訊息了 123 ./demostartterminating: terminated 後記疑問： 不太知道到底要怎麼要在vscode debug模式去模擬ctrl+c時會跑到的地方來看程式，google未有結果，無解 在linux環境有效，win環境搜尋無解","link":"/2020/05/01/03-go-signal/"},{"title":"[Go 05] 使用 Gin 框架快速建立 http 服務","text":"如何用 Gin 框架快速建立 HTTP [ GET/POST 等方法] 效果用 Postman 工具打看看就可以得到下面結果 SEND [method url ] RESPONSE [status body ] GET http://localhost:8080/api/v1/user 200 , OK GET http://localhost:8080/api/v1/user/May 200 ,”Hello,May” POST http://localhost:8080/api/v1/user {“name”: “user1”,”age”: 33} 200 , {“name”: “user1”,”age”: 33} 程式碼1234567891011121314151617181920212223242526272829303132333435363738394041// 1.啟動服務func StartHttpServer(errChan chan error) { gin.SetMode(gin.ReleaseMode) engine := gin.New() initRoutes(engine) go func() { errChan &lt;- engine.Run(:8080) }()}// 2.設定路由組func initRoutes(e *gin.Engine) { root := e.Group(&quot;api/v1&quot;) userGroup := root.Group(&quot;user&quot;) { userGroup.GET(&quot;&quot;, apis.User) userGroup.GET(&quot;:name&quot;, apis.UserName) userGroup.POST(&quot;&quot;, apis.PostName) }}// 3. 設定回覆func User(c *gin.Context) { c.JSON(http.StatusOK, &quot;OK&quot;) //回覆status 200 &amp; body &quot;OK&quot;}//接受path參數 name := c.Param(&quot;name&quot;) c.JSON(http.StatusOK, fmt.Sprintf(&quot;%s,%s&quot;, &quot;Hello&quot;, name))}//接收 json 內容func PostName(c *gin.Context) { sc := &amp;structs.User{} if err := c.ShouldBindJSON(sc); err != nil { return } c.JSON(http.StatusOK, sc)}type User struct { Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;`} Gin 延伸 寫中間件 [控制每個 Url timeout/log 等等行為] 套 swagger [下一篇] gin.Context 還有 c.Header, c.Query, c.GetRawData() 等等使用方法，取參數非常方便 第一次去套用 Gin 真的覺得很神奇，本章純快速記錄效果，","link":"/2020/05/08/04-go-gin-http/"},{"title":"[Go 06] 寫測試並產出一目瞭然的網頁版覆蓋率報告 再也不用怕遺漏","text":"本章介紹： 為上一篇 Gin 框架的 User &amp; PostName func.寫個簡單測試 跑測試並瞭解 coverage 覆蓋率，產生測試報告(20210702 有新增 vsocde 用法補充) 說明：新建一個檔案ＸＸ_test.go，並為 func 取名 Test ＸＸＸ(t *testing.T) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//測試打GET /api/v1/user 去跑User() 會拿到“ＯＫ”func TestUser(t *testing.T) { engine := gin.New() initRoutes(engine)//你的路由邏輯 uri := &quot;/api/v1/user&quot; body := Get(uri, engine) fmt.Printf(&quot;response:%v\\n&quot;, string(body)) if !reflect.DeepEqual(string(body), &quot;\\&quot;OK\\&quot;&quot;) { //利用 t.Errorf 觸發錯誤 t.Errorf(&quot;Get user name need to be ok!&quot;) }}//同理測試 Post 去跑PostName() 會拿到回復的名字等於打的內容（body）func TestPostName(t *testing.T) { engine := gin.New() initRoutes(engine) uri := &quot;/api/v1/user&quot; user := structs.User{Name: &quot;user&quot;, Age: 18} body := PostUser(uri, user, engine) fmt.Printf(&quot;response:%v\\n&quot;, string(body)) response := &amp;structs.User{} if err := json.Unmarshal(body, response); err != nil { t.Errorf(&quot;Unmarshal，err:%v\\n&quot;, err) } if response.Name != &quot;user&quot; { t.Errorf(&quot;response different，user:%v\\n&quot;, response.Name) }}// GET HTTP Requestfunc Get(uri string, router *gin.Engine) []byte { req := httptest.NewRequest(&quot;GET&quot;, uri, nil) w := httptest.NewRecorder() router.ServeHTTP(w, req) result := w.Result() defer result.Body.Close() body, _ := ioutil.ReadAll(result.Body) return body}// POST HTTP Requestfunc PostUser(uri string, param structs.User, router *gin.Engine) []byte { jsonByte, _ := json.Marshal(param) req := httptest.NewRequest(&quot;POST&quot;, uri, bytes.NewReader(jsonByte)) w := httptest.NewRecorder() router.ServeHTTP(w, req) result := w.Result() defer result.Body.Close() body, _ := ioutil.ReadAll(result.Body) return body} 測試單一個 function如果用 VS code，可以在上方看到 run test | debug test 按鈕可以按，十分方便 測試單一檔案內所有測試cover 有帶的話會算出覆蓋率，並要在該目錄下去執行，這邊跑出來結果大約有 57.1% 的覆蓋 1234$go test -v -cover=true user_test.go user.goPASScoverage: 57.1% of statementsok command-line-arguments 0.297s coverage: 57.1% of statements 測試整個專案12如果是在main的目錄要往子目錄找＄go test -v ./… 產生測試覆蓋(coverage)報表-gotest1234go test -coverprofile=coverage.out ./...用gool toolgo tool cover -func=coverage.outgo tool cover -html=coverage.out 這個真的很酷，用網頁產生報告，而且非常視覺化，可以看出剛剛沒有寫到的 UserName()測試為紅色 20210702 補充 :其實後來發現 vscode 在跑完 package test 後，右邊側欄就會跑出覆蓋的條線了如果只是要在測試時查看可以直接用ＩＤＥ的便利性即可． 當然寫測試還有很多判斷的條件等等，是否等於，是否不等於，各種輸出可能． 寫完之後，可以為下一次更動後確認邏輯，看跑過測試真的很有療癒的感覺！！！:grin: 覺得有疑問嗎？可以再進一步看看參考文章： 基于 golang gin 框架的单元测试 go test 提示 no test files Go: tests with HTML coverage report 使用 Go 进行单元测试","link":"/2020/05/08/05-go-test-coverage/"},{"title":"[Go 07] 使用 zap 框架印出 log","text":"本章內容： 實作使用高性能 zap log 框架 擁有 log level 配置 (常用 debug/warn/info/error)與程式碼位置 可以選擇印出在 console 或是文件（要外掛 lumberjack 去分割） zap 有 suger 函式可以增加易用性，但犧牲效能 雖然目前還未有高性能之需求，網路上也有很多不同的ＬＯＧ框架可以選擇，有興趣可以看這篇在 Github 中 stars 数最多的 Go 日志库集合，看了各框架說明介紹，這個框架實作上看來蠻容易的，今天就還試試看． 直接上實作完之程式碼 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package loggerimport ( &quot;mywork/demo/internal/config&quot; &quot;os&quot; &quot;strings&quot; &quot;time&quot; &quot;go.uber.org/zap&quot; &quot;go.uber.org/zap/zapcore&quot; &quot;gopkg.in/natefinch/lumberjack.v2&quot;)var ZapLogger *zap.Loggervar SugarLogger *zap.SugaredLoggerfunc InitLogger() { logWriter := []zapcore.WriteSyncer{zapcore.AddSync(os.Stdout)} if config.Configuration.Logger.File != &quot;&quot; { hook := setFileWriter(config.Configuration.Logger.File) logWriter = append(logWriter, hook) } encoderConfig := setEncoder() level := getLogLevel(config.Configuration.Logger.Level) core := zapcore.NewCore(encoderConfig, zapcore.NewMultiWriteSyncer(logWriter...), level) ZapLogger = zap.New(core, zap.AddCaller()) //印出log的位置 // ZapLogger.Debug(&quot;POK&quot;) // ZapLogger sample ZapLogger.Info(&quot;ZapLogger&quot;, zap.String(&quot;String&quot;, &quot;ohoh&quot;), zap.Int(&quot;Int&quot;, 3), zap.Duration(&quot;backoff&quot;, time.Second), ) SugarLogger = ZapLogger.Sugar() //SugarLogger.Infof(&quot;Success! statusCode = %s for URL %s&quot;, &quot;OK&quot;, &quot;OK&quot;) // SugarLogger sample}func setEncoder() zapcore.Encoder { encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder return zapcore.NewConsoleEncoder(encoderConfig)}func setFileWriter(filePath string) zapcore.WriteSyncer { lumberJackLogger := &amp;lumberjack.Logger{ Filename: filePath, MaxSize: 1, MaxBackups: 5, MaxAge: 30, Compress: false, } return zapcore.AddSync(lumberJackLogger)}func getLogLevel(lv string) zapcore.Level { lv = strings.ToLower(lv) if level, ok := levelMap[lv]; ok { return level } return zapcore.InfoLevel}var levelMap = map[string]zapcore.Level{ &quot;debug&quot;: zapcore.DebugLevel, &quot;info&quot;: zapcore.InfoLevel, &quot;warn&quot;: zapcore.WarnLevel, &quot;error&quot;: zapcore.ErrorLevel,} LOG 輸出範例 zap.Logger 輸出需針對 Type 去輸入，使用跟印出看起來都比較麻煩一點 zap.SugaredLogger 就像是語法糖 122021-01-31T11:46:00.954+0800 INFO log/log.go:27 ZapLogger {&quot;String&quot;: &quot;ohoh&quot;, &quot;Int&quot;: 3, &quot;backoff&quot;: 1}2021-01-31T11:46:01.012+0800 INFO http_server/httpserver.go:35 Listening on port: 56888","link":"/2020/05/18/06-go-zap-log/"},{"title":"[Go 08] 認識時間格式與golang的時區轉換寫法","text":"開發過程中，曾遇過部署到別的平台，時間就變成+0 時區了（例如明明下午五點，部署平台顯示早上九點），這時才發現原來你的時間不是他的時間，而資料庫中也常常用時間戳數字來做紀錄，但顯示給使用者時又要轉成格式化顯示，本篇紀錄各種時間格式的理解與 go 程式對於時間的使用 理解時間的各種顯示格式時間可以以很多格式化的方式做顯示。例如最常看到的 2021-04-22 17:27:44 標準時間格式國際標準格式，像是 ISO_8601 合併表示時，要在時間前面加一大寫字母 T 如果時間在零時區，並恰好與協調世界時相同，那麼（不加空格）在時間最後加一個大寫字母 Z例如以下這樣的顯示方式: 122021-04-28T01:51:35Z2004-05-03T17:30:08+08:00 //+08:00代表比世界協調時間快8小時的時區 UNIX 時間與時間戳UNIX 時間代表從 UTC1970 年 1 月 1 日 0 時 0 分 0 秒起至現在的總秒數 而 UTC 為世界協調時間（英語：Coordinated Universal Time，法語：Temps Universel Coordonné，簡稱 UTC）是最主要的世界時間標準。 這種你會看到可能是十位數的數字(s:1621999487)或是十三位數的數字(ms:1621999487377)，可以透過線上時間戳轉換器得出代表的時間。 時區的轉換世界各國位於地球不同位置上，，不同地區的人會有不同的地方時間，可以看時區轉換器 golang 時間轉換接著說明使用 golang 實現以上幾種常見的轉換，而 2006-01-02 15:04:05-0700 是一串 go 獨特神奇的對應順序。可以看time/format.go 大致列出四種轉換: 將時間戳轉換為時間 將時間做格式化輸出，golang 語法的時間輸出跟 java 比較不一樣。2006-01-02 15:04:05-0700 對應到 yyyy-MM-dd HH:mm:ss Z，請見golang 與 java time 的對照表， 記憶順序有點像是06代表年，後面則是1,2,3,4,5,7 時區轉換: FixedZone(name,位移的秒數)，可以自訂時區命名信息，loc := time.FixedZone(“UTC-8”, -8 _ 60 _ 60)第二個參數轉移多少秒，可以改+8 時區等等 時區轉換: LoadLocation(name)，可以輸入空值，”UTC”，”Local”，或是時區的資料庫 EX: “Asia/Taipei”，命名使用的資料庫為IANA Time Zone database，好處是不用自己輸入到底是＋ 8 還加多久，知道時區命名就好，但是背後的定義還是會依下列順序去找尋對應資料： ZONEINFO 環境變數所指定的 zip 文件 Unix 系统中已经安装的 $GOROOT/lib/time/zoneinfo.zip， 因此如果在 windows 系统上，没有安装 go 語言環境，time.LoadLocation 會失敗，建議用 time.FixedZone。 另外在 docker 環境裡也要注意使用的 image 是否已經有包含這些資料，否則會出現 unknown time zone XXXX 的錯誤，解決方法需要加入以下設定 1234567FROM alpine...COPY --from=0 /usr/local/go/lib/time/zoneinfo.zip /opt/zoneinfo.zipENV ZONEINFO /opt/zoneinfo.zipORRUN apk --no-cache add tzdata... 四種轉換時間格式範例程式: diff1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { var Time int64 Time = 1619083664867 //ms-&gt;2021-04-22 17:27:44 t := time.Unix(0, Time*int64(time.Millisecond)) fmt.Println(&quot;case1: timestamp to time:&quot;, t) layout1 := &quot;2006-01-02T15:04:05&quot; fmt.Println(&quot;case2: Formatlayout1:&quot;, t.Format(layout1)) zone := time.FixedZone(&quot;&quot;, +0*60*60) newTimezone0 := t.In(zone) fmt.Println(&quot;case3: Timezone at +0:&quot;, newTimezone0.Format(layout1)) // name := &quot;America/New_York&quot; name := &quot;Asia/Taipei&quot; t, err := TimeIn(t, name) if err != nil { fmt.Println(&quot;err:&quot;, err) } fmt.Println(&quot;case4: Timezone at Taipei:&quot;, t.Format(layout1))}func TimeIn(t time.Time, name string) (time.Time, error) { loc, err := time.LoadLocation(name) if err == nil { t = t.In(loc) } return t, err} 轉換結果： 12345timestamp: 1619083664867case1: timestamp to time: 2021-04-22 09:27:44.867 +0000 UTCcase2: Formatlayout1: 2021-04-22T09:27:44case3: Timezone at +0: 2021-04-22T09:27:44case4: Timezone at Taipei: 2021-04-22T17:27:44 網路參考文章 数据库存时间戳的好处 time-unix examples 1milli-&gt;1000000 nano sec Golang 時區 golang-timezone 到底是 GMT+8 還是 UTC+8 ? golang-TimeIn example Golang 神奇的 2006-01-02 15:04:05 Go 语言标准包解析 Location Golang 时区设置 解决容器运行 Go 代码 unknown time zone 的正确姿势","link":"/2021/05/30/07-go-time/"},{"title":"[Go] 性能&#x2F;品質檢測","text":"當開發golang程式完成後，其實有一些工具可以查看自己的程式效能，是否有些地方佔了太大的資訊進而改進，另外也可以 透過品質檢測工具去看修改建議；最後，如果有撰寫測試案例的話，也有工具可以產生測試報告，確認測試案例涵蓋了程式多少百分比，還有沒被寫到的地方也可以透過報告顯示出來． 本章介紹: 性能分析工具-pprof 查看CPU/memory 等的瓶頸 檢視go的品質與建議-gosec 性能分析工具-pprof先在程式碼插入以下程式後執行。 123456import _ &quot;net/http/pprof&quot;func main() { go func() { http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil) }()} 開啟http://localhost:8080/debug/pprof/可以看到一個簡單的分析數字 go tool 看記憶體(heap)透過以下指令可以看到佔記憶體的前幾名 1234567891011$go tool pprof http://127.0.0.1:8080/debug/pprof/heap&lt;br&gt;-&gt; 輸入top&lt;br&gt;-&gt; 輸入web可以看到圖形&lt;br&gt;(pprof) top&lt;br&gt;Showing nodes accounting for 1.50MB, 100% of 1.50MB total flat flat% sum% cum cum%&lt;br&gt; 1.50MB 100% 100% 1.50MB 100% golang.org/x/net/webdav.(*memFile).Write&lt;br&gt; 0 0% 100% 1.50MB 100% github.com/swaggo/files.init.8&lt;br&gt; go tool 看CPU(profile)而以下幾令則是幾秒內的ＣＰＵ計算 1go tool pprof http://localhost:6060/debug/pprof/profile?seconds=60&lt;br&gt; 網頁版查看 圖表以上兩種指令其實可以透過以下指令可以開啟一個網頁更容易看到資料的圖表呈現 1234go tool pprof -http=&quot;:9099&quot; -seconds=30 http://localhost:8080/debug/pprof/profilego tool pprof -http=&quot;:9099&quot; http://localhost:8088/debug/pprof/heapgo tool pprof -http=&quot;:9099&quot; http://localhost:8088/debug/pprof/goroutine 參考文章: golang pprof 使用多年的go pprof检查内存泄漏的方法居然是错的?! 檢視go的品質與建議1.先下載 go setgo get github.com/securego/gosec/cmd/gosec@v2.2.0 2.輸出報告(可選格式) 123gosec -fmt=json -out=results.json ./...&lt;br&gt;gosec -fmt=html -out=results.html ./...&lt;br&gt; 注意是*三個點 然後打開ＨＴＭＬ檔案就可以看到程式品質分析報告了 像是以上這條處理檔案位置時，path應該清理處理過以避免輸入異常 延伸文章 來源 摘要 新手问题 golang内存检测工具 生产环境中使用 pprof 时会遇到一些问题 go pprof与线上事故：一次成功的定位与失败的复现 很多小伙伴担心线上使用pprof会影响性能，担心安全问题。这个在我看来利大于弊，当服务出现问题的时候，资源占用多一点点与能够解决问题相比微不足道，当服务没有问题的时候使用pprof那更没有问题了~ Golang 語言的單元測試和性能測試(也叫 壓力測試) （高級測試技術） https://etcnotes.com/posts/pprof/ 生成圖","link":"/2020/09/18/13-go-pprof-gosec/"},{"title":"[純紀錄]Kubernetes基本操作","text":"學習 Kubernetes 與基本操作紀錄 Kubernetes 文章 学习 Kubernetes 基础知识官方 [Day 6] 實際環境運行的 Kubernetes - Node &amp; Architecture Overview概觀 Kubernetes 的內部運作 Kubernetes 元件介紹與 minikube 安裝教學pod/Service/Deployment介紹 适用于 Docker 用户的 kubectl提供docker與kubectl指令對應參考 [Day 5] 在 Minikube 上跑起你的 Docker Containers - Pod &amp; kubectl 常用指令pod與yaml說明與如何與 Pod 中的 container 互動 Day 4 - 部署應用程式到 Kubernetes 叢集 - Part I - 手動建立 deployment 與 Service建立deployment 與 Service/nodePort從本地開啟 Kubernetes &amp; OpenShift Java Client Kubernetes —學習好幫手minikube — 01將K8s所需的Master/Worker node封裝在一個虛擬機器中https://medium.com/@sniperbean/kubernetes-%E5%AD%B8%E7%BF%92%E5%A5%BD%E5%B9%AB%E6%89%8Bminikube-01-aedfaf8b00fe kubectl的簡單查看，新增，重開kubectl的簡單查看，新增，重開 kubectl get pod -A kubectl create 建立 後面可以直接加參數或是用yaml來建立 簡單建立deployment啟動 minikube 之後，我們可以透過 kubectl run 在 minikube 上運行一個 Google 提供的 hello-minikube docker image， 12345$ kubectl create deployment first-deployment --image=katacoda/docker-http-serverdeployment.apps/first-deployment created$ kubectl get podsNAME READY STATUS RESTARTS AGEfirst-deployment-8cbf74484-xgc4l 1/1 Running 0 25s 建立namespaces 12345678910&gt;kubectl get namespacesNAME STATUS AGEdefault Active 7m52skube-node-lease Active 7m53skube-public Active 7m53skube-system Active 7m53s //Create a new NamespacesD:\\k8syaml&gt;kubectl create namespace mynamespace/my created 建立deploymenthttps://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/D:\\k8syaml&gt;kubectl create -f my-first-pod.yaml 編輯要部屬的程式deployment.apps/my-pod created 查看所有podD:\\k8syaml&gt;kubectl get pod -A 看LOGkubectl -n NsName logs my-pod-5b788d95bc-kx76k 刪除D:\\k8syaml&gt;kubectl delete deployment my-pod -n NsName 先刪除deployment.apps “my-pod” deleted 重開D:\\k8syaml&gt;kubectl -n NsName rollout restart deployment nginx179 執行重開指令deployment.apps/nginx179 restarted 編輯一樣可以達到重開效果kubectl edit deployment -n NsName nginx179kubectl get pod -ANAMESPACE NAME READY STATUS RESTARTS AGENsName nginx179-5ddfbfccb8-76qz8 1/1 Running 0 84s//啟動成功 minikubeKubernetes —學習好幫手minikube — 01將K8s所需的Master/Worker node封裝在一個虛擬機器中https://medium.com/@sniperbean/kubernetes-%E5%AD%B8%E7%BF%92%E5%A5%BD%E5%B9%AB%E6%89%8Bminikube-01-aedfaf8b00fe1.install kubuctl你可以使用 Kubectl 命令行工具管理 Kubernetes 集群。 kubectl 在 $HOME/.kube 目录中查找一个名为 config 的配置文件。 2.Minikube Minikube 是由 Google 發布的一個輕量級工具。讓開發者可以在本機上輕易架設一個 Kubernetes Cluster，快速上手 Kubernetes 的指令與環境。Minikube 會在本機上跑起一個 virtual machine，並且在這 VM 裡建立一個 signle-node Kubernetes Cluster，本身並不支援 HA (High availability)，也不推薦在實際應用上運行。 安裝:https://minikube.sigs.k8s.io/docs/start/ *開啟docker的k8s設定docker desktop -&gt;settings-&gt; 12345678910111213&gt;kubectl get nodesNo resources found- 啟動minikube start&gt;minikube start* minikube v1.16.0 on Microsoft Windows 10 Enterprise 10.0.17763 Build 17763* Using the docker driver based on existing profile* Starting control plane node minikube in cluster minikube* Restarting existing docker container for &quot;minikube&quot; ...* Preparing Kubernetes v1.20.0 on Docker 20.10.0 ...* Verifying Kubernetes components...* Enabled addons: storage-provisioner, default-storageclass* Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default 確認kubectl version 123&gt;kubectl versionClient Version: version.Info{Major:&quot;1&quot;, Minor:&quot;19&quot;, GitVersion:&quot;v1.19.3&quot;, GitCommit:&quot;1e11e4a2108024935ecfcb2912226cedeafd99df&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2020-10-14T12:50:19Z&quot;, GoVersion:&quot;go1.15.2&quot;, Compiler:&quot;gc&quot;, Platform:&quot;windows/amd64&quot;}Server Version: version.Info{Major:&quot;1&quot;, Minor:&quot;20&quot;, GitVersion:&quot;v1.20.0&quot;, GitCommit:&quot;af46c47ce925f4c4ad5cc8d1fca46c7b77d13b38&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2020-12-08T17:51:19Z&quot;, GoVersion:&quot;go1.15.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;} server version需要minikube有安裝才會出現 1234567&gt;kubectl get nodesNAME STATUS ROLES AGE VERSIONminikube Ready control-plane,master 3d v1.20.0PS C:\\&gt; minikube dashboardOpening kubernetes dashboard in default browser... 啟動 minikube 之後，我們可以透過 kubectl run 在 minikube 上運行一個 Google 提供的 hello-minikube docker image， 12345$ kubectl create deployment first-deployment --image=katacoda/docker-http-serverdeployment.apps/first-deployment created$ kubectl get podsNAME READY STATUS RESTARTS AGEfirst-deployment-8cbf74484-xgc4l 1/1 Running 0 25s 在 minikube 上透過 kubectl get 來自 https://ithelp.ithome.com.tw/articles/10197186 12345678910D:\\k8syaml&gt;kubectl get namespacesNAME STATUS AGEdefault Active 7m52skube-node-lease Active 7m53skube-public Active 7m53skube-system Active 7m53sCreate a new NamespacesD:\\k8syaml&gt;kubectl create namespace NsNamenamespace/NsName created 建立deployment 123456https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/D:\\k8syaml&gt;kubectl create -f my-first-pod.yaml 編輯要部屬的程式deployment.apps/my-pod createdD:\\k8syaml&gt;kubectl get podsNo resources found in default namespace. D:\\k8syaml&gt;kubectl get pod -A 123456789NAMESPACE NAME READY STATUS RESTARTS AGENsName my-pod-5b788d95bc-kx76k 0/1 Error 0 46s 建立不成功因為有相依kube-system coredns-74ff55c5b-wf484 1/1 Running 0 10mkube-system etcd-minikube 1/1 Running 0 10mkube-system kube-apiserver-minikube 1/1 Running 0 10mkube-system kube-controller-manager-minikube 1/1 Running 0 10mkube-system kube-proxy-skl6r 1/1 Running 0 10mkube-system kube-scheduler-minikube 1/1 Running 0 10mkube-system storage-provisioner 1/1 Running 0 10m 看LOGkubectl -n NsName logs my-pod-5b788d95bc-kx76k D:\\k8syaml&gt;kubectl delete deployment my-pod -n NS名稱 先刪除deployment.apps “my-pod” deleted 12345678910111213141516171819202122232425262728293031323334D:\\k8syaml&gt;kubectl get pod -ANAMESPACE NAME READY STATUS RESTARTS AGExx my-pod-5b788d95bc-kx76k 0/1 Terminating 5 6m20skube-system coredns-74ff55c5b-wf484 1/1 Running 0 16mkube-system etcd-minikube 1/1 Running 0 16mkube-system kube-apiserver-minikube 1/1 Running 0 16mkube-system kube-controller-manager-minikube 1/1 Running 0 16mkube-system kube-proxy-skl6r 1/1 Running 0 16mkube-system kube-scheduler-minikube 1/1 Running 0 16mkube-system storage-provisioner 1/1 Running 0 16mD:\\k8syaml&gt;kubectl get pod -ANAMESPACE NAME READY STATUS RESTARTS AGEkube-system coredns-74ff55c5b-wf484 1/1 Running 0 16mkube-system etcd-minikube 1/1 Running 0 16mkube-system kube-apiserver-minikube 1/1 Running 0 16mkube-system kube-controller-manager-minikube 1/1 Running 0 16mkube-system kube-proxy-skl6r 1/1 Running 0 16mkube-system kube-scheduler-minikube 1/1 Running 0 16mkube-system storage-provisioner 1/1 Running 0 16mD:\\k8syaml&gt;kubectl create -f my-first-nginx179.yaml //重新建立一個deployment.apps/nginx179 createdD:\\k8syaml&gt;kubectl get pod -ANAMESPACE NAME READY STATUS RESTARTS AGENsName nginx179-75c6f6f5b8-bwzgm 1/1 Running 0 98s //啟動成功kube-system coredns-74ff55c5b-wf484 1/1 Running 0 20mkube-system etcd-minikube 1/1 Running 0 20mkube-system kube-apiserver-minikube 1/1 Running 0 20mkube-system kube-controller-manager-minikube 1/1 Running 0 20mkube-system kube-proxy-skl6r 1/1 Running 0 20mkube-system kube-scheduler-minikube 1/1 Running 0 20mkube-system storage-provisioner 1/1 Running 0 20m 12345678D:\\k8syaml&gt;kubectl -n NsName rollout restart deployment nginx179 執行重開指令deployment.apps/nginx179 restarted 編輯一樣可以達到重開效果kubectl edit deployment -n NsName nginx179kubectl get pod -ANAMESPACE NAME READY STATUS RESTARTS AGENsName nginx179-5ddfbfccb8-76qz8 1/1 Running 0 84s//啟動成功 建立statefulhttps://kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/ 1234567891011121314151617181920D:\\k8syaml&gt;kubectl apply -f my-web.yamlservice/nginx createdstatefulset.apps/web createdD:\\k8syaml&gt;kubectl get pods -ANAMESPACE NAME READY STATUS RESTARTS AGEdefault web-0 1/1 Running 0 39sdefault web-1 1/1 Running 0 27sD:\\k8syaml&gt;kubectl delete pod -l app=nginxpod &quot;web-0&quot; deletedpod &quot;web-1&quot; deletedD:\\k8syaml&gt;kubectl apply -f my-web.yamlservice/nginx unchangedstatefulset.apps/web createdD:\\k8syaml&gt;kubectl edit statefulset -n NsName my-webEdit cancelled, no changes made.","link":"/2020/12/31/Kubernetes/"},{"title":"[cloud]紀錄雲端儲存服務MinIO與Amazon S3開發筆記","text":"簡單紀錄雲端儲存服務MinIO與Amazon S3與使用GO SDK開發筆記” Amazon Web Services (AWS) S3*Amazon Web Services (AWS) S3，全名為亞馬遜簡易儲存服務，是亞馬遜公司利用其亞馬遜網路服務系統所提供的網路線上儲存服務。(目前可申請免費12個月)，沒有限制，就是用多少付多少錢，可以設定 Billing alert． 如果你有申請AWS帳號，可以用AWS SDK操作上傳到AWS S3，s3沒有免費開發模擬器，只能註冊使用，但有其他可替代的兼容服務。剛開始開發時因為沒有申請帳號，所以使用minIO替代． minIO MinIO是與Amazon S3兼容的服務器端存儲協議，可以處理最大對像大小為5TB的非結構化數據，例如照片，視頻，日誌文件，備份和容器映像，並附帶web ui介面。官方文檔:https://docs.min.io/cn/ minIO server1.自行建立安裝minIO server各種安裝方式:https://docs.min.io/cn/minio-quickstart-guide.html Windows系统 執行檔安裝https://dl.min.io/server/minio/release/windows-amd64/minio.exe 1234執行minio.exe server D:\\Photos預設開啟9000RootUser: minioadminRootPass: minioadmin Windows docker 1docker run -p 9000:9000 --name minio1 -v D:\\data:/data -e &quot;MINIO_ROOT_USER=AKIAIOSFODNN7EXAMPLE&quot; -e &quot;MINIO_ROOT_PASSWORD=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY&quot; minio/minio server /data 1.接著開啟:http://127.0.0.1:9000/，輸入上面的資訊就可以登入，2.新增一個bucket，3.然後上傳檔案成功，4.上傳的檔案就會出現在 D:\\data裡。 但簡單建立的版本並沒有Https，設定上教學裡的win載點已不在..，有興趣可以看這篇安裝:使用TLS安全的访问Minio服务 *HTTPS經由HTTP進行通訊，但利用SSL/TLS來加密封包 2.使用官方提供建立好的minIO server123https://play.min.io Play uses access_key_id Q3AM3UQ867SPQQA43P2F, secret_access_key zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG.GUI操作:https://play.min.io/ minIO clientmcMinIO Client (mc)为ls，cat，cp，mirror，diff，find等UNIX命令提供了一种替代方案。它支持文件系统和兼容Amazon S3的云存储服务（AWS Signature v2和v4）。 有興趣可以至MinIO客户端快速入门指南 minIO SDK自行寫程式撰寫，範例:Golang-minIO 首先使用minio-go 1go get -u github.com/minio/minio-go 加入範例自行替換以下endpoint/accessKeyID/secretAccessKey/useSSL資訊 這個範例是使用minIO的SDK的範例golang-client-quickstart-guide12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( &quot;context&quot; &quot;log&quot; minio &quot;github.com/minio/minio-go/v7&quot; &quot;github.com/minio/minio-go/v7/pkg/credentials&quot;)//1.先要建立minIO serverfunc main() { // endpoint := &quot;play.min.io&quot; // accessKeyID := &quot;Q3AM3UQ867SPQQA43P2F&quot; // secretAccessKey := &quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot; //useSSL := true endpoint := &quot;127.0.0.1:9000&quot; accessKeyID := &quot;AKIAIOSFODNN7EXAMPLE&quot; secretAccessKey := &quot;wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY&quot; useSSL := false //error http: server gave HTTP response to HTTPS client // 初使化 minio client对象。 minioClient, err := minio.New(endpoint, &amp;minio.Options{ Creds: credentials.NewStaticV4(accessKeyID, secretAccessKey, &quot;&quot;), Secure: useSSL, }) if err != nil { log.Printf(&quot;err\\n&quot;) log.Fatalln(err) } log.Printf(&quot;ok\\n&quot;) // minioClient初使化成功 // 创建一个叫mymusic的存储桶。 bucketName := &quot;test11&quot; location := &quot;us-east-1&quot; ctx := context.Background() err = minioClient.MakeBucket(ctx, bucketName, minio.MakeBucketOptions{Region: location}) if err != nil { // 检查存储桶是否已经存在。 exists, errBucketExists := minioClient.BucketExists(ctx, bucketName) if errBucketExists == nil &amp;&amp; exists { log.Printf(&quot;We already own %s\\n&quot;, bucketName) } else { log.Printf(&quot;err\\n&quot;) log.Fatalln(err) } } else { log.Printf(&quot;Successfully created %s\\n&quot;, bucketName) } // 上传一个zip文件。 objectName := &quot;ssss.zip&quot; filePath := &quot;./ssss.zip&quot; contentType := &quot;application/zip&quot; // 使用FPutObject上传一个zip文件。 n, err := minioClient.FPutObject(ctx, bucketName, objectName, filePath, minio.PutObjectOptions{ContentType: contentType}) if err != nil { log.Fatalln(err) } log.Printf(&quot;Successfully uploaded %s of size %d\\n&quot;, objectName, n)} AWS SDK如果你有用AWS S3的SDK，一樣可以使用它撰寫程式連結到minIO的server，MinIO官方範例:How to use AWS SDK for Go with MinIO Server，不過該AWS ADK已經有V2了，如果用V2版需要再改一下自行定義資訊的寫法Overriding Endpoint with Fallback，或是讀取AWS config的本地Credentials資訊。 產生Credentials組態與登入資料檔案設定 Windows 中是使用環境變數 %UserProfile% (通常是c:/users/xxx)來參考，而在 Unix 系統中是使用 $HOME 或 ~ (波狀符號) 來參考 可以下載AWS CLI 來幫你產生這些檔案 minIO server的產生方式可以看這篇AWS CLI with MinIO Server 測試用aws CLI列出buckets 12345678910111213&gt;aws configureAWS Access Key ID [****************MPLE]: Q3AM3UQ867SPQQA43P2FAWS Secret Access Key [****************EKEY]: zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TGDefault region name [us-east-1]:Default output format [None]:&gt;aws configure set default.s3.signature_version s3v4&gt;aws --endpoint-url https://play.min.io s3 ls2021-04-06 00:05:40 00dst12021-04-06 00:05:53 00dst2(略) 網路參考文章 amazon-s3開發是否有免費帳號","link":"/2021/04/28/aws-s3/"},{"title":"[Blog]使用 gitbbook 建立我的 golang 線上學習筆記","text":"GitBook 幫助你創建一個方便瀏覽撰寫好用的文件協作分享． 最近嘗試用 gitbook 來記錄學習的線上備忘錄，發現還蠻好用的！所以建了一個golang memo的gitbook專區～把自己所學都整理往裡面放． 優點 線上編輯即所見 有側邊欄與文章目錄，可以拖拉更改配置． 編輯區塊方便 表格/程式碼/heading… 等等，適合不習慣用純 markdown 語法編輯的人． 可以與github sync 做備份 發布就有網址，可以分享給別人． 開始吧～ 上gitbook官網，註冊帳號 開始新增文章，於線上編輯 點擊發布！！就可以拿到網址了 使用gitbook一切就是這麼簡單！！！ 發布網址點這裡看我的 -&gt; golang 學習備忘錄 心得","link":"/2022/09/09/blog-gitbook/"},{"title":"[Blog] 五分鐘教你使用 docusaurus 建立筆記部落格","text":"雖然說現在用的hexo技術建立的部落格就是為了寫筆記，但有時候只是為了真的純快速紀錄，之後待查或待看，但要整理成新的文章往往要一段時間，且很多不同的速記比較很難一下找出來，這時看到有另一種風格的部落格蠻適合當這樣的記錄的，適合作文檔的站點． 1.Docusaurus will help you ship a beautiful documentation site in no time.2.是由Faecbook團隊開源專案，提供的一款易於維護的靜態網站建立工具，且可以使用react技術編輯．（MIT License） 個人選擇的優點： 左側有可以開闔的側欄，且進入文章後不會不見，可以快速瀏覽． 單純作為文檔保存筆記而建立 玩玩Docusaurus ！！ （第一點雖然hexo我有試圖找過有沒有不同主題可以符合這樣的需求，但搜尋上有點困難，就當作為了切開風格而另架一種風格的網站，而且也很快速．） 建立Docusaurus馬上就進入官網 看 get started 說明流程只要三個指令： 123npx @docusaurus/init@latest init my-website classiccd my-websitenpx docusaurus start Ex 我的配置流程，我用的命名為note-blog(你可以使用自訂的命名)： 12345678910111213141516171819202122blog npx @docusaurus/init@latest init note-blog classicnpx: 40 安裝成功，花費 6.139 秒Creating new Docusaurus project ...Success! Created note-blogInside that directory, you can run several commands: npm start Starts the development server. npm run build Bundles the app into static files for production. npm deploy Publish website to GitHub pages.We suggest that you begin by typing: cd note-blog npm start 這邊最後一步啟動介紹寫的有點不同，但是都可以啟動 一些基本的畫面就出來了☼☼☼http://localhost:3000/note-blog/ 接著我先不改內容，先部署到網路上拿到正式網址． 上傳到github這邊我用的方式是用gh-pages工具的做法，跟官網deployment介紹的有點不同，（個人覺得官網寫的覺得有點難懂，但流程可能比較正式，有興趣的人可以試著做做看） 個人使用gh-pages工具流程記錄如下． 先到githu\bb新增專案名為“”note-blog 先把剛剛的專案上傳到GIT 基本上照gutbuh建立完的提示輸入就好12git remote add origin XXXgit push -u origin master 安裝gh-pages工具 1npm install --save gh-pages 在專案的 package.json 中加入 homepage與scripts 12345678910&quot;name&quot;: &quot;note-blog&quot;,+ &quot;homepage&quot;: &quot;https://minilabmemo.github.io/note-blog&quot;,scripts&quot;: {+ &quot;predeploy&quot;: &quot;npm run build&quot;,+ &quot;deploy&quot;: &quot;gh-pages -d build&quot;, &quot;docusaurus&quot;: &quot;docusaurus&quot;, &quot;start&quot;: &quot;docusaurus start&quot;, &quot;build&quot;: &quot;docusaurus build&quot;, &quot;swizzle&quot;: &quot;docusaurus swizzle&quot;,- &quot;deploy&quot;: &quot;docusaurus deploy&quot;, 接著gh-page 就可以用下列指令上傳啦 console12345678910npm run deploy略Success! Generated static files in build.Use `npm run serve` to test your build locally.&gt; note-blog@0.0.0 deploy /xxxx&gt; gh-pages -d buildPublished 成功部署到 Github 上後，會發現多了一個名為 gh-pages 的分支，教學文中說設定頁-&gt;GitHub Pages-&gt;Source要把頁面指到 gh-pages 這個分支（但我查看預設就是了） 接著打開頁面，結果發現馬上跳錯誤畫面，但有指示要更改docusaurus.config.js檔案內的 1baseUrl: '/note-blog/', 再開一次頁面會成功了！！https://minilabmemo.github.io/note-blog/ （到這邊大約就五分鐘差不多，但為了看懂它的編輯設定還是花了我一點時間．） 開始編輯網站建立完後基本畫面上就有教學了，而且覺得比官網上的說明還要清楚，可以直接查看這邊就好，我也保留了這些教學文件（-&gt;點我） 以下就簡單紀錄使用用法: 更改設定檔 docusaurus.config.js這邊可以更改網站標題與logo，看欄位一一修改應該沒什麼困難,但也有更多可以新增的欄位設定: 主設定檔說明寫在這邊 主題使用設定，可以修改導覽列的下拉清單，新增通知訊息等． 編輯的文件檔案說明文件的編輯格式檔案有兩種選擇 學過react可以用js撰寫 一般可以使用Markdown(.md)撰寫（不知道什麼是Markdown的可以先去玩玩線上編輯工具),而docusaurus可以輸入前言作為描述顯示相關位置： 相關的markdown前言 新增頁面 page可以新增一個頁面，然後對應的網址就會出現對應內容了，這通常是獨立頁面，需要另外用超連結指到這個位置． 須注意對應的網址會在 baseUrl底下喔12ex/src/pages/foo/index.js → &lt;baseUrl&gt;/foo/ 看看效果：note-blog/src/pages/markdown-page.md→https://minilabmemo.github.io/note-blog/markdown-page/ 建立文件 Document可以直接把文章放到docs資料夾裡，並在前言編輯位置與標題就會出現在側邊欄了． /docs/intro.md12345678+ ---+ sidebar_label: &quot;Hi!&quot; + sidebar_position: 3+ ---# Hello 這邊就是文章內容This is my **first Docusaurus document**! 建立blog這邊一樣方法，只是會建立在blog分頁，裡面已經有基本範本，且說明blog支援tags功能，如果不想要blog頁籤，可以把整個資料夾刪除（/your_repo/blog/2019-05-30-welcome.md）． 新增與修改插件設定插件列表 plugin-content-docs如果是有裝classic主題，就可以不用另外安裝，plugin-content-docs裡的內容可以像下面修改： editUrl：修改進入github編輯的位址 showLastUpdateTime：顯示修改日期/docusaurus.config.js12345678910111213presets: [ [ '@docusaurus/preset-classic', { docs: { editUrl: 'https://github.com/&lt;git_account&gt;/&lt;repo&gt;/edit/master/', + showLastUpdateTime: true, } }, ], ], 注意事項 - 錯誤狀況不知道為什麼有的時候能顯示，但是跑到deploy &amp; build時，如果文章中有錯誤連結，就會跑出一堆錯誤喔～！！！可以在一堆錯誤上方中找到,一不小心會以為是npm與libiary問題…. 123456Exhaustive list of all broken links found....npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! /Users/yiyin/.npm/_logs/2021-08-03T06_04_03_540Z-debug.log 網路參考文章 docusaurus 中文指南 [Day 29 - 即時天氣] 寫網頁就是要炫耀啊，不然要幹麻？發布上 Github Pages 吧！","link":"/2021/05/21/blog-docusaurus-01/"},{"title":"[Blog] 使用 Hexo 撰寫部落格 03 - 外部資源&#x2F;插件設定","text":"外部也有一些插件與資源可以幫助部落格更加豐富，本篇記錄用到的外部插件使用方式． 外部資源/插件設定標籤雲1.安裝插件 1npm i hexo-tag-cloud --save 2.配置主網站_config.yml要注意不要改錯檔案，不然可以看到標籤雲卻改不了樣式 12345678# hexo-tag-cloud 標籤雲：see https://github.com/MikeCoder/hexo-tag-cloudtag_cloud: textFont: Trebuchet MS, Helvetica # 字体 textColor: '#869ABF' # 字體颜色 textHeight: 12 # 字體高度 outlineColor: '#FFCFAB' # 字體背景色 maxSpeed: 0.1 # 標籤雲最大移動速度 pauseOnSelected: true # true 選中時停止移動 修改主題側邊欄的語言內容以 NexT 主题為例修改 layout/_macro/sidevar.swig 文件中在 sidebar-inner 新增 123456789101112&gt;if site.tags.length &gt; 1 %}&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;{{ url_for('/js/tagcloud.js') }}&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;{{ url_for('/js/tagcanvas.js') }}&quot;&gt;&lt;/script&gt;&lt;div class=&quot;widget-wrap&quot;&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;220&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; {{ list_tags() }} &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&gt;endif %} 作者 git 上的 Readme 說明 [by version 2.1.2]建議可以關注 https://github.com/MikeCoder/ 說明動作操作 12完成安装和显示，可以通过 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 来进行本地预览, hexo clean 为必须选项。**PS:不要使用 hexo g -d 或者 hexo d -g 这类组合命令。**详情见: Issue 7 新增 Google Analytics 流量分析Google 分析是一個由 Google 所提供的網站流量統計服務。Google 分析現在是網際網路上使用最廣泛的網路分析服務。 （雖然這部落格只是用來來自己筆記的，流量應該很少，但想要用來玩玩看 google 的分析網站而試試） 1.註冊 google analysis這邊我註冊了一個帳戶名（yume），資源名稱為 hexo_blog，名稱之後都可以更改，接著填寫一些想要分析的內容與目的等等，完成後就會得到一個資源，也會有資源 ID（但這不是我們要的），點入該新建的資源後，再新增一個資源串流，就可以得到評估ＩＤ了． 代碼設定操作說明這邊提供了兩種方式說明： 1.新增網頁內代碼，全域網站內有說明如果在網站上 head 區塊加入代碼範例或是使用 google 代碼管理工具． 2.使用現有的網頁內代碼：內有提到 gtag.js 與你的評估 ID 資訊． 2.修改 hexo 的主題設定檔由於目前我用的主題已經有現有的相關代碼設定，因此只要在上面拿到的評估 ID，貼到主題設定檔中的 app_id 裡就可以了． themes/next-reloaded/_config.yml123456# Google Analyticsgoogle_analytics: tracking_id: # &lt;app_id&gt; # By default, NexT will load an external gtag.js script on your site. # If you only need the pageview feature, set the following option to true to get a better performance. only_pageview: false 當然有的時候會遇到不失效的問題，網路有說有的代碼會去判斷主設定檔的 hostname 與 github 是否 123# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://minilabmemo.github.io/ 最終效果網路上可說可以在剛剛的分頁按下測試，但發現並沒有，且一直出現過去 48 小時並未收到資料，不過實際瀏覽可以看到分析結果喔!! 參考文章 Hexo 添加标签云 Hexo 加上 Google analysis Hexo 的 Next 主题中配置 Google Analytics 之后不生效的问题 Hexo fluid 中关联 Google Anlytics 的具体方法","link":"/2022/02/03/blog-hexo-03-plug/"},{"title":"[Blog] 使用 Hexo 撰寫部落格 01- 建立部落格","text":"cq %} hexo 是什麼？ endcq %} Hexo 是一個快速、簡單且強大的網誌框架。Hexo 使用 Markdown 標記語言解析您的文章，並在幾秒鐘內，透過漂亮的主題產生靜態檔案。（來自 https://hexo.io/zh-tw/docs/ 說明） 本文將會知道 如何使用 Hexo 產生部落格 （超快速，只要看到這邊就建好囉！） 如何使用 markdown 撰寫文章 如何部署到 github 個人網頁 如何更改主題與內文風格 (本站用到的所有修改介紹，移到下一篇) 安裝 hexo 與初始化部落格產生基本部落格結構12345678安裝工具 （使用npm安裝 可先安裝Node：https://nodejs.org/en/）$ npm install -g hexo-cli初始資料夾$ hexo init &lt;folder&gt;進入資料夾及安裝相依$ cd &lt;folder&gt;$ npm install這邊就已經做好初始化了 啟動部落格 Run server12$ hexo server開啟瀏覽器 http://localhost:4000 就可以看到部落格了💕💕💕 More info: Server （紀錄）顯示版本資訊（有需要的話，可以查詢對應安裝版本）知道自己安裝的版本，對於之後查詢問題是很有幫助的喔！ 123456789101112131415161718192021$ hexo version(node:5190) ExperimentalWarning: The fs.promises API is experimentalINFO Validating confighexo: 5.1.1hexo-cli: 4.2.0os: Darwin 19.0.0 darwin x64http_parser: 2.8.0node: 10.16.3v8: 6.8.275.32-node.54uv: 1.28.0zlib: 1.2.11brotli: 1.0.7ares: 1.15.0modules: 64nghttp2: 1.39.2napi: 4openssl: 1.1.1cicu: 64.2unicode: 12.1cldr: 35.1tz: 2019a 開始撰寫文章新增文章12345$ hexo new &quot;My New Post&quot;(預設)會在source/＿posts 底下新增一個 .md 檔案$ hexo new draft &quot;My New Post&quot; //指定生成草稿會在source/＿draft 底下新增一個 .md 檔案 More info: Writing 撰寫文章在剛剛新增的檔案開始採用 markdown 語法開始撰寫文章． 可以找線上編輯器工具幫助撰寫及預覽，「自己習慣用這一個https://markdown-editor.github.io/」 ，編輯完再貼過來內文． 如對語法有一點熟悉，就直接用 vscode 打開檔案開始撰寫內文，並可以安裝 vscode markdown preview 插件，邊改邊預覽． 編寫完再啟動部落格並在瀏覽器查看效果． （可帶–draft 顯示草稿） 1hexo s --draft 部署網站建立與設定 Git 空間 先在 github 上新增一個專案叫與帳號一樣命名叫做“[yourname].github.io” 建立完成後會有教你如何建立 commit &amp; push 的語法，建議要先建立連結，之後部署才會順利． 1git push -u origin master 配置 _config.yml 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io branch: master 產生靜態文件 Generate static files123$ hexo generate 或是hexo g會在public資料夾產生網站靜態檔案這是用來部署到網站的檔案，記得每次部署前都要更新喔 More info: Generating 一鍵部署12345$ hexo deploy（略）Branch 'master' set up to track remote branch 'master' from 'https://github.com/minilabmemo/minilabmemo.github.io'.INFO Deploy done: git要看到這句才是部署成功，如果卡住可能要先檢查git連結是否正常． 其他空間部署說明(ex:heroku) More info: Deployment 註：部署會上傳至剛剛 config 的位置，測試發現只會上傳 web 檔案相關如果有上傳 source/theme 檔案也會被移除．因為在開發環境時可以先開一個 src branch 來控管原始檔案．branch - src (have all files)branch - master (only web files) 個人網站網址https://yourname.github.io/ 這樣就大功告成啦！🎉🎉🎉（註：有時要稍等一下才會看到更新） 清理靜態文件 Clean static files12$ hexo clean清除快取檔案 (db.json) 和已產生的靜態檔案 (public) 下一篇會介紹如何更換主題及內文撰寫%} 參考文章 Quick StartWelcome to Hexo! Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub HEXO 指令","link":"/2021/01/31/blog-hexo-01-hello-world/"},{"title":"[Blog] 使用 Hexo 撰寫部落格 02- 更換主題編寫與個人化設定","text":"上一篇已經建立好基本網站架構了，這篇收集本站所有更改主題為 NextT 及更換的個人化設定． 主題呈現效果 更換主網站設定檔主網站設定檔位置：/your folder/_config.yml，可以在此編輯基本網站說明． 12345678title: '程式筆記subtitle: ' Ｍemo 'description: ''keywords:author: xxxlanguage: zh-TW語言可以改為繁體中文，但對應顯示語言可以在以下位置修改：/your folder/themes/next-reloaded/languages/zh-TW.yml 更換主題 Hexo 預設主題是 landscape 想要更換主題依下列步驟即可： 在 hexo 網站上挑選主題：https://hexo.io/themes/ 然後依照教學 clone 對方的主題到自己的 theme 資料夾(通常都有 git 指令，在自己資料夾照下即可) 20220405 更新 使用 fork 對方的主題庫到自己的庫，然後用 submodule 進 theme 資料夾 修改主網站設定_config.yml 來更換 部署修改紀錄 （可跳至最後一步） 本部落格採用 Next，它是一個相當熱門的主題,且有很多中文文檔說明，我也是看了範例網站，真的太喜歡才決定架 hexo 的，紀錄操作步驟如下． (嘗試1:啟動失敗)失敗 更換主題 git clone https://github.com/iissnan/hexo-theme-next themes/next: config.yml 換成 theme：next，但是啟動 hexo s 後，開啟的網站卻是亂碼參數頁面＠＠啟動畫面也出現以下訊息： 123456WARN ========================= ATTENTION! ========================== ===============================================================WARN NexT repository is moving here: https://github.com/theme-next ===============================================================WARN It's rebase to v6.0.0 and future maintenance will resume there =============================================================== 原因應該是找到的文章教學，clone 來源太舊了？改參考官方更新步驟从 NexT v5.1.x 更新 （嘗試2:啟動成功 但曾經部署網站成功後來失敗)&gt;label danger@失敗 %} 試著更換主題 Clone v7.8.0 最新的倉庫（如放在 next-reloaded）：$ git clone https://github.com/theme-next/hexo-theme-next themes/next-reloaded（v.5.1.4） 在 Hexo 的主配置文件中设置主题：theme: next-reloaded 重新開啟就正常了 嘗試3:成功 2022 04 發現部署後 網站一直沒有更新，部署上傳後會跑部署流程，正常會有綠色勾勾，但某次之後都是紅色勾勾，點擊發現一直沒有辦法找到 submoudule themes/next-reloaded 排查過程：蠻奇怪的，不太懂沒有用到 submoudule，不知道是不是殘留，部署的源碼也有看到 theme/next-reloaded 的連接． 決定用 fork 方式一份自己的主題my-hexo-theme-next)，並用 submoudule 加入 1git submodule add https://github.com/xxx/my-hexo-theme-next.git themes/my-hexo-theme-next 然後砍掉其他不要的主題，另外發現.deploy_git 裡面有殘留 theme/next-reloaded…等東西，就直接把.deploy_git 資料夾整個砍掉，重新跑就部署成功了． （這時會發現.deploy_git 跟上傳的檔案裡面都沒有 theme 中奇怪的 next-reloaded 的連接） 之後想更換別的主題也是這樣喔 主題設定主題設定位置：/hexo-web/themes/next-reloaded/_config.yml 更換 NexT 版面風格1234NextT 提供不同風格可以更換#scheme: Muse 選單在上方#scheme: Mist 選單在上方scheme: Pisces 選單在側邊 新增文章標籤與分類 新增標籤與分類頁面 123456789hexo new page tagshexo new page categories=====index.md---title: categoriesdate: 2021-01-11 17:25:08type: &quot;categories&quot; 為文章加上 Tag 與 categories在_posts/xxx.md 文章上方新增，差別在於標籤是並行的標示，而分類會有階層式關係． 1234567891011121314151617---title: 使用Ｈexo 撰寫部落格tags: - Testing - Another Tag比較特別以下這種寫法代表階層關係Web-&gt;blogcategories: - Web - blog或是多分類表示法：代表Diary-&gt;Food...categories:- [Diary, Food]- [Diary, Games]- [Life]--- 開啟 menu 頁面(側邊欄) _config.yml12345678# Usage: `Key: /link/ || icon`# icon 也可以自由置換 https://fontawesome.com/v4.7.0/icons/menu: home: / || fa fa-home categories: /categories/ || fa fa-th archives: /archives/ || fa fa-archive tags: /tags/ || fa fa-tags about: /about/ || fa fa-user 新增個人頁面 新增關於我頁面 1hexo new page about 編輯頁面內容[your folder]/source/about/index.md 12345---title: About Medate: 2020-09-06 13:53:06---bla bla bla bla... 開啟頁面 123456789_config.yml# Usage: `Key: /link/ || icon`# icon 也可以自由置換 https://fontawesome.com/v4.7.0/icons/menu: home: / || fa fa-home categories: /categories/ || fa fa-th archives: /archives/ || fa fa-archive tags: /tags/ || fa fa-tags about: /about/ || fa fa-user 文章中顯示引言 (標籤外掛（Tag Plugins）)12345678910111213有分號的上下引言，兩種皆可&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&gt;centerquote %}blah blah blah&gt;endcenterquote %}&lt;!-- 标签别名 --&gt;blah blah blah單純的置中引言&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;顯示效果在本文開頭喔 文章中程式碼區塊更改主題/themes/next-reloaded/_config.yml 12345678highlight_theme: night# Add copy button on codeblockcopy_button: enable: true # Show text copy result. show_result: true # Available values: default | flat | mac style: default 標籤外掛（Tag Plugins）12345678910依序為 語言 左上標題 右上網址 網址名稱&gt;(% codeblock lang:go terminal https://minilabmemo.github.io/ 完整程式碼 %}go xxx&gt; {% endcodeblock %}\\\\ Backtick Code Block```go terminal https://minilabmemo.github.io/ 完整程式碼```diff-+ codeblock 效果 terminal完整程式碼12&gt; go xxx&gt; Backtick Code Block 效果 terminal完整程式碼1go xxx diff 效果 12- go xxx+ go xxx 文章開頭標記12&gt;Content (md partial supported)其中class_name可不設或是改成下方關鍵字 Content (不設定) 淡灰色 主題_config 文件配置关键字：note，可修改成想要的風格 1234567891011note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 標籤標注1234&gt; {% label info@標示藍色底色 %} &gt; {% label warning@標示黃色底色 %} &gt; {% label danger@標示 danger 底色 %}&gt; {% label info@標示藍色底色 %}&gt; {% label warning@標示黃色底色 %}&gt; {% label danger@標示danger底色 %} 文章中貼上圖片1234567放置圖片在/your folder/themes/next-reloaded/source/images貼上相對路徑![my](/images/avatar_memo.png)或是用html寫法，可以控制大小&lt;img src=&quot;/images/avatar_memo.png&quot; width=&quot;150px&quot; /&gt; 開啟文章與網站訪問數字12345678910111213主題內建不蒜子計數器_config.ymlbusuanzi_count: enable: true total_visitors: true total_visitors_icon: fa fa-user total_views: true total_views_icon: fa fa-eye post_views: true post_views_icon: fa fa-eye本地預覽時底部訪問人數與總訪問的數字會異常大，這是正常现象只需要部署至雲端即可恢復正常 在標頭放上可愛的 git 連結1234_config.ymlgithub_banner: enable: true（本部落格右上角範例） 顯示部落格作者照片12_config.ymlavatar：圖片網址 放上個人社群連結12social可自由新增 顯示閱讀進度百分比123456back2top: enable: true # Back to top in sidebar. sidebar: false 顯示在右下角 true代表顯示在側邊欄 # Scroll percent label in b2t button. scrollpercent: true 顯示百分比 個人化設定預設新增文章模板修改 /scaffolds/post.md 新增自己預設內容 12345678---title: {{ title }}date: {{ date }}tags:categories:---blabla..... 前言&lt;!--more--&gt;\u0006 意外發現的方法，藉由這樣修改 hexo new post 時就可以把基本的設定加好了 參考文章 NextT 開始使用 NextT 主题配置 NextT 內置標籤 Hexo 个人博客 NexT 主题设置 Scheme 外观 hexo 页脚添加访客人数和总访问量 【Hexo 插件系列】 常用 tag deploy 在 hexo 中使用 git submodules 管理主題 用 Github Pages+Hexo 搭建博客之(七)如何删除一篇已经发布的文章 #成功解决：同时删除掉.deploy_git 文件夹","link":"/2022/05/01/blog-hexo-02-themes/"},{"title":"[Blog] hexo 在文章開頭加上內容目錄","text":"內容目錄\"toc“ 是代表 table of contents 目錄，上一篇透過內建的toc雖然可以長出側邊欄，但如果想要在撰寫markdown時讓他出現文章開頭，就需要安裝額外的插件來做到，以下研究了兩種插件的方式並記錄下來． 目錄 | Contents 效果介紹 方法一: use hexo-toc 方法二 use hexo-insert-toc reference 效果介紹原本這個部落格的文章，就已經具有側邊欄 toc 了，只要在文章標頭放上toc:true即可，但我想要的效果是在文章開頭時就放上，這樣手機瀏覽時也能看到內容，這邊有找到安裝額外插件． 方法一: use hexo-toc安裝 hexo-toc 安裝說明來自：https://github.com/bubkoo/hexo-toc 12npm install hexo-toc --save安裝完之後在文章內加入 &lt;!-- toc --&gt; 即可 //注意前後有空格 但這樣加完會出現所有階層，但我並不希望階層太多，可以出現第一層就好，需要再另外安裝插件 markdown-toc 並修改 config 12345671. npm install --save markdown-toc2. _config.ymltoc: maxdepth: 2 class: toc 記得 hexo clean & hexo g 後啟動才會看到效果． 這個插件的問題：這樣做完之後，側邊欄的階層也跟著被影響了，我希望側邊欄可以多階層並隨著文章閱讀而擴展，而內文開頭就顯示第一層就好．找不到方法所以先卸載hexo-toc． 方法二 use hexo-insert-toc安裝 hexo-insert-toc 插件來自：https://github.com/bennycode/hexo-insert-toc 1npm i hexo-insert-toc 更改階層 12hexo-insert-toc: maxdepth: 2 成功安裝完的 dependencies 版本 “展開查看dependencies版本” json >folded123456789101112131415161718192021&quot;dependencies&quot;: { &quot;bulma-stylus&quot;: &quot;^0.8.0&quot;, &quot;hexo&quot;: &quot;^6.3.0&quot;, &quot;hexo-asset-image&quot;: &quot;^1.0.0&quot;, &quot;hexo-component-inferno&quot;: &quot;^2.0.2&quot;, &quot;hexo-deployer-git&quot;: &quot;^2.1.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;, &quot;hexo-insert-toc&quot;: &quot;^1.1.2&quot;, &quot;hexo-log&quot;: &quot;^3.2.0&quot;, &quot;hexo-pagination&quot;: &quot;^2.0.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-inferno&quot;: &quot;^0.1.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^3.0.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;, &quot;hexo-server&quot;: &quot;^2.0.0&quot;, &quot;hexo-theme-landscape&quot;: &quot;^0.0.3&quot;, &quot;markdown-toc&quot;: &quot;^1.2.0&quot;}, 這個插件產生出來的 toc 並不能客制class name，需要再自己加入，而且中文連結會無法跳轉，英文是正常的「尚不知如何解決，只好先練練英文了（誤）」． 後記 20230318更新 關於中文問題，後來有在這個作者的github上詢問.似乎是這個檔案 slugify.js造成，嘗試修改 replace 其實沒有什麼用，所以我就整段註解掉（後來有照作者建議修改），重新 hexo clean/hexo g ，就正常了，不太了解細節，看來是這個位置會變成％E6，但後來又變成%25E6，百分比符號又被變成%25，或許我使用的主題不需要這段，但這樣可以解決我的問題就好了，有時間再來研究． reference Photo by Milan Seitler on Unsplash","link":"/2023/02/26/blog-hexo-05-toc/"},{"title":"[Blog] 使用 Hexo 撰寫部落格-04更換ICARUS主題","text":"2023年新的一年，突然想要來幫部落格換個新主題，這陣子看到 ICARUS 主題，覺得蠻喜歡它的版面配置的，於是就把主題換一下，目前的環境已經裝好hexo了，這篇就直接從更換主題開始～< 更換主題注意事項：原本有一些主題特殊的標籤或是插件及文章內容有可能會發生失效或排版混亂，更換後需要再花時間修正過去的功能． 目錄 hexo 版本 與相依設定 更換主題 替換配置 魔改 theme 主題樣式 [後記] 過程中處理問題 網路參考文章 hexo 版本 與相依設定使用 hexo version 可以查詢版本 “點我查看hexo version ” >folded123456789101112131415161718192021222324252627282930313233+ $ hexo -vINFO Validating configInferno is in development mode.INFO ======================================= ██╗ ██████╗ █████╗ ██████╗ ██╗ ██╗███████╗ ██║██╔════╝██╔══██╗██╔══██╗██║ ██║██╔════╝ ██║██║ ███████║██████╔╝██║ ██║███████╗ ██║██║ ██╔══██║██╔══██╗██║ ██║╚════██║ ██║╚██████╗██║ ██║██║ ██║╚██████╔╝███████║ ╚═╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚══════╝=============================================INFO === Checking package dependencies ===INFO === Checking theme configurations ===INFO === Registering Hexo extensions ===hexo: 6.3.0hexo-cli: 4.3.0os: darwin 22.2.0 13.1node: 14.17.0v8: 8.4.371.23-node.63uv: 1.41.0zlib: 1.2.11brotli: 1.0.9ares: 1.17.1modules: 83nghttp2: 1.42.0napi: 8llhttp: 2.1.3openssl: 1.1.1kcldr: 38.1icu: 68.2tz: 2020dunicode: 13.0 “點我查看package.json ” >folded123456789101112131415161718192021222324252627282930313233343536{ &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;server&quot;: &quot;hexo server&quot; }, &quot;hexo&quot;: { &quot;version&quot;: &quot;6.3.0&quot; }, &quot;dependencies&quot;: { &quot;bulma-stylus&quot;: &quot;^0.8.0&quot;, &quot;hexo&quot;: &quot;^6.3.0&quot;, &quot;hexo-asset-image&quot;: &quot;^1.0.0&quot;, &quot;hexo-component-inferno&quot;: &quot;^2.0.2&quot;, &quot;hexo-deployer-git&quot;: &quot;^2.1.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;, &quot;hexo-log&quot;: &quot;^3.2.0&quot;, &quot;hexo-pagination&quot;: &quot;^2.0.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-inferno&quot;: &quot;^0.1.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^3.0.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;, &quot;hexo-server&quot;: &quot;^2.0.0&quot;, &quot;hexo-tag-cloud&quot;: &quot;^2.1.2&quot;, &quot;hexo-theme-landscape&quot;: &quot;^0.0.3&quot; }, &quot;devDependencies&quot;: {}} 更換主題執行安裝指令 - 安裝位置安裝時有兩種安裝方式 see Getting Started with Icarus install from source12git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus --depth 1 install from NPM1npm install -S hexo-theme-icarus hexo-renderer-inferno Note:一開始我是用第二種安裝方式就裝起來了，不過看起來hexo-theme-icarus會出現在node_modules裡，不是在自己的themes/icarus 兩種方式都可以正確套用到主題效果，不過考慮到之後可能自己會想改主題底層效果當作自己的部分，後來改用第一種方式安裝． 20230319 更新，後來使用補丁，又改用第二種方式，這邊就依使用習慣即可． 執行 12$ hexo config theme icarus然後執行hexo s 就可以了 成功啟動後的初始畫面 可以看到這邊很多介紹都還沒有更改，接下來可以開始更改內容． 替換配置修正 ＿config 檔案 基本設定這裡面的設定就改成自己的資料，另外可以預設語言與時區 _config.yml123+ language: zh-TW+ timezone: 'Asia/Taipei' 修正 config.icarus 檔案 配置版面 _config.icarus.yml 是進到首頁的配置，可以另外新增 _config.post.yml (文章頁面) 和_config.page.yml (自訂頁面) 來覆蓋。 “點我查看 _config.icarus.yml細節” >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221version: 5.1.0variant: default- logo: /img/logo.svghead:- favicon: /img/favicon.svg manifest: name: short_name: start_url: theme_color: background_color: display: standalone icons: - src: '' sizes: '' type: open_graph: title: type: blog url: image: site_name: author: description: twitter_card: twitter_id: twitter_site: google_plus: fb_admins: fb_app_id: structured_data: title: description: url: author: publisher: publisher_logo: image: meta: - '' rss: navbar: menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about links:- Download on GitHub:- icon: fab fa-github- url: https://github.com/ppoffice/hexo-theme-icarusfooter: links: Creative Commons: icon: fab fa-creative-commons url: https://creativecommons.org/ Attribution 4.0 International: icon: fab fa-creative-commons-by url: https://creativecommons.org/licenses/by/4.0/ Download on GitHub: icon: fab fa-github url: https://github.com/ppoffice/hexo-theme-icarusarticle: highlight:- theme: atom-one-light+ theme: atom-one-dark clipboard: true fold: unfolded readtime: true update_time: true licenses: Creative Commons: icon: fab fa-creative-commons url: https://creativecommons.org/ Attribution: icon: fab fa-creative-commons-by url: https://creativecommons.org/licenses/by/4.0/ Noncommercial: icon: fab fa-creative-commons-nc url: https://creativecommons.org/licenses/by-nc/4.0/search: type: insight index_pages: truecomment: type: disqus shortname: ''donates: - type: afdian url: '' - type: alipay qrcode: '' - type: buymeacoffee url: '' - type: patreon url: '' - type: paypal business: '' currency_code: USD - type: wechat qrcode: ''share: type: sharethis install_url: ''sidebar: left: sticky: false right: sticky: falsewidgets: - position: left type: profile author: Your name author_title: Your title location: Your location avatar: avatar_rounded: false gravatar: follow_link: https://github.com/ppoffice social_links: Github: icon: fab fa-github url: https://github.com/ppoffice Facebook: icon: fab fa-facebook url: https://facebook.com Twitter: icon: fab fa-twitter url: https://twitter.com Dribbble: icon: fab fa-dribbble url: https://dribbble.com RSS: icon: fas fa-rss url: / - position: left type: toc index: true collapsed: true+ depth: 4 - position: left type: links links: Hexo: https://hexo.io Bulma: https://bulma.io - position: left type: categories - position: left type: recent_posts - position: left type: archives - position: left type: tags order_by: name amount: show_count: true - position: left type: subscribe_email description: feedburner_id: '' - position: left type: adsense client_id: '' slot_id: '' - position: left type: followit description: action_url: '' verification_code: ''plugins: animejs: true back_to_top: true baidu_analytics: tracking_id: bing_webmaster: tracking_id: + busuanzi: true cnzz: id: web_id: cookie_consent: type: info theme: edgeless static: false position: bottom-left policyLink: https://www.cookiesandyou.com/ gallery: true google_analytics: tracking_id: hotjar: site_id: katex: false mathjax: false outdated_browser: false progressbar: true statcounter: project: security: twitter_conversion_tracking: pixel_id: providers: cdn: jsdelivr fontcdn: google iconcdn: fontawesome logologo可以放置自己的圖片，svg檔案或png檔案都可以． highlight 代碼區塊我改成深色主題atom-one-dark，從它們提供的 styles 檔案位置 中找到的，預覽可以從highlight.js demo 看到效果。（不過切換成深色要注意黑色文字是否被吃掉） sidebar left/right.sticky: true 這設定可以固定左右側邊欄，閱讀時到下方時才會不會看不到 toc 這個是設定出現在部落格側邊的文章目錄，需配合文章開啟Front-Matter才能用，預設是顯示三層，我習慣改成四層． plugins busuanzi: true 這是開啟網站底部及和每篇文章頭部，顯示共多少訪客的開關，上線後數字才會正常． 新增文章文章的 Front-Matter设置1234567891011121314151617181920212223242526272829---title: &quot;[Blog] 使用 Hexo 撰寫部落格-04更換ICARUS主題&quot;+ //文章封面cover: /img/posts/dariusz-sankowski-3OiYMgDKJ6k-unsplash.jpg + //文章縮圖thumbnail: /img/posts/dariusz-sankowski-3OiYMgDKJ6k-unsplash.jpg+ // 文章目錄導覽toc: true+ // 文章標籤tags: - blog+ // 文章目錄categories: - [技術工具,blog]date: 2023-01-22 16:31:36+ 更改某篇文章的代码高亮主题article: highlight: theme: atom-one-dark---+ 這邊可以加入一些引言Post content...&lt;!--more--&gt;Post content... Tip 默認文章都是不開啟toc的，要手動添加在文章開頭，但網路上有教學使之預設開啟．或者你也可以加入到文章模板中． 文章插入圖片根據這篇說明Asset Folders，有兩種方式，一種是放在/source/images，一種是依文章分類放置． 123456789101112// 第一種方法 一定要取名images資料夾 不知道為什麼不能隨便命名&lt;img src=&quot;/images/icarus_init_ui.png&quot; width=&quot;auto&quot; /&gt;// 第二種方法 hexo new xxx 時會有一個獨立資料夾可以放圖片不知道為什麼我這邊是開啟post_asset_folder: true permalink: ':year/:month/:day/:title/'![icarus_init](icarus_init.png)update link as:--&gt;/.io//icarus_init.png但是發現無法找到資料，推判可能是我的插件有什麼插件無法對應到日期 待查 文章插入代碼12345678//第一種可以簡單用```diff “hexo version” &gt;folded //第二種放入codeblock {% codeblock &quot;config.icarus.ym&quot; lang:diff &gt;folded %}{% endcodeblock %}//可以指定是否折疊,沒指定就照預設黨 魔改 theme 主題樣式有時候套用主題，可能會有些地方格式想要調整，就要去更改底層主題的檔案，另外，這邊的更改發布之後，可能會需要清除 cache 才能看到效果． 更改 header logo 高度 因為自己的logo 內容較多，上傳時發現會被自動縮小，為了清楚顯示，所以我把高度調高了，1$logo-height ?= 5rem Warning 這邊要注意圖片是否會模糊（雖然在電腦檔案中看來正常），要設定適當的大小，或是換成svg檔案試試． 更改卡片懸浮效果這個教學是來自 挂件卡片增加浮动效果 include/style/card.styl 當滑鼠移到卡片上時添加陰影及上移效果1234.card+ &amp;:hover+ box-shadow: 0 6px 15px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1)+ transform: translateY(-3px); source/js/animation.js 加上陰影漸變動畫效果1234567.card- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; });- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; }, i * 100); [後記] 過程中處理問題 這個段落是用來記錄過程中遇到的問題，如果你沒有遇上問題可以直接跳過這個章節． 安裝啟動錯誤123註：因為我是從NextT轉換過來的，才發現有些特殊標籤在這邊啟動會爆錯&gt; ：``` Error [Nunjucks Error]: about/index.md [Line 7, Column 4] unknown block tag: note```&gt; 因此我把文章中的找到`{% `與`{% endnote %}`。移除． 再次啟動還是爆錯12345const { Component } = require('inferno'); const classname = require('hexo-component-inferno/lib/util/classname'); const Head = require('./common/head'); const Navbar = require('./common/navbar'); const Widgets = require('./common/widgets'); const Footer = require('./common/footer'); const Scripts = require('./common/scripts'); const Search = require('./common/search'); module.exports = class extends Component { render() { const { site, config, page, helper, body } = this.props; const language = page.lang || page.language || config.language; const columnCount = Widgets.getColumnCount(config.widgets); return ; } };// 解法因為官網github 少了hexo-renderer-inferno 用另一個月再次安裝即可- $ npm install hexo-theme-icarus+ $ npm install -S hexo-theme-icarus hexo-renderer-inferno 刪除舊的NextT主題預設產生位置如果下hexo clean hexo g 會發現文章會產生在public資料夾裡，以前舊的主題先刪除 >folded12345678- 2020- 2021+ .....+ public+ 2020+ 2021 插入圖片時不知道為什麼不能用與文章放置一起的設定(尚未解)12345678// 第一種方法 hexo new xxx 時會有一個獨立資料夾可以放圖片不知道為什麼我這邊是開啟post_asset_folder: true permalink: ':year/:month/:day/:title/'![icarus_init](icarus_init.png)update link as:--&gt;/.io//icarus_init.png但是發現無法找到資料，推判可能是我的插件有什麼插件無法對應到日期 待查 highlight 主題部分無效果 不知道為什麼除了atom-one-dark，換成別的都沒有效果． hexo 版本升級一開始用的hexo版本是5.4.2，但是啟動時噴ERRROR 提示要升至hexo: 6，還有其他錯誤…，於是就一步步照著指令安裝就啟動成功了． 主題備份自己有開了一個 src 分支用來記錄所有原生檔案，因為上傳只會紀錄 public 檔案，但是theme這個資料夾裡面是 git clone 別人的（theme作者），所以其實是不會出現在自己分支內的，如果有魔改theme的要記得自己在備份一下．我自己是開了一個icarus_fix_record來記錄，雖然有點麻煩，但以後要更新比較方便（或許會更新ＸＤ），如果改得太多可以考慮解除git綁定上傳整個theme． 20230319更新：改用補丁更新，可以看最新文章． 部署時卡住 1.檢查token有沒有過期 2.檢查上傳使用者是否錯誤12345git config --global -luser.name=xxxuser.email=xxx@gmail.comcredential.username=xxxcredential.helper=osxkeychain 未完待續 待研究中…12345678910111213141516多語言多階層Submenuhttps://github.com/ppoffice/hexo-theme-icarus/issues/527看板娘留言區魔改SEObuymecoffeeOpen GraphIcarus用户指南 - 主题配置 Google Structured Data 你可以在head配置中设置Google Structured Data。 你应该在配置文件中将绝大部分配置留空。 仅在需要的时候在文章的front-matter中为这些设置赋值。https://ppoffice.github.io/hexo-theme-icarus/Widgets/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E6%8C%82%E4%BB%B6/添加404公益页面中文分類或標籤 tag_map 網路參考文章 hexo-theme-icarus github Icarus快速上手 Icarus用户指南 - 主题配置 Icarus的默认主题配置文件为_config.icarus.yml。 此文件定义了站点全局的布局与样式设置，同时也控制了例如插件与挂件等外部功能的配置。 本文详细介绍了本主题的一般配置，并且解释了Icarus使用哪些配置文件和它是如何生成并验证这些配置。 Hexo-Icarus主题配置建议 活用 Bulma 美化 Icarus 文章 Hexo博客指南|第十二篇:Icarus配置 - 网站分析插件 不蒜子网页计数器 及其他統計插件 圖片來源：https://unsplash.com/ [icarus个性化配置] (http://www.anticme.com/2021/03/26/icarus%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/#%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)","link":"/2023/01/22/blog-hexo-04-theme-icarus/"},{"title":"[Blog] 使用 Hugo 撰寫部落格","text":"本章介紹如何在套用 hugo 做好一個自己的部落格網站．並上傳 github 2020.09 更新： 因為找不到主題可以將文章標題透過階層式瀏覽，所以後來改用 hexo（就是現在這邊網站用的樣式），使用上部署也較 hugo 方便，本篇紀錄當時的 hugo 建立留存． 建立部落格前可以先分別上 hexo/hugo 官網查看主題效果，看自己喜歡哪一種再建立． hexo 教學文請看： 使用Ｈ exo 撰寫部落格 gohugo作者Steve Francia Step 1: 安裝 Hugo開啟終端機，依序執行下列指令： 12345678* brew install hugo//macOs 須先安裝Homebrew* hugo version//確認安裝成功版本Hugo Static Site Generator v0.69.0/extended darwin/amd64 BuildDate: unknow* hugo new site **website-hugo*** cd **website-hugo**// 新增網站，粗體可以自命名，安裝完會新增該資料夾 Step 2: 新增主題https://themes.gohugo.io/hugo 網站有很多可以選擇與查看效果進入該主題的 github/README 可以看安裝步驟執行基本執行：git submodule add https://github.com/alex-shpak/hugo-book themes/book//這樣就會在website-hugo/themes/新增主題 Step 3: 編輯 config.toml這檔案與整體網站設定有關 baseURL = “https://xxx.github.io/&quot;languageCode = “zh-tw”title = “xxx Blog” #domain 設定 xxx 改成你的 GitHub 帳號名稱 根據主題不同 這檔案也可能會有更多不同設定ex: 設定主題 theme = “ananke” Step 4: 新增文章 hugo new posts/my-first-post.md新增預設檔案在以下位置 採用 markdown 編寫content//. title: “My First Post”date: 2019-03-26T08:47:11+01:00draft: true //是草稿是否 改成 false 可被發布 可以根據主題新增：tags: [“hugo”, “web”]summary: “The summary image should be a custom one”summaryImage: “summary_2.jpg”resources: src: summary_2.jpg 圖片新增將圖片放置在 website-hugo/static/images文章內可用相對路徑新增 Step 5: 啟動本地 server hugo server -DWeb Server is available at http://localhost:1313/Press Ctrl+C to stop記得結束務必按 不然下次啟動會佔用 Step 6: 產生靜態檔案Ｄ 參數代表要不要輸出草稿文章Build static pages hugo -D 將會生成./public/ 資料夾，每次編輯完要記得更新，之後發布的時候也要上傳 Step 7:githug 網站上傳新增兩個 repoxxx.github.io (xxx 改成自己的帳號名稱)website-hugo 上述的 site 名稱 上傳 public 資料夾 cd publicgit initgit remote add origin https://github.com/xxx/xxx.github.io.gitgit add .git commit -m “Initial commit”git push -u origin master 上傳整個 website-hugo 資料夾 cd ../git initgit remote add origin https://github.com/xxx/website-hugo.gitgit add .git commit -m “Initial commit”git push -u origin master 開啟https://xxx.github.io/ 等個幾分鐘會看到結果 參考文章 ＨＵＧＯ官網 在-github-部署-hugo-靜態網站","link":"/2020/09/01/blog-hugo/"},{"title":"[Blog] 在文章底部加上 分享&#x2F;贊助&#x2F;評論 內容","text":"一開始設置完 blog，底部有幾個區塊 - 分享/贊助/評論 沒有設定，是會跳出紅色框框的，這篇就來把文章底部相關的互動給補齊吧． 目錄 | Contents 分享按鈕 評論功能 贊助按鈕 網路參考文章 分享按鈕依照Icarus 用户指南 - 分享按钮 選擇一個喜歡的按鈕，我是用 addthis，依照說明填入，需注意要填入正確，不然會看不見．這一個用法要先去 addthis 上面註冊，然後可以在 addthis 時時更改樣式． _config.icarus.yml123share:+ type: addthis+ install_url: '要填入正確' 起在本地就可以看到效果了． 評論功能依照 Icarus 用户指南 - 用户评论插件 內有多種評論平台，我目前是直接使用 Facebook． _config.icarus.yml12comment:+ type: facebook 起在本地就可以看到效果了． 贊助按鈕依照 Icarus 用户指南 - 赞赏按钮 說明設定，選擇可以收款的方式． 123456789101112131415161718192021donates: - type: afdian url: '' - type: alipay qrcode: '' - type: buymeacoffee url: '' - type: patreon url: '' - type: paypal business: '' currency_code: USD - type: wechat qrcode: '' 網路參考文章 AddThis 詳細的操作可以看這邊 AddThis 現已免費！一行程式碼為網站加入分享追蹤按鈕，整合電子報等行銷功能","link":"/2022/01/27/blog-hexo-06-share/"},{"title":"[chrome-extension] 自己動手寫一個 chrome 擴充 (一次搜尋電子書網站)","text":"Chrome 擴充功能是一種可以在 Chrome 瀏覽器應用商店安裝的擴充程式。透過網頁技術（HTML、CSS、JS），它能夠修改和增強瀏覽器的功能，例如書籤管理、自訂背景、開啟新分頁、右鍵選單等等。這篇文章將引導您進行一個實際範例，教您如何撰寫一個擴充功能，並以搜尋特定網站為例子 目錄 | Contents 程式架構說明 動手更改程式碼 網路參考文章 程式架構說明在 Google Chrome 的 GitHub 存儲庫中，有提供多種程式碼範例，位置在chrome-extensions-samples。這些範例包含了一個 manifest.json 檔案，用於定義擴充功能的名稱、版本、描述，以及擴充功能所需的 HTML、JS 和圖示等檔案。以下是 hello-world 的範例： tutorial.hello-world/manifest.json12345678910{ &quot;name&quot;: &quot;Hello Extensions&quot;, &quot;description&quot;: &quot;Base Level Extension&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;manifest_version&quot;: 3, &quot;action&quot;: { &quot;default_popup&quot;: &quot;hello.html&quot;, &quot;default_icon&quot;: &quot;hello_extensions.png&quot; }} API reference這份 JSON 文件中所定義的 Manifest Keys 需要參考官方的API 參考文件來確保正確性。請留意 manifest_version 版本的選擇，因為網路上大部分資源是針對 V2 版本的 Manifest Keys 寫法。上述範例是 V3 版本的寫法，所以在對照時需要特別注意，以避免元件出錯。 以下列出幾種 Manifest Keys 說明： action 內容可用來控制 Chrome 用戶界面中的工具欄按鈕： 123456789101112131415{ &quot;name&quot;: &quot;Action Extension&quot;, ... &quot;action&quot;: { &quot;default_icon&quot;: { // optional &quot;16&quot;: &quot;images/icon16.png&quot;, // optional &quot;24&quot;: &quot;images/icon24.png&quot;, // optional &quot;32&quot;: &quot;images/icon32.png&quot; // optional }, &quot;default_title&quot;: &quot;Click Me&quot;, // optional, shown in tooltip &quot;default_popup&quot;: &quot;popup.html&quot; // optional }, ...} contextMenus 控制右鍵選單 tab 控制瀏覽器分頁 storage使用來存儲、檢索和跟踪對用戶數據的更改。 runtime 消息傳遞，可以使用這些方法和事件與其他擴展通信：connect()、onConnect、onConnectExternal、sendMessage()、onMessage 和 onMessageExternal。 本地載入開發將上述程式碼範例從 github 下載到本地端，依下列步驟載入程式 打開自訂與管理-&gt;更多工具-&gt;擴充功能 或者 Open chrome://extensions 把開發者模式打開。 將範例資料夾丟入，如果格式正確就會成功載入出現該擴充。 網址列右方的擴充按鈕就會出現相關的圖示以及點擊後的彈出視窗 html。（以 hello 範例為例，你可以自行載入不同擴充看看效果） 動手更改程式碼接下來自己寫一個擴充元件，加入自己想要控制的功能。 發想 1 : 一個簡單可實現的搜尋功能你是否經常在閱讀網頁時對某個主題感興趣，但需要另外進行搜尋呢？我最近經常想查找公共圖書館是否有特定的電子書，但使用 Google 搜尋並不迅速。因此，我會打開所有需要的電子書網站，一一輸入關鍵字進行搜尋。這雖然是簡單的動作，卻花了不少時間。 Google Chrome 擴充功能支援在右鍵選單中添加擴充按鈕，我們可以利用這個功能實現對特定網站的搜尋。以電子書資源為例，在右鍵選單中加入一個按鈕，可以快速開啟特定網站的電子書資源。 擴充功能 : 尋找台南圖書館線上資源這裡是台南圖書館提供的電子書資源網站列表，我將挑選其中我每次都會查詢的網址，包括 HyRead ebook X 台南圖書館、台灣雲端書庫、udn 讀書館(臺南分區資源中心)、台灣雲端書庫和國立公共資訊圖書館電子書服務平台，進行一次開啟。 功能 1 實現右鍵出現選單 contextMenus 新增背景執行程式與權限 manifest.json123456 &quot;background&quot;: {+ &quot;service_worker&quot;: &quot;background.js&quot; }, &quot;permissions&quot;: [+ &quot;contextMenus&quot; ], 加入右鍵選單 與點選後要做的事情 background.js1234567891011121314151617181920212223// title 裏面加上 %s 可以很神奇的出現你選擇的內容function setupContextMenu() {+ chrome.contextMenus.create({+ id: 'find-ebook',+ title: `find e-Book resources %s`,+ contexts: ['selection']+ });}// runtime.onInstalled 去執行 setupContextMenu+ chrome.runtime.onInstalled.addListener(() =&gt; {+ setupContextMenu();+ });+ chrome.contextMenus.onClicked.addListener((data) =&gt; { //當選單被按下要做的事 這邊要做的是新增分頁+ chrome.tabs.create({+ url: `https://tnml.ebook.hyread.com.tw/searchList.jsp?search_field=FullText&amp;search_input=${data.selectionText}`+ })+ }); 其中 url 的部分要先去你要搜尋的網站，去觀察找出 keyword 要取代的部分 近一步加入自己想要開啟的特定網站列表，這樣就完成了，如下顯示： 功能 2. popup 顯示條件搜尋根據前面提到的 “action”，我們可以設定 “popup.html”，在這個 HTML 檔案中可以加入你希望呈現的頁面內容。這部分需要一些 HTML、CSS 和 JavaScript 的基礎技巧。而 “popup.js” 則負責定義與控制動作，並與前面提到的 Chrome API 進行互動。這樣的設定可以讓你自由地定製擴充功能的外觀和功能。 完成如下顯示，功能效果與前述相同，只是多加了搜尋設定： 延伸： 如果要記住設定可以與 storage API 互動 設定要能同步傳到右鍵開啟選項則可以使用 runtime API 消息傳遞傳送， 完整程式碼這裡是我完整的程式碼 chrome-ext-find-ebook，你可以根據需要添加其他地區的電子資源網站。如果這對你有用，請給我一些星星評價。如果你遇到問題或有其他需求，請在問題回報頁面上提出，我會盡力提供幫助。 發想 ２ ： 護眼功能另一個想法是添加護眼功能。根據前面所提到的開啟新分頁的方法，我們也可以設定提醒通知。有時候，當我們在寫程式時，往往會連續工作數小時，經常忘記讓眼睛休息一下。儘管有使用過番茄鐘等應用程式，但往往會忽略背景執行的提醒。 我們可以開發一個擴充功能，每隔一段時間彈出提醒視窗，提醒使用者休息眼睛。可以設定時間間隔，例如每60分鐘彈出一次提醒。這樣即使沉浸在工作中，也會有提醒來保護視力健康。 但這項功能搜尋後發現已經有人做過了，完全符合我的需求，而且有些會去更改網頁底色，直接推薦這些元件出來，雖然我覺得應該可以參考再整合，之後有時間或更大的需求再來做做看了： eyeCare - Protect your vision 可以設定休息時間還有音效，跳出通知也有簡單的護眼訊息 深色模式，這個在chrome 應用商店 搜尋可以發現很多，會幫你把網頁改成深色底色。 網路參考文章 Photo by Mediamodifier on Unsplash","link":"/2023/05/05/chrome-ext-01/"},{"title":"[docker]常用docker指令筆記整理","text":"常用docker指令筆記整理 啟動imagedocker run使用docker有兩種方式，docker hub 有些會寫好內容 ex:mongo-docker hub 一種是直接下docker run，再下對應參數，下一次起一個程式。 ex:docker run -v D:\\home/work:/home/work –name myub -it ubuntu bash 參數 意思 –name 替container取名 -p（小寫） hostPort對應containerPort -v 分享空間 -it 代表在執行Docker 虛擬容器環境時，開啟虛擬終端機，以互動的模式執行 –cpus=1.5 限制 CPU 使用量 –memory=300m –memory-swap=1g 限制記憶體與 swap 交換空間的用量 docker-compose 另一種是把它寫成docker-compose.yml方式，可以一次啟動多個程式。有些image會提供已編寫好的內容。 docker-compose up -d 啟動，-d detached 在背景執行 docker-compose stop 停止容器 docker-compose down 刪除容器 其他常用指令基本操作 $docker –versionDocker version 18.09.2, build 6247962 查看簡易docker版本 docker ps 查看正在啟動的CONTAINER與ID docker stop ‘CONTAINER_ID’ 停止 Docker 容器 docker kill ‘CONTAINER_ID’ 強制停止 Docker 容器 docker restart ‘CONTAINER_ID’ 重新啟動 Docker 容器 docker ps -a -a :顯示所有的容器，包括未運行的 docker search ‘ubuntu’ docker search ‘xxx’ 查詢可下載 image docker pull ‘ubuntu’ docker pull ‘xxx’ 下載 image docker images 查看下載image與ID docker system df 查看使用的磁盘空间 -v more detail 查看個別container docker stats 查看容器使用的系统资源 每隔 1 秒刷新 docker stats –no-stream 查看容器當前的系統資源 docker stats ‘CONTAINER ID or name’… 指定查看特定容器 備份系列 docker cp ‘CONTAINER ID’:/xx local Ex: docker cp 9e701a5209fe:/data/db C:/test_temp 複製CONTAINER內資料出來本地 docker save 備份 Docker Image 清理指令系列清理指令系列另外寫:因為image都有一定的大小，使用完不用要記得清除。 docker rm ‘CONTAINER_ID’ 刪除 container docker rmi ‘image_ID’ 刪除 image docker rm $(docker ps -a -q) 刪除所有容器(container)//在powershell下才有用 docker stop $(docker ps -a -q) 停止所有容器 //在powershell下才有用 製作 docker image要針對服務去寫Dockerfile, 然後執行下列值令 123docker build -t myname . --no-cache//-t: 鏡像的名字及標籤，通常 name:tag 或者 name 格式；可以在一次構建中為一個鏡像設置多個標籤。 參考文章1.Docker 常用指令與容器操作教學2.谁用光了磁盘？Docker System命令详解3.清理Docker，删除没用的文件4.查看 docker 容器使用的资源","link":"/2020/10/31/docker-cli/"},{"title":"[docker&#x2F;mongo]使用docker啟動mongo與操作","text":"什麼是mongo MongoDB是NoSQL的資料庫，以文件儲存資料，一般資料庫開Table須定義欄位(大小、型別、名稱等)，但是Collection完全不事先定義欄位，每筆document可以有不等數量的欄位 本文將會知道： 使用docker-compose 快速啟動mongodb 須先下載docker並具docker-compose知識 簡單的工具操作與MongoDB Shell 更新批量資料 與關聯式資料庫名詞對應： MongoDB RDBMS 意思 db DB 資料庫 collection Table 表格 document record 一筆紀錄 1.啟動mongo docker這邊直接用編輯docker-compose.yml 貼上網路找到的內容 123456789101112version: '3.1'services: mongo: image: mongo ports: - &quot;27017:27017&quot; restart: always environment: MONGO_INITDB_ROOT_USERNAME: root MONGO_INITDB_ROOT_PASSWORD: example 啟動 123➜ mongo git:(master) ✗ docker-compose up -d Creating network &quot;mongo_default&quot; with the default driverCreating mongo_mongo_1 ... done 2.操作資料內容以下可用透過一些網上mongo工具 ex Robo3T操作 先進行連線進入介面host: localhost, port: 27017 CreateDB”test”，新增一筆Collection”user”，與新增Documanet如下(Json格式) 1234567{ &quot;profile&quot; : { &quot;name&quot; : &quot;user1&quot;, &quot;gender&quot; : &quot;F&quot;, &quot;age&quot; : 18 }} 新增完會自動產生唯一的objectID，透過工具也可以對資料做簡單的修改動作。 3.mongo shell 可以再有提供shell指令視窗的工具上下指令去做更新進階的搜尋， 例如mongo 3T上方就有視窗可以使用． 搜尋指令搜尋全部1db.getCollection('user').find({}) 搜尋by_id1db.getCollection('user').find({_id:ObjectId(&quot;5eaa780f3dfac43981e4412c&quot;)}) 限制顯示的欄位: 1可見,0不可見12345db.getCollection('user').find({},{profile.name:1})有一點像是SELECT profile.name FROM user_id預設顯示，可以關掉_id:0 搜尋內容值1db.getCollection('user').find({&quot;profile.name&quot;:&quot;user1&quot;}) 搜尋範圍 數字型態12[gt大於，gte大於等於，lt小於，lte小於等於]db.getCollection('user').find({&quot;profile.gender&quot;:&quot;F&quot;,&quot;profile.age&quot;:{$gt:2,$lte:18}}) 搜尋範圍 字串型態12按UTF-8進行字典排序 表搜尋字母A~Z間db.getCollection('user').find({&quot;profile.name&quot;:{$gt:&quot;a&quot;,$lte:&quot;z&quot;}}) 排序12依命名排序，其中 1 为升序排列，而 -1 是用于降序排列db.getCollection('user').find({}).sort({name:1}) 顯示筆數(limit)與開始(skip)12可以用他來做分頁讀取db.getCollection('user').find({}).sort({name:1}).skip(0).limit(2) 計算總數1db.getCollection('user').find().count() 批次更新一般來說工具就可以做內容更新，但如果需要透過指令， 更新欄位將性別欄位“F”全改成“woman” 12345678db.getCollection('user').find().forEach( function(d) { if(d.profile.gender==&quot;F&quot;){ d.profile.gender=&quot;woman&quot; db.getCollection('user').update({&quot;profile.name&quot;:d.profile.name},d); print(d.profile.name+&quot; process change done&quot; ); };}); 新增欄位合併內容12345db.getCollection('user').find().forEach( function(d) {d.description= d.profile.name+&quot;,&quot;+d.profile.gender;db.getCollection('user').update({&quot;profile.name&quot;:d.profile.name},d); print(d.profile.name+&quot; process change done&quot; ); }); 刪除欄位12345db.getCollection('user').find().forEach( function(d) {delete d.descriptiondb.getCollection('user').update({&quot;profile.name&quot;:d.profile.name},d); print(d.profile.name+&quot; process change done&quot; ); }); 如果是要在mongo的docker環境上面下指令需要把指令包成js，檔案丟進去docker裡面，然後下指令12load(&quot;script/Change.js&quot;) //檔案位置mongo 127.0.0.1:27017/test Change.js 執行結果與上述內容一樣 本章對mongo的簡單操作到此結束，之後再介紹如何用golang程式去對mongo CRUD操作．","link":"/2020/09/12/docker-mongo/"},{"title":"[Docker]快速啟動可用VNC進去連線之ubuntu","text":"一般來說docker可以快速去建立一個ubuntu環境，但如果習慣畫面操作，還需要再安裝VNC設定，不知道有沒有人做好的VNC版本呢? 網路上找到一個docker image專案可以做到這件事-&gt;docker-ubuntu-vnc-desktop 遵照git readme指示啟動:網頁版本連線Quick Start Run the docker container and access with port 6080 docker run -p 6080:80 -v /dev/shm:/dev/shm dorowu/ubuntu-desktop-lxde-vncBrowse http://127.0.0.1:6080/ VNC 版本連線docker run -p 6080:80 -p 5900:5900 -v /dev/shm:/dev/shm dorowu/ubuntu-desktop-lxde-vnc 下載VNC工具realvnc 啟動之後連VNC(local:127.0.0.0)就可以一樣看到畫面了","link":"/2020/09/14/docker-ubuntu-vnc/"},{"title":"[command]使用內建指令快速產生大黨","text":"開發時有時會需要測試大檔案的上傳，因此需要先準備大檔案，而系統內建就有一些指令可以快速產生虛胖的檔案． windows環境 Fsutil 是用於執行與檔案配置表 (FAT) 和 NTFS 檔案系統相關的工作，例如管理重新剖析點、管理稀疏檔案或卸載磁片區。必須以系統管理員身分執行，才能使用 fsutil。 更多功能請見microsoft fsutil fsutil file createnew 用法 fsutil file createnew 位置 &lt;FileName.txt&gt; &lt;FileSize(size in bytes)&gt;12345C:\\WINDOWS\\system32&gt; fsutil file createnew /?使用方法 : fsutil file createNew &lt;filename&gt; &lt;length&gt; 例如 : fsutil file createNew C:\\testfile.txt 1000C:\\WINDOWS\\system32&gt;fsutil file createnew C:\\testfile.txt 1000檔案 C:\\testfile.txt 已經建立 自行計算一下產生不同大小的檔案1234fsutil file createnew C:\\1kb.txt 1000 //產生1kb檔案至指定位置fsutil file createnew large_10m.txt 10485760 //10*1024*1024fsutil file createnew large_500m.txt 524288000 //500*1024*1024fsutil file createnew large_1g.txt 1073741824 //1*1024*1024*1024 Mac 環境在Ｍac環境使用更方便，不需計算大小，使用內建的 mkfile 指令就可以輕鬆建立了： mkfile -n size[b|k|m|g] filename1mkfile -n 20m 20mb.txt 網路參考文章Quickly Generate Large Test Files in Windows[Mac] 使用 mkfile 指令，快速建立測試用的大檔","link":"/2021/04/20/fake-file/"},{"title":"[docker] 建立elasticSearch儲存資料與kibana呈現使用","text":"本章介紹使用elasticSearch儲存資料與kibana呈現使用 本文內容： 自行建立elasticSearch/kibana [docker] 建立elasticSearch index與傳送資料 使用kibana查詢資料 1.啟動docker-elasticSearch/kibana 先備知識:docker &amp; docker-compose 先將網路上找到的docker-compose.yml內容編輯好，然後在一樣的目錄下開啟指令docker-compose up -d 1234$docker-compose up -dWARNING: Some services (elasticsearch, kibana) use the 'deploy' key, which will be ignored. Compose does not support 'deploy' configuration - use `docker stack deploy` to deploy to a swarm.Starting elasticsearch-624 ... doneStarting kibana-624 ... done 需要一點時間，可以用Kitematic之類的工具查看有沒有成功 GET localhost:9200 確認elasticSearch是否啟動成功會回版號等資訊 “number”: “6.2.4” 開啟瀏覽器，確認kibana有無成功http://127.0.0.1:5601/app/kibana#/home?_g=() 2.準備資料與index 先設計資料內容，假設今天要收集一個使用者每天的運動紀錄這是一個有array的紀錄內容，內容可長可短。1234567891011121314151617181920{ &quot;user&quot;: &quot;user01&quot;, &quot;timestamp&quot;: 1583734521000, &quot;records&quot;: [ { &quot;record_name&quot;: &quot;heart_rate&quot;, &quot;data_number&quot;: 80, &quot;data_txt&quot;: &quot;avg&quot; }, { &quot;record_name&quot;: &quot;Calories&quot;, &quot;data_number&quot;: 200 }, { &quot;record_name&quot;: &quot;time_duration&quot;, &quot;data_number&quot;: 30, &quot;record_unit&quot;: &quot;min&quot; } ]} 接著新增必須欄位的屬性index user是一般text,timestamp是date records先建立nested巢狀，在建立裡面的record_name等欄位。 建立index: PUT localhost:9200/{index}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172PUT localhost:9200/event{ &quot;mappings&quot;: { &quot;_doc&quot;: { &quot;properties&quot;: { &quot;user&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } }, &quot;id&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } }, &quot;timestamp&quot;: { &quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;epoch_millis&quot; }, &quot;records&quot;: { &quot;type&quot;: &quot;nested&quot;, &quot;properties&quot;: { &quot;record_name&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } }, &quot;data_number&quot;: { &quot;type&quot;: &quot;long&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } }, &quot;data_txt&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } }, &quot;record_unit&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;keyword&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } } } } } } }} 送資料進去 接著把上述資料先送一筆進去 http://localhost:9200/{index}/{type}POST http://localhost:9200/event/_doc kibana建立index 建立indexManagement頁面-&gt;create index-&gt;填入event-&gt;選擇可以做時間分割的欄位名稱{上述是用timestamp}-&gt;按下create index pattern Discover頁面搜尋資料再送一次資料，這次把 “timestamp”: {改成現在時間戳}-&gt;線上有很多工具可以做轉換回到Discover頁面，query最近15分鐘的資料-&gt;就可以看到時間軸了 Visualize 建立感興趣的圖表展示ex: table顯示/長條圖顯示等/或是特定filter資料。然後替圖表存檔。 Dashboard 頁面這邊把剛剛建立的圖表拉好顯示在這邊。 dev tools 頁面透過條件指令搜尋特定資料，如有程式需要可以用搜尋API試著找出自己想搜尋的內容 size/page/sort 分頁與排序依據 bool query 條件-filter時間/range/match/wildcard等搜尋 所有 must 必须匹配，所有 must_not 都必须不匹配 minimum_should_match 參數控制需要匹配的 should 語句的數量 範例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394GET /event/_search{ &quot;size&quot;: 1000, &quot;query&quot;: { &quot;bool&quot;: { &quot;filter&quot;: { &quot;range&quot;: { &quot;timestamp&quot;: { &quot;from&quot;: 159132465000, &quot;include_lower&quot;: true, &quot;include_upper&quot;: true, &quot;to&quot;: 1591324650099 } } }, &quot;must&quot;: [ { &quot;exists&quot;: { &quot;field&quot;: &quot;user&quot; } }, { &quot;match&quot;: { &quot;user&quot;: { &quot;operator&quot;: &quot;AND&quot;, &quot;query&quot;: &quot;user01&quot; } } }, { &quot;nested&quot;: { &quot;path&quot;: &quot;records&quot;, &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: [ { &quot;match&quot;: { &quot;records.record_name&quot;: { &quot;operator&quot;: &quot;AND&quot;, &quot;query&quot;: &quot;heart_rate&quot; } } }, { &quot;wildcard&quot;: { &quot;records.data_txt&quot;: &quot;*a*&quot; } }, { &quot;range&quot;: { &quot;records.data_number&quot;: { &quot;from&quot;: 2, &quot;include_lower&quot;: false, &quot;include_upper&quot;: true, &quot;to&quot;: null } } } ] } } } } ], &quot;minimum_should_match&quot;: &quot;1&quot;, &quot;should&quot;: [ { &quot;match&quot;: { &quot;user&quot;: { &quot;operator&quot;: &quot;AND&quot;, &quot;query&quot;: &quot;user01&quot; } } }, { &quot;match&quot;: { &quot;user&quot;: { &quot;operator&quot;: &quot;AND&quot;, &quot;query&quot;: &quot;user02&quot; } } } ] } }, &quot;sort&quot;: [ { &quot;timestamp&quot;: { &quot;order&quot;: &quot;desc&quot; } } ]} 網路參考文章 elastic-組合查詢 中文","link":"/2021/04/24/docker-elastic-kibana/"},{"title":"GitHub 建立首頁個人頁面介紹","text":"GitHub創立完帳號之後 其實可以產生profile 個人頁面，就可以在自己的首頁加上更多介紹！ 如何建立自己的 GitHub 個人頁面： 建立帳號同名 Repository 修改 README.md 完成! 到首頁看看效果 看看我的效果＝&gt;https://github.com/minilabmemo 網路上還有更多很酷的個人介面介紹與產生器，可以參考以下文章: 如何建立獨一無二的 GitHub Profile！與三個很酷的設計及應用 🚀 profile Generator這工具幫你產出介紹還有技能樹圖示!!!","link":"/2021/01/11/github-profile-page/"},{"title":"[deploy]將網頁程式部署到heroku運行","text":"Heroku是一個支援多種程式語言的雲平台即服務，免費版提供每個月平台550小時時間，但每 30 分鐘未使用都會休眠一次，需等待他從休眠時間中甦醒，時間大約 30 秒左右． 註冊 heroku 先上官網註冊一個帳號 安裝 heroku CLI參考：https://devcenter.heroku.com/articles/heroku-cli#download-and-install 安裝 123456789 ➜ testmemooo git:(master) heroku version › Warning: heroku update available from 7.40.0 to 7.43.0.heroku/7.40.0 darwin-x64 node-v12.16.2➜ testmemooo git:(master) npm install -g heroku/usr/local/bin/heroku -&gt; /usr/local/lib/node_modules/heroku/bin/run+ heroku@7.43.0added 788 packages from 316 contributors in 54.332s➜ testmemooo git:(master) heroku versionheroku/7.43.0 darwin-x64 node-v10.16.3 登入heroku login 查看每個月使用多少時間 Account Setting-&gt;Billing-&gt; Free Dyno Usage 部署 React方式一：兩分鐘 0 配置快速部署 官方已先配置好並照說明指令輸入即可Deploying React with Zero Configuration 123456789npm install -g create-react-appcreate-react-app '自命名專案'cd '自命名專案'git initheroku create -b https://github.com/mars/create-react-app-buildpack.gitgit add .git commit -m &quot;react-create-app on Heroku&quot;git push heroku masterheroku open 其中中間那一句 heroku create 會在剛剛的網站上新增一個 damp-stream-02723 專案最後一句是開啟網站：https://damp-stream-02723.herokuapp.com/這樣就看到網站了，命名應該是隨機的，但實際測試可以透過以下方式改名 更換專案名稱登入該網站後直接在專案上改名字之後要回到專案上改 git 上傳的位置update git remote 1234567891011使用指令git remote rm heroku刪除舊有的 remote ‘heroku’➜ demomemooo git:(master) git remote rm heroku使用heroku指令綁定heroku git:remote -a newname➜ demomemooo git:(master) heroku git:remote -a demomemooo › Error: Couldn't find that app. › Error ID: not_found這邊會失敗是因為當時還沒有在網站上更名➜ demomemooo git:(master) heroku git:remote -a demomemoooset git remote heroku to https://git.heroku.com/demomemooo.git https://demomemooo.herokuapp.com/ 小提醒：之後如果要更新記得先在本地起看看，並且照一般在 vscode 操作 git 上傳即可． 部署設定： 保護源代碼設定GENERATE_SOURCEMAP環境變數可以使得源代碼不會出現在dev tool中顯示add into package.json:1234&quot;scripts&quot;: { &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;GENERATE_SOURCEMAP=false react-scripts build&quot;,} 現有專案上傳1234567cd '現有專案'heroku create -b https://github.com/mars/create-react-app-buildpack.git專案內容看不到有什麼變化＠＠ 但本地專案會多連接一個heroku遠端git連結遠端heroku網站上一樣會多一個隨機命名的專案被建立．git push heroku master上傳，會直接執行build/deploy，等待它完就可以了．heroku open 方法二 自行建立設定 先建立 React 命名 testdemooo 1create-react-app testdemooo 進入後 按 New-&gt;Create New App 輸入命名新增一個專案(ex testdemooo) 產生完會有部署指令，照做即可 12345678910新的 Git repository 需做$ cd my-project/$ git init$ heroku git:remote -a testmemooo針對已存在Git repository，簡單新增“ heroku remote$ heroku git:remote -a testmemooo 但這樣做打開網站會錯誤，以下面文章的最佳解答照做即可React 專案佈署 heroku 問題大致上做法是自行建立 server.js 與產生 build，只需要推 build 檔案上去即可（記得 gitignor 要拿掉 build folder） 網路參考文章 Deploying create-react-app project isn’t uglifying my code React Create Script 2.0 減少維護環境配置","link":"/2020/09/18/heroku-deploy/"},{"title":"[JAVA]有關java之OutOfMemory檢測等相關問題文章整理","text":"有關java之OutOfMemory檢測等相關問題文章整理 關於JVM1234-Xms = 初始值，預設是實體記憶體的1/64-Xmx = 最大值，預設是實體記憶體的1/4-Xmn = 最小值預設空餘堆記憶體小於40%時，JVM 就會增大堆直到-Xmx 的最大限制。 一图解千愁，jvm内存从来没有这么简单过！ 該文建議使用操作系统的2/3作为堆空间，是比较合理的。这是一个经验值。比如6GB的内存，你分配给JVM的，最好不要超过4GB。 淺談 JVM PermGen space 的解決方法 調整JVM可以透過以下的參數來修改它，不過應該不要刻意去加大給它的分配記憶體，因為遇到需要大量的請求不多，怕造成記憶體的浪費，應該是從程式面下手修正程式效能(又是一課題了Orz)。 開發時 IDE 設定 12IDE JAVA_OPTS=&quot;-Xmx900m -Xms900m&quot; 修改jvm.cfg調整JVM虛擬機器記憶體大小 執行jar包的時候參數調整1java -Xmx900m -Xms900m jar app.jar tomcat/Resin/weblogic 等設定完美解決java.lang.OutOfMemoryError處理錯誤的問題 調整JVM參數說明 深入理解JVM內幕之JVM簡單調優參數 Xmx和Xms設置一樣大，MaxPermSize和MinPermSize設置一樣大 關於OutOfMemoryError追查專案出現記憶體溢位的原因及解決方案重點: 修改JVM啟動引數，直接增加記憶體。(-Xms，-Xmx引數一定不要忘記加。) 檢查錯誤日誌，檢視“OutOfMemory”錯誤前是否有其它異常或錯誤。 對程式碼進行走查和分析，找出可能發生記憶體溢位的位置。 使用記憶體檢視工具動態檢視記憶體使用情況 Eclipse開啟Show Heap Status IntelliJ IDEA 可開啟Memory Indicator &amp; debugger Memory頁籤(可參考下方檢測工具@IDEA標題) 程式面與錯誤訊息範例 關於集合物件未清除的範例List、MAP等集合对象是否有使用完后,未清除造成内存溢出 Map &amp;Java heap space 無限迴圈Java記憶體溢位(OOM)異常排查指南 內含更多錯誤示例解說OutOfMemoryError: Java heap spaceOutOfMemoryError: GC overhead limit exceededOutOfMemoryError:Permgen spaceOutOfMemoryError:MetaspaceOutOfMemoryError:Unable to create new native threadOutOfMemoryError:Out of swap space?OutOfMemoryError:Requested array size exceeds VM limitOut of memory:Kill process or sacrifice child 檢測工具@IDEAIntelliJ IDEA 可開啟Memory Indicator &amp; debugger Memory頁籤 (可參考說明開啟: show-heap-memory-size-in-intellij Analyze objects in the JVM heap) 關於IDEA如何设置JVM参数IDEA如何设置JVM参数菜鸟学习IntelliJ IDEA之如何设置JVM运行参数 關於IDEA debugger Memory頁籤用來查看目前堆中類的個數的情况，右邊的diff會顯示跳轉類的變化 過去看來是透過plugin去安裝JVM Debugger Memory View，但我在plugin 已找不到這個，且官網支援的版本也沒有了，但在IEDA 2020.1 debugg時多出的Memory tab，似乎與這功能一模一樣。說明網站:神兵利器－内存调试插件IDEA中很有用的內存調試插件使用多年的go pprof检查内存泄漏的方法居然是错的?! 使用jvm監控工具命令一般用於檢視服務執行時狀態的主要命令包括：jstat、jmap、top、jstack 基本工具介紹 Java內存泄露監控工具","link":"/2020/11/14/java-jvm-memory/"},{"title":"[JAVA] spring 非同步事件","text":"spring 加上 Fire and forget，非同步處理，發出處理後就不用等待回復繼續做其他事情 1.找到@Configuration 的地方加上@EnableAsync 1234@Configuration@EnableAsyncpublic class XxxConfig {} 2.找到想要執行非同步的方法上方加上 @Async 1234567@Componentpublic class MyComponent { @Async void doSomething() { // this will be executed asynchronously }} 如果想要拿到回傳的地方可以在 Future拿到結果。 12345678@Componentpublic class MyComponent { @Async Future&lt;String&gt; doSomething(String s, int i, long l, Object o) { // this will be executed asynchronously return new AsyncResult&lt;&gt;(&quot;result&quot;); }} 3.異常處理 TBD這塊自己是用 restTamplate 發出訊息，但無奈可以 catch 到錯誤，卻無法做錯誤輸出整理。留下文章待做研究。 網路參考文章 spring-background-fire-and-forget-processing Spring Boot(5) @Async 非同步執行緒池詳解 Spring 中@Async 用法與異常處理Spring 中@Async 用法","link":"/2021/01/30/java-spring-asnc/"},{"title":"整合測試工具 jmeter 初體驗","text":"什麼是 JMeter **Apache JMeter™** 是開源軟件，是一個 100% 純 Java 應用程序，旨在加載測試功能行為和測量性能， /div> 使用時機當需要對 API 做整合測試並驗證回覆時使用． 本文將會知道： 使用測試工具 JMeter 做一連串 API 測試 解析回覆json與驗證 啟動在windows下使用 下載並開啟時執行黨 (jmeter=”5.2.1”) 如果需要解析json，需自行放入lib,xxx.jar 範例：Get APIs以下這個範例是根據詢問一個Http [list]，再根據回覆去一個個問另一支API，最終希望檢視結果 API 都回覆 200 OK． 請依序新增對應設定，可以右鍵disable/enable該群組 按下執行就可以從檢視結果樹看到結果 測試計畫 使用者自訂變數; 執行緒群組 簡易控制器: 簡易命名 HTTP 標頭管理員 Authorization:Bearer ${token} HTTP 要求 arrays BeanShell PostProcessor JSON Extractor disabled ForEach 控制器 HTTP 要求 by id 驗證回覆 Debug Sampler 檢視結果樹 這個測試檔案：sample.jmx 處理器細節：自訂變數/引用變數當自訂toekn=xxx時就可以用${token}拿到變數． HTTP 要求 arrays這是一個API 會直接回覆 arrays 如下： 1234567891011[ { &quot;id&quot;:&quot;1&quot;, &quot;name&quot;:&quot;123&quot; }, { &quot;id&quot;:&quot;2&quot;, &quot;name&quot;:&quot;233&quot; }] BeanShell PostProcessor (java語法)處理json資料，並透過vars.put（key,value）設定資料給下一步使用 這邊會需要debug比較麻煩，可以另外從上方視窗叫出log來查看問題出在哪裡1234567891011121314151617181920212223import org.json.JSONObject;import org.json.JSONArray;try{ String response = &quot;&quot;;response = prev.getResponseDataAsString();log.info(&quot;responsessss：&quot; + response);JSONArray jsonArray = new JSONArray(response);for (int i=0; i &lt; jsonArray.length(); i++) { JSONObject o= jsonArray.getJSONObject(i); String name = o.getString(&quot;name&quot;); String id = o.getString(&quot;id&quot;); log.info(&quot;name：&quot; + name); vars.put(&quot;data_&quot;+i,id);}catch (Throwable ex) {log.error(&quot;Error in Beanshell&quot;, ex);throw ex;} ForEach 控制器在使用之前必須有資料是[data_1:xxx,data_2:xxx….]  變數前置字串為data，start index:-1，輸出變數名稱，d  這時下一層的HTTP 要求 by id就可以引用${d} 驗證回覆可以驗證回復，如果要驗證的是500，可以勾選Ignore status。 Debug Sampler 可以查看過程中變數內容 （未完待續） 壓力測試網路參考文章 Jmeter断言中判断请求失败的响应代码问题 找不到斷言，但有驗證回復 Meter - JSON variable in a ForEach Controller","link":"/2022/07/01/jmeter/"},{"title":"[重新認識 Javascript 基礎] 什麼是基於原型的物件導向與原型鏈？","text":"Javascript 是一個物件導向的語言，只不過是基於原型的物件導向，本篇筆記介紹什麼是基於原型的物件導向與原型鏈。 目錄 | Contents 基於類別與基於原型 原型鏈 回顧總結 網路參考文章 物件導向 Object-oriented programming，縮寫：OOP，是一種設計模式，是使用「物件」來做設計 ，封裝資料與操作，使得程式碼更具重用性與擴展性，易於理解與維護。 基於類別與基於原型基於類別的物件導向基於類別 (Class-Based) 的物件導向語言，例如 Java 和 C++。，類別（Class）是物件的抽象設計藍圖，包含資料屬性和操作方法，而物件（Object）是根據類別所創建的具體實例（Instance）。 看看 Java 的程式碼範例： 1. 建立物件藍圖123456789101112class Animal { String name; int age; public Animal(String name, int age) { this.name = name; this.age = age; } void makeSound() { System.out.println(&quot;The animal makes a sound.&quot;); }} 2. 建立物件實體Main{}是 Java 的主程式入口，使用類別 實例名稱 = new 類別(...)可以創建不同的物件實體。 1234567891011121314public class Main { public static void main(String[] args) { // 創建 Animal 類別的實例 myAnimal, .... Animal myAnimal = new Animal(&quot;Dog&quot;, 3); Animal myAnimal2 = new Animal(&quot;Cat&quot;, 5); // 呼叫實例的操作方法 myAnimal.makeSound(); System.out.println(&quot;Name: &quot; + myAnimal.name); System.out.println(&quot;Age: &quot; + myAnimal.age); System.out.println(&quot;Name: &quot; + myAnimal2.name); System.out.println(&quot;Age: &quot; + myAnimal2.age); }} 基於原型的物件導向基於原型 (Prototype-Based) 的程式語言 JavaScript。只有物件 (Object）以原型物件作為設計藍圖獲得資料屬性和操作方法，沒有傳統類別與實例概念，但類似於建構函式和物件實例。 1. 建立物件藍圖這邊有兩種寫法，以下看看 ES5 與 ES6 差異，ES6 的寫法更為簡潔。 ES5 建構式 寫法 1234567891011var Animal = function (name, age) { this.name = name; this.age = age;};// 在原型上添加方法 makeSound// 共享相同方法，節省記憶體。Animal.prototype.makeSound = function () { console.log('The animal makes a sound.');}; ES6 class 寫法在 ES2015 有提供 class 關鍵字，但那只是個語法糖，JS 仍然是基於原型的語言。-MDN 1234567891011class Animal { constructor(name, age) { this.name = name; this.age = age; } makeSound() { console.log('The animal makes a sound.'); }} 2. 建立物件實體創建物件實體，使用let 物件名 = new 建構函式(...)創建。 1234567891011// 創建 Animal 實例let myAnimal = new Animal('Cat', 3);// 使用實例的屬性和方法console.log(myAnimal.name);// 輸出: Catconsole.log(myAnimal.age);// 輸出: 3myAnimal.makeSound();// 輸出: The animal makes a sound. 原型鏈看看由上述程式碼形成的原型鏈： 對象內部的 [[Prototype]] 12345678910console.log(myAnimal) // 印出可以看到Animal {name: ‘Cat’, age: 3} age: 3 name: &quot;doggy&quot; [[Prototype]]: Object makeSound: ƒ () constructor: f(name, age) prototype: {makeSound: ƒ, constructor: ƒ} [[Prototype]]: ƒ () 當對象找不到屬性時，會不斷向上尋找，可以取得原型的屬性跟方法，一層一層形成鏈結，就是原型鏈的由來。 12myAnimal.makeSound(); 訪問對象原型 (內部的 [[Prototype]] )語法： obj.__proto__ 不過這個用法已準備移除，示例先用此表示，建議可改用 Object.getPrototypeOf(obj) 12console.log(myAnimal.__proto__==Animal.prototype); //true 判斷屬性是否在本身還是原型身上。語法：obj.hasOwnProperty (屬性名稱) 12console.log(myAnimal.hasOwnProperty('makeSound')); // falseconsole.log(myAnimal.__proto__.hasOwnProperty('makeSound')); // true 判斷 constructor 構造函數的 prototype 屬性是否在 object 的原型鏈上語法：object instanceof constructor 123console.log(myAnimal instanceof Animal); // trueconsole.log(myAnimal instanceof Object); // trueconsole.log(myAnimal instanceof Array); // false 回顧總結 在 Instagram 查看這則貼文 Mini Lab memo 軟工女孩×小研究式（@minilab_memo）分享的貼文 網路參考文章 Photo by Mediamodifier on Unsplash","link":"/2024/02/10/js-03-oop/"},{"title":"[linux][紀錄]在linux環境下指令操作","text":"紀錄在linux環境下使用command line如何下指令操作 如果曾經維護管理過linux介面環境，或是管理部署，都會需要在命令列介面環境下操作，所以需要了解基礎的指令操作，本篇純記錄用過的linux CLI指令．如果沒有linux環境可以參考另一篇 [Docker]快速啟動可用VNC進去連線之ubuntu，就可以快速練習喔． ＊命令列介面（英語：Command-Line Interface，縮寫：CLI）是在圖形使用者介面得到普及之前使用最為廣泛的使用者介面，它通常不支援滑鼠，使用者通過鍵盤輸入指令，電腦接收到指令後，予以執行。也有人稱之為文字使用者介面（character user interface, CUI）- 維基百科。 系統相關資訊ref:linux查詢作業系統資訊，CPU物理個數，CPU核心數，邏輯CPU數，記憶體資訊查詢，硬碟資訊查詢 查詢記憶體大小123456789可以用下述指令:free free -m //單位cat /proc/meminfoaaaa@el1000:~$ free -m total used free shared buff/cache availableMem: 31985 17605 3437 71 10941 15137Swap: 0 0 0 查詢CPU資訊 查看 CPU 物理個數aaaa@el1000:~$ grep ‘physical id’ /proc/cpuinfo | sort -u | wc -l1 查看 CPU 核心數量aaaa@el1000:~$ grep ‘core id’ /proc/cpuinfo | sort -u | wc -l8 查看 CPU 執行緒數aaaa@el1000:$ cat /proc/cpuinfo| grep “processor”|wc -l16aaaa@el1000:$ grep ‘processor’ /proc/cpuinfo | sort -u | wc -l16 查看 CPU 型號aaaa@el1000:~$ cat /proc/cpuinfo | grep name | sort | uniqmodel name : Intel(R) Xeon(R) CPU D-1548 @ 2.00GHz 基本路徑操作12345678pwd 目前位置mkdir folder 創建資料夾mkdir -p folder 如果目錄已存在則不會報錯mkdir -p Project/a/src 创建多级目录 mkdir -ptouch 檔名.txt 新增空白檔案ls 列出 -a 含隱藏檔案cd 進入cat filename 直接檢視檔案內容 檔案文件權限查看 ls -l 123-l 參數可以顯示檔案與目錄的詳細資訊。-h 參數可以讓輸出的資訊以比較容易閱讀的格式呈現。 -rwxr-xr-x 意思1234第一位表示文件的類型，-爲文件，d爲目錄之後每三位代表即用戶、組用戶、其他用戶其中r表示讀、w表示寫、x表示可執行-表示沒有權限 Linux 系统中采用三位十进制数表示权限，如0755， 0644. 一般赋予目录0755权限，文件0644权限。123456789101112131415161718190755ABCDA- 0， 表示十进制B－用户C－组用户D－其他用户 --- -&gt; 0 (no excute , no write ,no read)--x -&gt; 1 excute, (no write, no read)-w- -&gt; 2 write -wx -&gt; 3 write, excuter-- -&gt; 4 readr-x -&gt; 5 read, excuterw- -&gt; 6 read, write , rwx -&gt; 7 read, write , excute 0755-&gt;即用户具有读/写/执行权限，组用户和其它用户具有读写权限；0644-&gt;即用户具有读写权限，组用户和其它用户具有只读权限； Ref: ls 參數說明 vi 文書處理軟體1234567vi test.txt//輸入i進入編輯模式//按下ESC回到一般模式:wq存檔:q!不存檔離開 http://linux.vbird.org/linux_basic/0310vi/0310vi.php 刪除12345678910rm filenamerm -r dirname/要刪除目錄, 需要加入 -r 代表 recursive 遞迴刪除, 使用時要格外小心, 會把目錄內所有檔案及目錄一同刪除．-f：force=&gt;強制，不會出現警告訊息，會自動忽略不存在的檔案。$ rm -r dirname/ 刪除空目錄,內有檔案或副目錄便不能刪除各發行版為了安全起見,強制刪除整個根目錄會不能生效，如果真的想刪請見參考用法：Ref:https://www.opencli.com/linux/rm-delete-files-directory-command 查看檔案大小1234567du &quot;File&quot;du --block-size=1G &quot;File&quot; 後面不加檔案則是當前目錄-s, --summarize 只顯示總計-h, --human-readable 以 K, M, G 為計量單位du -shc /ftp/*https://clay-atlas.com/blog/2020/01/11/linux-chinese-tutorial-command-du-check-file-size/https://blog.xuite.net/cadmus.lin/yo/39567921 tar123456789壓縮tar zcvf FileName.tar.gz-z ：透過 gzip 的支援進行壓縮/解壓縮：此時檔名最好為 *.tar.gz-c ：建立打包檔案，可搭配 -v 來察看過程中被打包的檔名(filename)-f filename：-f 後面要立刻接要被處理的檔名解壓縮tar zxvf FileName.tar.gz -C /xxx/xxx-x ：解打包或解壓縮的功能，可以搭配 -C (大寫) 在特定目錄解開 wgetwget 是 linux 中除了 curl 外另一個檔案下載的好用工具。若要下載網路上的檔案，可執行 wget 加上檔案的網址即可立即下載， 123456wget http://xxxx/xxxxx.tar.gz //也支援ftp://協定-c //檔案續傳，如果下載大型檔案中途斷線，-c 參數從上次中斷的地方繼續下載-i urls.txt //如果要下載的檔案非常多，可以將網址放進txt裡more:https://blog.gtwang.org/linux/linux-wget-command-download-web-pages-and-files-tutorial-examples/ Ubuntu內建的apt-get指令來完成更新Update the package list first: 1sudo apt-get update sshpass 安裝sshpass 1apt-get install sshpass 使用 scp 與 sshpass 即可複製檔案至遠端 SSH 伺服器. 1$ sshpass -p [使用者密碼] scp -v [本地檔案路徑] [使用者帳號]@[遠端 SSH 伺服器 IP 位址]:[遠端 SSH Server 目錄] Ref:How to install sshpass on ubuntu?https://www.codeproject.com/Questions/1179693/How-to-install-sshpass-on-ubuntuSSH 檔案傳輸https://artistehsu.pixnet.net/blog/post/257353906 更多參考，待讀看似比較簡單的Linux推坑教學 Linux CLI 基本教學","link":"/2020/12/27/linux-CLI/"},{"title":"[監控]使用 Prometheus+Grafana 監控電腦與程式效能","text":"使用 Prometheus+Grafana 監控效能 介紹Prometheus 普羅米修斯是開源的免費應用程序。可以很容易建立不同維度的 metrics 及資訊視覺化圖表的監控與查詢，也有告警設定，Kubernetes 的核心組件也可以找到它的身影，許多知名公司如：Uber 也有導入。 Grafana Grafana 是一個跨平台、開源的資料視覺化網路應用程式平台。使用者組態連接的資料來源之後，Grafana 可以在網路瀏覽器里顯示資料圖表和警告。該軟體的企業版本提供更多的擴充功能。擴充功能通過外掛程式的形式提供，終端使用者可以自訂自己的資料面板介面以及資料請求方式。Grafana 被廣泛使用，包括維基百科專案。 必備安裝與設定下載 Prometheus下載網址 https://prometheus.io/download/ 個人是用 windows 所以下載的是 zip 檔，內含 prometheus.exe 執行程式與 prometheus.yml 設定檔。點擊 prometheus.exe 啟動預設 9090port，即可查看 http://localhost:9090/已運作。如欲更改 port 123//start.batprometheus.exe --web.listen-address=:9999cmd 但這時並未監控任何程式，待後面範例會用到，可先關閉。 下載 grafana下載網址 https://grafana.com/grafana/download個人是 docker 啟動 1docker run -d --name=grafana -p 3000:3000 grafana/grafana 即可開啟 http://localhost:3000/ 預設帳號密碼：admin 設定 grafana 連結 prometheus進入後尋找 data sources-&gt;設定連接 prometheus新增 Url:http://localhost:9999 Access:Browser，Save &amp; Test 確認連接目前還沒有設定圖表，僅先設定待用。 監控 windows 電腦 CPU/Network/Memory1.windows_exporter 用來監控 windows下載地址：https://github.com/martinlindhe/wmi_exporter/releases下載 MSI，下載後在需要監控的目標主機上雙擊執行安裝，安裝完成後會以服務的形式自動執行，預設監聽 9182 埠。 如須關閉可以在電腦中服務找到 windows_exporter 關閉之。 其他Node Exporter Full by Instance ID 2.修改 prometheus.yml12345- job_name: 'windows_exporter' static_configs: - targets: ['localhost:9182'] labels: instance: Windows 3.於 grafana 新增圖表於grafana 的網站上搜尋做好的圖表，這邊有找到兩種： windows_exporter for Prometheus Dashboard Windows Node (fixed for v0.13.0+)就可以監控了 監控 Go 程式效能1.在 Go 程式代碼中加入監控代碼ex: GIN 的 prometheus 用法 123456789101112131415161718192021222324252627282930import ( &quot;log&quot; &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;+ &quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;)func main() {+ StartMonitoring(&quot;0.0.0.0:8000&quot;) select {}}func StartMonitoring(port string) { var p string if port == &quot;&quot; { p = &quot;:8080&quot; } else { p = port } go func() { log.Println(&quot;Listening on&quot;, p)+ http.Handle(&quot;/metrics&quot;, promhttp.Handler()) log.Fatal(http.ListenAndServe(p, nil)) }()}+ func prometheusHandler() gin.HandlerFunc { h := promhttp.Handler() return func(c *gin.Context) { h.ServeHTTP(c.Writer, c.Request) }} 已開啟一個 listen 8000 的程式 2. 編輯 prometheus.yml，把監控的 web 服務 localhost:8000 加入，這邊可以編輯多組。 1234567- job_name: &quot;prometheus&quot; # metrics_path defaults to '/metrics' # scheme defaults to 'http'. static_configs: - targets: [&quot;localhost:8000&quot;, &quot;localhost:8011&quot;] 3. 啟動這時可以打開 localhost:9999 就可以看到 Prometheus 的簡易歷史圖表記錄了。metrics available for this monitor prometheus-go 4. import Go Metrics 圖表於grafana 的網站上搜尋做好的圖表 例如可以套入這個Go Metrics 範例 網路參考文章 Prometheus（二）：Prometheus 監控 Windows 機器 Promethus 叢集部署筆記：（四）安裝並配置 windows_exporter 使用 Prometheus 和 Grafana 打造 Flask Web App 監控預警系統Grafana | 將資料視覺化？簡易的介紹與操作！","link":"/2021/04/28/monitor-promethus-grafana/"},{"title":"[分享] 修改依賴源碼超省時的補丁套件","text":"有的時候，因為一些個人因素，或是依賴庫的檔案有問題，使你不得不去修改 node_modules 裡某個套件的源碼，或許你修正了，也發出 PR 正在等待合併，可是如果你重新使用 npm install 可能還是會拉到尚未修正的源碼，而這個補丁工具 patch-package 可以快速解決你的問題。 目錄 | Contents 起源 安裝 patch-package 修正源碼 創建補丁 部署 實際應用 網路參考文章 起源因為我去改了 node_modules 裡某個套件的源碼，看了網路上說明為了避免下次拉依賴庫又會被修改回來，所以你可能要自己把修正拉進自己的庫，但修改起來看了有點麻煩，文章內有提到另一個補丁工具，索性就用用看，這工具實在好用，記錄下使用過程，如果有看不懂的地方可以看這篇最下方的參考文章． 安裝 patch-package1npm install patch-package --save-dev 修正源碼接著你可以去改 node_modules/xxx/xxx 的檔案 創建補丁12// npx patch-package package-namenpx patch-package xxx package-name 就是你依賴的 node_modules/xxx 的名字 執行完成會發現生成 patches 文件夾，裡面有修改過的文件 diff 紀錄 部署 修改 package.json，新增命令 postinstall123&quot;scripts&quot;: {+ &quot;postinstall&quot;: &quot;patch-package&quot; } 之後再下`npm install` 就會發現它幫你下載相依庫時又修正更改了，這真是太神奇了！ （你可以刪掉相依在讓它載回來看看，記得備份） 12345678910+ $npm install&gt; hexo-site@0.0.0 postinstall xx/blog/minilabmemo.github.io&gt; patch-package+ patch-package 6.5.1+ Applying patches... //下面的檔案進行修改hexo-insert-toc@1.1.2 ✔audited 543 packages in 2.279s 實際應用hexo 主題魔改之後曾有提過我有針對主題底層更改魔改-theme-主題樣式，後來又備份自己修改的地方，想一想或許可以用這個套件修補． 原本架構 12themes/icarus //不會上傳 install from source git clone來的themes/icarus_fix_record //自己的修改備份紀錄 改用 install from NPM 1234npm install -S hexo-theme-icarus專案出現相依庫&quot;hexo-theme-icarus&quot;: &quot;^5.2.1&quot;, 接著移除掉 themes/icarus 資料夾原本修改的地方就被恢復成原主題了 接著再把我備份的修改紀錄去修改 node_modules/hexo-theme-icarus 12345themes/icarus_fix_record/include/style/base.stylthemes/icarus_fix_record/include/style/card.stylthemes/icarus_fix_record/include/style/helper.stylthemes/icarus_fix_record/layout/common/article.jsx... 創建補丁 npx patch-package hexo-theme-icarus 因為檔案會有點多，所以也可以再加上 –include “.include.“ 讓他針對部分去修改就好 完成後去生成的檔案夾確認 diff，這邊也可以記錄你的修改123456789101112$ npx patch-package hexo-theme-icaruspatch-package 6.5.1• Creating temporary folder• Installing hexo-theme-icarus@5.2.1 with npm• Diffing your files with clean files✔ Created file patches/hexo-theme-icarus+5.2.1.patch💡 hexo-theme-icarus is on GitHub! To draft an issue based on your patch run npx patch-package hexo-theme-icarus --create-issue$ npx patch-package hexo-theme-icarus --include &quot;.*include.*&quot;$ npx patch-package hexo-theme-icarus --include &quot;.*(?:include|common).*&quot; 重新安裝確認你可以刪除相依再次下 npm install確認，但似乎用 npm install -S hexo-theme-icarus是沒有作用的 網路參考文章 修改 nodejs 项目中 node_modules 的代码，不能生效吗？ 配置 webpack alias 的方法介紹（沒用過） 使用 patch-package 修改第三方模块 更多選項介紹 Super Easy NPM Package Patching with ‘patch-package’ Photo by Webstacks on Unsplash Photo by Sincerely Media on Unsplash","link":"/2023/03/18/node-modules-fix/"},{"title":"[HTML &amp; CSS][✍ 筆記] 初學 HTML &amp; CSS","text":"練習CSS & HTML 操作相關筆記．[✍ 持續更新] HTMLHtml 基礎 HTML 文件 (HTML document) 標籤 (tag)…包圍著語意 (semantic) 內容(Content)區塊稱作 HTML 元素 (HTML element)，不同標籤表達不同語意 空元素 (Empty Element / Void Element)有些 HTML 元素是不允許有內容的，稱之為空元素。沒有結束標籤常見包括1&lt;br&gt;換行 &lt;hr&gt; &lt;img&gt;圖片 &lt;input&gt;輸入 &lt;link&gt; &lt;meta&gt; HTML 標籤中還有屬性 (Attribute)，來提供該標籤的額外資訊 撰寫規則 屬性值用單引號雙引號都可以 標籤與屬性大小寫都可以，常見且建議是固定使用小寫 (lowercase)。 雙引號間的屬性值不能空白什麼是HTML 標籤Tag - HTML 語法教學Tutorial - Fooish 程式技術https://www.fooish.com/html/tag.html 語意標籤HTML5中新增了語意化標籤(Semantic Elements)，目的是為了讓標籤(Tag)更具意義，以加強文件的結構化，讓搜尋引擎更清楚了解 123456789101112131415161718Header 可於body內或是article或是section代表頁首或是首要區塊Nav 導覽區塊Main 主要區塊，整頁只有一個Article 包覆文章Section 區塊Div 無意義為包裹區塊排版用Aside 用來代表主內容的附加內容，未必是側邊欄，廣告等等都可以用Footer 頁尾Time 時間Mark 似螢光筆重點details 文章的細節Figure /figcaption區塊 引用與標題&lt;hgroup&gt; 當內容有主標題及次標題等多個標題的狀況下使用。&lt;cite&gt; 引用其他文獻或作品(例如書籍、歌曲、電影、繪畫、雕塑等）的標題&lt;String&gt; 粗體相對於&lt;b&gt;&lt;/b&gt;更有強烈意思&lt;i&gt;&lt;/i&gt;italic(斜體)的字首。em 的完整名稱則是 emphasized(強調/注重)s 原文是 strikethrough(刪除線)，del 這個標籤一看就會明白：delete(刪除)。 好文參考： 快速了解HTML語意化標籤 [HTML5]b,i,s 跟 strong,em,del 這些看起來一樣，但意義不同的標籤們 CSS權重計算 在 Instagram 查看這則貼文 Mini Lab memo 軟工女孩×小研究式（@minilab_memo）分享的貼文 區塊計算 Box Model Box Model 預設 box-sizing: content-box content 內容 1width: 寬度值;height: 高度值; padding 內距12padding:上 右 下 左; padding:上下 左右; padding:上 左右 下; padding:四邊同値; border 邊框1border: 邊框粗細 邊框顏色 邊框樣式 ; margin 物件與物件間距離12margin:上 右 下 左;margin:上下 左右;margin:上 左右 下;margin:四邊同値; 該物件整體的大小會是content+padding+border，不要以為真的是width; height大小 然後margin是占空間但不可視的地方。 可以改變屬性 box-sizing: border-box; 就會幫你把整體物件大小設定為width+height 但這樣表示content內容只有width/height-padding-border(看左右/上下設定多少) 然後margin還是占空間但不可視的地方。 範例：可以用開發模式查看它的設定 css reset撰寫時會發現元素與視窗有空隙，css reset可以清楚，還有其他一些效果 React + @emotion/css 套用範例1234import reset from 'react-style-reset';import { injectGlobal } from '@emotion/css';injectGlobal(reset, {}); 排版display隱藏元素 display預設為none 123display: none; //空間消失visibility:hidden //空間仍存在 w3schools Hide an Element 區塊元素 display預設為block，區塊元素排列都會另起一行，除非被改變 可設置寬高 width hight 默認情况下，其寬度自動填满其父元素寬度，即寬度100% 高度，行高以及頂和底邊距都可控制； 123456常見包括 div、p、h1~h6、ul、ol、li、dl、dt、dd、form、table、hr、blockquote 、address、menu、pre.....等等 行內元素 display預設inline，除非被改變 設置寬高無效，只能由内容撑起来，行內元素會依照物件內容的大小決定占用的版面 行内元素会排列在同一行，直到一行排不下，才會換行，其寬度隨元素的内容而變化。 設置上下margin、padding无效，左右padding 、margin有效1234常見包括span、em、i、b、strong、a、img、input、br、select、textarea、q、bdo、sub、sup...等等 行內不能包含區塊元素 *可變元素 依上下文決定 Ref:https://www.jianshu.com/p/9fa96ece88f1 行內區塊 display：inline-block 以inline的方式呈現，但同時擁有block的屬性 PositionStatic：默認值，沒有定位。 固定定位fixed 不管滾軸移動，依然在一樣位置 空間不佔據，會蓋住別人 固定他在原本寫的位置上 有寫上右下左就會定位在視窗頂端的相對位置（非自身） 應用： 蓋版廣告（左右上下置中 設立五個 為什麼） 頂置導覽列top0 回到上面 bottom 0 relative 空間會佔據，也會蓋住沒有設定定位的物件 相對於原本的位置上 兩個都有定位物件，後面蓋前面 可以設定z-index 設定優先，預設0 absolute 空間不佔據，資料會在原本資料的位置 設定完上下左右它會往有定位的父層找 如果找不到會定位在視窗上，不是body(如果想要定在body上，body需要設定定位，往上還有html,有一點差別 ) 應用在不想與人排列的情況，通常父層會用relative,父層想要有排列 應用： 特賣標籤absolute,父層項目relative 改版廣告的(X) float Flex 父層設定可以控制子層的排列方式 關於置中margin“margin:0 atuo;”所代表的的意思是水平居中，區塊元素的容器水平置中。關於margin:0 atuo;”是什么意思？不要告訴我你懂margin ＴＢＤ1.align-content2.延伸設定3. default: align-items: stretch; 上下高度自動滿版時有出現空白問題 範例版面與物件互動式視窗 Modal window原理：製作一置中視窗，然後先隱藏起來，該位置距離上方可以百分比設定． margin: 15% auto; / 15% from the top and centered /w3schools=How TO CSS/JS Modal *My React版練習Add: Model input 欄位 一般的輸入數字框，可以看到預設會有上下箭頭出現 1&lt;input type=&quot;number&quot; value=&quot;5&quot;&gt; 如果要隱藏上下箭頭可以這樣寫：howto_css_hide_arrow_number css-in-js 版- Hiding input spinner using styled-component","link":"/2020/09/15/note-css-html/"},{"title":"[react + typescript + jest] 為你的 react 項目引入測試工具與問題排解","text":"我的 react 項目是採 create-react-app ＋ typescript 創建的，現在要讓它加入 jest 測試項目，記錄整個創建過程及工具，過程中的問題排解。 目錄 | Contents 初始專案建置 新增測試 運行測試 插件 問題 網路參考文章 初始專案建置 首先你要有一個 react ＋ typescript 項目 123npm install -g create-react-app //有裝過可以不用跑create-react-app &lt;你的專案名稱&gt; --template typescript//要注意後方是否正確 否則可能回出現非 ts 版本的專案 另外它會幫你自動生成 tsconfig.json 配置 target:Modern browsers support all ES6 features, so ES6 is a good choice. 其他解釋請見 typescript lang\"展開查看 tsconfig.json 內容\" >folded1234567891011121314151617181920212223242526{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es2015&quot;, &quot;lib&quot;: [ &quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot; ], &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true, &quot;esModuleInterop&quot;: true, &quot;allowSyntheticDefaultImports&quot;: true, &quot;strict&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;noFallthroughCasesInSwitch&quot;: true, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: true, &quot;noEmit&quot;: true, &quot;jsx&quot;: &quot;react-jsx&quot; }, &quot;include&quot;: [ &quot;src&quot; ]} 新增測試 Create React App 使用 Jest 作為其測試運行器，透過 package.json 中的 Jest 配置可以覆寫配置，Jest 是一個流行的 JavaScript 測試框架，只需使用 it() 或 test() 及 expect 等及可編寫測試程式。 只要在對應檔案下新增 xxx.test.tsx 即可。如果你用 react-create-app 生成預設會有一個 App.test.tsx撰寫測試內容，以下是簡單的測試範例： jest 斷言可以參考 jest js 而 @testing-library/react 有一些 render, screen 可用12345678910111213import React from 'react';import { render, screen } from '@testing-library/react';import App from './App';test('render app toMatchSnapshot', () =&gt; { const view = render(&lt;App /&gt;); expect(view).toMatchSnapshot();});test('renders the title with the correct text', () =&gt; { render(&lt;App&gt;&lt;/App&gt;); const titleElement = screen.getByText('首頁'); expect(titleElement).toBeInTheDocument();}); 運行測試Create React App 本身就可以直接使用 npm run test 開始執行測試。 npm test -- --coverage可以看到多了覆蓋率與未覆蓋的地方，這指令也會多出一個 coverage 資料夾，裡面有 index.html 也可以看到結果，不過這個資料夾是被 git 濾掉不會上傳的。。123456&quot;scripts&quot;: { &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test&quot;, &quot;testC&quot;: &quot;npm test -- --coverage&quot;, }, \"點我展開\">folded123456789101112131415161718192021npm test -- --coverage PASS src/components/twDistricts.test.tsx PASS src/App.test.tsx------------------|---------|----------|---------|---------|---------------------File | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s ------------------|---------|----------|---------|---------|---------------------All files | 81.15 | 50 | 63.63 | 82.35 | src | 100 | 100 | 100 | 100 | App.tsx | 100 | 100 | 100 | 100 | src/components | 80.3 | 50 | 61.9 | 81.53 | xxx.tsx | 77.08 | 100 | 60 | 77.08 | 150-155,172-191,248 header.tsx | 100 | 100 | 100 | 100 | ------------------|---------|----------|---------|---------|---------------------Test Suites: 2 passed, 2 totalTests: 3 passed, 3 totalSnapshots: 0 totalTime: 3.496 s, estimated 4 s 插件因為我是用 vscode 做開發，而安裝插件 jest 可以有更好的測試面板做使用，安裝完之後只要檔案有任何更動，不管是不是測試檔案都會重新執行測試。 通過的項目就會在左側出現打勾。 上面測試報告的未覆蓋範圍可以透過 cmd+shift+P-&gt;Jest:Toggle Coverage 提示未覆蓋範圍。 問題運行後出現 SyntaxError 問題 原本在一般簡單的專案執行測試都沒問題，直到我用了一些複雜的外部元件 EX:axios，炸出一堆錯誤訊息，根據提示的方法 moduleNameMapper 與 transform 解一個又一個都出現問題，原本以為是編譯問題也因此研究了 tsconfig 與 jest.config.js/babel-jest 等概念設置都沒有效果，最後使用了 issue 上列的 transformIgnorePatterns 來排除問題，如果有人有其他解法可以一起討論一下。 錯誤訊息123456789101112131415161718SyntaxError: Cannot use import statement outside a moduleHere's what you can do: • If you are trying to use ECMAScript Modules, see https://jestjs.io/docs/ecmascript-modules for how to enable it. • If you are trying to use TypeScript, see https://jestjs.io/docs/getting-started#using-typescript • To have some of your &quot;node_modules&quot; files transformed, you can specify a custom &quot;transformIgnorePatterns&quot; in your config. • If you need a custom transformation specify a &quot;transform&quot; option in your config. • If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the &quot;moduleNameMapper&quot; config option. You'll find more details and examples of these config options in the docs: https://jestjs.io/docs/configuration For information about custom transformations, see: https://jestjs.io/docs/code-transformation import axios, { AxiosError } from 'axios'; | ^//有時是引入資源import { useMediaQuery } from &quot;@uidotdev/usehooks&quot;;import SaveSvg from &quot;../Icons/SaveSvg&quot;;import construct_img from '../images/construct_img.png'; 解法 SyntaxError: Cannot use import statement outside a module #9938 12345&quot;jest&quot;: { &quot;transformIgnorePatterns&quot;: [ &quot;node_modules/(?!@shotgunjed)/&quot; ] }, 網路參考文章 create-react-app 使用 Jest 在 Visual Studio Code 中进行更好的单元测试 Photo by Unsplash","link":"/2023/11/05/react-jest/"},{"title":"[React][✍練習]套用 css-in-js (Emotion 庫) 撰寫 CSS","text":"[✍練習 ing] 練習 React JS 寫法與 css-in-js( Emotion 庫) 撰寫 CSS 一般要在 React 中撰寫 CSS 有幾種做法1.撰寫在.CSS 檔案，再 import 套用。 把 css 寫在不同檔案中12import &quot;./styles.css&quot;;&lt;div className=&quot;App&quot;&gt; 可定義 className 不便性：會需要考慮 CSS 優先度問題2.直接在對應地方用 style={JS 寫法} 撰寫 直接用 Inline-style 在屬性中加入 style12&lt;h2 style ={{color:'red', backgroundColor: &quot;#3f51b5&quot;}}&gt;JS 寫法&lt;/h2&gt;裡面是 JS 寫法，值需加''，且-需改成駱駝式寫法(不能含-字元) 不便性：會需要轉成 JS 寫法，有插件工具可以幫忙轉 3.套用 css-in-js 庫 直接撰寫 CSS，不用再改 JS 寫法啦 而 css-in-js 庫的主要有：styled-components, emotion, glamorous。 練習用 emotion 庫撰寫 CSS Emotion 是一個旨在使用 JavaScript 編寫 CSS 樣式的庫 - 加上兩個反引號，之間就可以直接撰寫 CSS，有 styled 寫法，本篇主要用這個練習看看。 styled 寫法要建立 &lt; div&gt; 標籤樣式時，使用 styled.div；如果要建立的是 &lt; button&gt; 則是使用 styled.button 以此類推。 套用 emotion 庫撰寫基礎使用方法： 安裝 npm install –save emotion 引入用 className 屬性套用123456import { css } from &quot;emotion&quot;;const myStyle = css` color: rebeccapurple;` &lt;div className=&quot;myStyle &quot;&gt;myStyle 樣式&lt;/div&gt; 更多範例可以看 NPM 上的 emotion 庫介紹emotion 套用@emotion/styled基礎使用方法： 引入 npm i @emotion/styled 撰寫標籤 tag123456789const Container = styled.div` //外面 background-color: skyblue;`;...return ( &lt;Container &gt; &lt;/Container &gt; ); 變數修改方法12345let displayNone = &quot;block&quot;const Modal = styled.div`display: ${displayNone}; `; 套用@emotion/core 庫撰寫官方推薦＠＠ 但使用上有一些限制 基礎使用方法： 引入 npm i @emotion/core 引入後用 css 屬性套用12345678910111213/** @jsx jsx */ import { css, jsx } from &quot;@emotion/core&quot;; //在無法配置 babel 配置（create-react-app，codesandbox 等）的項目中一定要加前述/** @jsx jsx */ 才有效果喔！！！之前漏了查好久＠＠定義常數，CSS 區塊要用 css`` 包起來 const TextRed = css` color: red; `;然後在要套用的地方加上 css={xxx} &lt;h2 css={TextRed}&gt;emotion css 寫法&lt;/h2&gt; 更多介紹範例： emotion Introduction 練習區✍持續練習其他進階套用法並更新在範例檔案中 ex: 多重套用，階層樣式，標籤樣式… *可側邊開啟程式碼（如有更好的寫法介紹還請多多指教，謝謝🙏） 開發插件 in vscodevscode 中有一些針對 css-in-js 的插件可以幫助開發效率． Css-in-js可以透過指令將 CSS 選取後切換 css &amp; css-in-js 寫法，不用再自己改半天啦！！ vscode-styled-components可以自動完成在 css-in-js 區塊裡面的 css 補全提示． 網路參考文章 連結 摘要與大致內容 【Day 10】CSS &amp;&amp; Inline-style React CSS &amp;&amp; Inline-style 介紹，JS 物件寫法。 https://github.com/rtsao/csjs/wiki/How-to-apply-multiple-classnames-to-an-element 多重 classnames 寫法 谈一谈在 React 项目中使用 css-in-js 方案 鉴于 emotion 已经支持了 styled 模式，可以优先选择 emotion。內涵 emotion 用法示例 (進階 待看 ☐👈) [Day 14 - 即時天氣] 把 CSS 寫在 JavaScript 中！？ - CSS in JS 的使用 使用 emotion 撰寫 styled components 介紹撰寫 React CSS 的神套件 Styled Components Styled Components sample emotion Composition 套用兩個樣式寫法 https://stackoverflow.com/questions/53803466/what-does-the-comment-jsx-jsx-do-in-the-emotion-css-in-js-library 解釋要在 import 前加上/ ** @jsx jsx * /的原因 https://emotion.sh/docs/css-prop#jsx-pragma 在文件頂部設置 jsx 編譯指示才可以使用 css prop。尤其在無法配置 babel 配置（create-react-app，codesandbox 等）的項目中。 change-style-of-material-ui-textfield 更改 material-ui 樣式的發問 Why you shouldn’t use @emotion/core 有一篇文章分析不應使用 emotion/core 的原因","link":"/2021/04/18/react-css/"},{"title":"[✍練習][🚧進行中][react] 使用ramda整理資料","text":"ramda 一款實用的 JavaScript 函數编程库 安裝 ramda$ npm install ramda 使用import * as R from “ramda”; 過濾資料1234567891011121314151617181920const datas = [ { name: &quot;Cupcake&quot;, pri: 1, status: &quot;OPEN&quot;, type: &quot;blog&quot;, protein: 4.3 }, { name: &quot;Donut&quot;, pri: 2, status: &quot;OPEN&quot;, type: &quot;go&quot;, protein: 4.9 },]找出所有datas.name=&quot;Cupcake&quot;的資料let f = R.filter(R.propEq(&quot;name&quot;, &quot;Cupcake&quot;), datas); 延伸用法介紹JavaScript 的 map() functionArray.prototype.map()map() 方法會建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。Array.prototype.map() react 列表與 Key含 index 輸出介紹範例react lists-and-keys 👇👇👇 未完待續 您可以拉到底部先看參考文章 👇👇👇 練習區 ✍ 持續練習並更新 網路參考文章 官方文檔 中文官方文黨 Display JSON Data in React JS Ramda,从开始到重构","link":"/2020/10/01/react-ramda/"},{"title":"[React][✍練習][🚧進行中] 使用recharts進行圖表繪製","text":"練習 Reactc 畫圖套件 recharts Reactc 畫圖套件 recharts導入1$ npm install recharts 使用123456789101112131415161718192021import { LineChart, Line, XAxis, YAxis, Tooltip } from 'recharts';function RenderLineChart() { const data = [ { name: 'Page A', uv: 400, pv: 2400, amt: 2400 }, { name: 'Page B', uv: 800, pv: 1200, amt: 2400 }, { name: 'Page C', uv: 900, pv: 3000, amt: 2400 }, ]; return ( &lt;LineChart width={400} height={250} data={data}&gt; &lt;XAxis dataKey=&quot;name&quot; /&gt; &lt;YAxis /&gt; &lt;Tooltip /&gt; &lt;Line type=&quot;monotone&quot; dataKey=&quot;uv&quot; stroke=&quot;#8884d8&quot; /&gt; &lt;Line type=&quot;monotone&quot; dataKey=&quot;pv&quot; stroke=&quot;#3f51b5&quot; /&gt; &lt;Line type=&quot;monotone&quot; dataKey=&quot;amt&quot; stroke=&quot;#666666&quot; /&gt; &lt;/LineChart&gt; );}//在對應要放入的位置放入&lt;RenderLineChart /&gt; 問題如果導入後看不見，注意是否是寬跟高沒給對。 網路參考文章 recharts","link":"/2020/11/14/react-recharts/"},{"title":"[react+scss] 快速在 create-react-app 中引用 scss 簡易開發","text":"之前在 React 專案中使用了 CSS-in-JS。CSS-in-JS 的寫法雖然能解決樣式污染問題，但它的寫法較為多變，需要一定的時間來熟練，且轉化 CSS 語法較為麻煩。後來發現在 React 專案中也常能看到 SCSS 的使用，而且只要套用 CSS 的邏輯即可。本篇紀錄在已有 React（Create React App）基礎上的啟用 SCSS 的方法。 目錄 | Contents React 專案 建置 SCSS 環境 檔案架構 SCSS 寫法 插件工具 網路參考文章 React 專案用以下指令快速建立 create-react-app 專案。 create-react-app 是由 Facebook 開發，透過執行一個命令來設定現代 Web 應用程式的 react 專案。 123npx create-react-app my-appcd my-appnpm start 建置 SCSS 環境方法一：先寫 scss 轉成 css 引入這是大部分任何專案都是用的方法，直接用 scss 寫法，然後用插件自動幫你轉 css，檔案引入就引入這個 css 檔案就好。 插件 裝 Live Sass Compiler 右下角有一個 watch css 按下去就可以監控到 scss 檔案幫你轉 css 了，如果有錯誤的話，轉換過程下方視窗會報錯。 方法二：直接引入 scss這方法是 create-react-app 項目直接裝 &gt;npm i sass，然後寫 scss 檔案，引入 scss 檔案即可，其實覺得很神奇，也不用 watch css 跟產生同樣的 css 檔案，查找上比較快速。_Styling React Using Sass the Sass file12345678import './my-sass.scss';const Header = () =&gt; { return ( &lt;&gt; &lt;h1&gt;Hello Style!&lt;/h1&gt; &lt;/&gt; );} 如果寫錯的話會有提示 12345678Module build failed (from ./node_modules/sass-loader/dist/cjs.js):SassError: Expected identifier. ╷14 │ color: $123; │ ^ src/layouts/header.scss 14:11 root stylesheetwebpack compiled with 1 error and 1 warning 檔案架構網路上有很多可以參考的架構建議，你可以在 styles 裏面分檔案對應組件去放置，或者對應組件的地方自己放一份 scss 檔案，一開始我是用前者的方式，後來覺得要找跟創建一樣的資料夾太麻煩了，直接放在旁邊省事多了，原本的資料夾就放全域或基本的設置。 SCSS 寫法你可以參考這份教學文件：Sass 官方指南，裡面有很詳細對應說明，以下簡單列出幾個用法並進行解釋。 變數 VariablesSCSS 中可以定義變量，使用 $name 來引用。雖然原本的 CSS 後來也引進了變數功能，可以視情況使用。 階層 Nesting在 SCSS 中，你可以使用類似 HTML 結構的巢狀方式來定義樣式規則。這種方式更加清晰和易於維護，與原生 CSS 中用空格區分父子選擇器的寫法相比更加直觀。 分割如果你想要將 SCSS 編譯成 CSS，但又不想產生大量的 CSS 文件，可以使用 _xxx.scss 命名的方式。這類文件不會單獨產生 xxx.css 文件，而是被集合到統一的 SCSS 文件中。這種方式有助於組織和管理樣式文件，使得專案結構更加清晰。 插件工具記錄其他有幫助開發的工具。 SCSS Everywhere，當你定義好 scss 後，className 可以幫你自動補齊提示名稱，很多插件都有類似功能，而這個插件在 TSX 下也能正常使用，不用再來回複製，但要自己記憶比較好記的命名來做快捷輸入。 網路參考文章 Photo by Mediamodifier on Unsplash","link":"/2023/11/07/react-scss/"},{"title":"[React 筆記 01] 初始開發環境設定","text":"快速安裝 React 專案與建置開發環境，創建 React App 是創建單頁 React 應用程序的官方支持方式。它提供了無需配置的現代化構建設置。 目錄 | Contents 安裝 node.js (npm) Node.js 是能執行 JavaScript 的執行環境，讓 JS 可以在伺服器 (瀏覽器以外) 運作 npm（全稱 Node Package Manager，即「node 包管理器」）是 Node.js 預設的、用 JavaScript 編寫的軟體套件管理系統 使用 npm 安裝 create-react-app12345npm install -g create-react-app/usr/local/bin/create-react-app -&gt; /usr/local/lib/node_modules/create-react-app/index.js+ create-react-app@3.4.1~ create-react-app --version3.4.1 -g 代表全局安裝 create-react-app 是適合學習 React 的環境及單頁（single-page）應用程式，不需再安装或配置 Webpack 或 Babel 等工具，它們是預先配置好並隐藏的 create-react-app –version 確認版本的指令 - 使用 create-react-app 建立專案12～create-react-app 01-create-react-appCreating a new React app in /Users/xxx/front/01-create-react-app. 啟動專案1npm start 就會看到一個網頁介面啟動囉！！！！！！ *註：當重新下載專案時需要先下 npm install 後才能 npm start*在本地可以看到 node_modules 的資料夾 create-react-app 內容架構 123456README.md package.json //和設定打包工具(webpack)有關node_modules publicpackage-lock.json src public/index.html基本的 HTML 架構，內有 1&quot;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&quot; 而在/src/index.js 則有渲染 DOM 的程式碼 123456ReactDOM.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 完成開發生成靜態與部署1npm run build 當編譯結束時，專案目錄底下會出現 build 資料夾，裡面的檔案就是所需要的靜態檔案 (可以點開 index.html 試試看)，其他檔案在部署時不用上傳。 實作直接打開 HTML 或是用 live server 都會一片空白？？但實際起 python web server 可以看到 (待釐清) vscode 外掛 ESlint 插件 -&gt; 一個 Javascript Linter，是一種靜態代碼分析工具，用於識別在 JavaScript 代碼中發現的有問題的模式，可以定義和加載自定義規則。ESLint 涵蓋了代碼質量和編碼風格問題。 JS JSX Snippets 插件 -&gt;程式碼快速鍵 延伸閱讀 [wait]有看沒懂的 npx 方式","link":"/2020/05/16/react01-create-react-app/"},{"title":"[React筆記 02] react JSX 基本語法","text":"上一篇已建立一個基本專案，開始可以對index.js做一些改寫練習，並練習如何使用 JSX 語法 來撰寫。 目錄 | Contents JSX html 區域 React 中的 JSX 區域 網路參考文章 JSX看起來是 html 與 JS 混合使用，比較接近 JavaScript 而不是 HTML， JSX 允許你使用 JavaScript 所有的功能。 Ref :https://zh-hant.reactjs.org/docs/introducing-jsx.html html 區域剛剛產生的public/index.html，含有基本HTML範本id=”root”的div區塊 1&quot;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&quot; React 中的 JSX 區域接著看一下src/index.js裡的程式碼 基本範例: 直接撰寫 html1234567// APP是組件ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));//或是改成ReactDOM.render( &lt;h1&gt; Hello world!&lt;/h1&gt;,document.getElementById('root')); 解說： 由 React DOM 函式將元素渲染 ROOT 這個DOM 節點中 而將 html當參數傳遞是使用一種Javascript語法: JSX12345678const name = 'Josh Perez'; //一般javascriptconst element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;//混和的html與字串 特殊JSX語法ReactDOM.render( element, document.getElementById('root')); 關於 Babel 是JavaScript 前處理器，編譯器，主要能轉換JSX與ES6成各瀏覽器支持的 JS 12345const element = ( &lt;h1 className=&quot;text&quot;&gt; Hello, World! &lt;/h1&gt;); Babel 將 JSX 編譯為呼叫 React.createElement() 的程式。 12345const element = React.createElement( 'h1', {className: 'text'}, 'Hello, World!'); 範例: 在 html中 可以用 {JS} 表達式崁入變數12345678910111213141516171819202122//js函式宣告或是變數宣告區const styleRed = { color: 'red' };const pic=()=&gt;{ //html語法可以當作參數傳遞 return ( &lt;div&gt;&lt;img src=&quot;https://picsum.photos/200/200?image=229&quot; alt=&quot;&quot; class=&quot;circle-profile&quot;/&gt;&lt;/div&gt;);}var arr = [ &lt;h1&gt;REACT學習&lt;/h1&gt;, &lt;h2&gt;如何使用JSX！&lt;/h2&gt;,];ReactDOM.render(&lt;React.StrictMode&gt; &lt;h1 style = { styleRed } &gt; Hello, world! &lt;/h1&gt; &lt;div&gt;{ pic()} &lt;/div&gt; {/*註解這樣寫*/} &lt;div&gt;{arr}&lt;/div&gt;,{/*可以放入數組*/} &lt;/React.StrictMode&gt;, document.getElementById('root'));- 可在 html 標籤中利用 {} 寫 javascript 表示式- 其中style = {{ color: 'red' }} 這樣的表示也可以。 範例: 帶入屬性命名與Event1234567891011const getValue=(event)=&gt;{ console.log(event.target.value)}ReactDOM.render(&lt;React.StrictMode&gt; &lt;h1 className = &quot;title&quot; &gt; Hello, world! &lt;/h1&gt; &lt;button value onClick={getValue}&gt;按下以取得數值 &lt;/button&gt; &lt;button value={true} onClick={getValue}&gt;按下以取得數值 &lt;/button&gt;&lt;/React.StrictMode&gt;, document.getElementById('root')); 駱駝式命名 class 要用 className 然後可以在 style.css中更改樣式 onclick 也要改onClick{函數名稱} 駱駝式命名 實測命名打錯 console 會出現報 Warning: Invalid DOM property class. Did you mean className? 輸入類的元件button/input/textarea互動事件觸發時，函式只會接收到一個event類別的參數，並不能傳遞其他參數 布林=true 的屬性值可以不寫 範例 JSX引入Inline-style123456789export default function App() { return ( &lt;div className=&quot;App&quot; style={{ color: 'blue',fontSize:'19px' }}&gt; &lt;/div&gt; );} 在style內的是 JS物件也可以把他們只給一個const變數 內容與css不同的是必須是小寫駱駝且去除’-‘ 這種寫法的缺點是不行用hover等特殊效果，需利用其他模組化stylr寫法 網路參考文章 - [【React.js入門 - 06】 JSX](https://ithelp.ithome.com.tw/articles/10216468) - [React篇: JSX語法撰寫指引](https://eyesofkids.gitbooks.io/react-basic-zh-tw/content/day18_deeper_jsx/ \"React篇: JSX語法撰寫指引\")","link":"/2020/05/30/react02-jsx/"},{"title":"[React][🚧進行中]做to-do list頁面","text":"練習用 React 做 to-do list 頁面 功能： 可自由新增代辦任務/選擇優先度/預設類型/日期 新增列表後預設為OPEN，可更改為進行中（inprogress）-&gt;完成（Done) 列表可以依Tab顯示不同狀態 選取後可以刪除，或是右上角有全部清空按鈕 [✍ 修改 ing] 本篇用到套件與關鍵技術： Material-ui table ＆新增修改資料 Material-ui tab Material-ui Icon Material-ui 可輸入下拉選項框 + class 切換動畫 ramba for filter json 整理資料 線上 CodeSandBox","link":"/2020/10/02/react-todo/"},{"title":"[✍持續更新中] [vscode] 使用與插件分享","text":"什麼是 vscode Visual Studio Code（簡稱vscode）是一個由微軟開發，同時支援Windows 、 Linux和macOS等操作系統的免費程式碼編輯器，它支援測試，並內建了Git 版本控制功能，同時也具有開發環境功能，例如代碼補全、代碼片段和代碼重構等。 （維基百科） 開啟命令面板F1 或 Ctrl+Shift+P 開啟命令面板，再輸入想使用什麼內容，結合後續說明使用． Git 版本控制其實在 vscode 中操作 Git 真的非常方便，以下動作都是自己摸索就找到對應功能了，直接紀錄幾個常用動作． commit change File切換到 git 頁籤-&gt;會出現你有更動過的檔案，點擊可以看到差異點-&gt;按下+ 可以新增至 change 列表-&gt;上方輸入 commit Message-&gt;上方有一個勾勾按下及 commit 上傳 change File Push點擊左下角分支圖右方會有上傳按鈕 新增 branch點擊左下角分支圖-&gt;Create branch -&gt;輸入名稱 切換 branch點擊左下角分支圖-&gt;選擇分支 刪除分支Ctrl+shift+p-&gt;git delete branch-&gt;選擇分支 gitmoji在git提交上加入表情符號gitmoji Code Snippet這個是 vscode 內建就有的程式碼內建設定， 開啟終端機你不用跳到 VS Code 工具外來執行，直接按下【Ctrl+、】即可開啟終端機畫面，。Ctrl+` Show integrated terminal 安裝插件側邊欄中有一項 Extensions 可以在這邊搜尋插件與插件使用介紹． 代碼格式化 prettier - code formatter ESLint Path Intellisense自動補齊程式中的路徑和文件名。 Task Kill有時候程式發生意外終止或是不小心關閉，會需要使用終端機查出進程ＩＤ並終止．這個插件很好用，安裝完後 cmd+shift+p 可以叫出對話 輸入task kill…by port 再輸入要砍的網路 port即可． TODO TREE有時候開發過程中有未能完成或是要稍後完成的地方，可以加上TODO/FIXME等註解．這一個插件安裝完之後，側邊會出現新的icon，點擊後可以快速找出這些註解的地方． Quokka.js (沒用過先記著)Quokka.js 会在你输入时自动计算结果，并在 IDE 中打印结果。 Auto rename TagCss-in-js可以透過指令將 CSS 選取後切換 css &amp; css-in-js 寫法，不用再自己改半天啦！！ vscode-styled-components可以自動完成在css-in-js區塊裡面的css補全提示． Git Graph可以看到分支圖 後端語言相關 Go 套件新增 task 設定F1 或 Ctrl+Shift+P 開啟命令面板 12345678910111213141516171819202122232425262728tasks.json{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;echo&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;echo Hello&quot;, &quot;problemMatcher&quot;: [] }, { &quot;label&quot;: &quot;rungo&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;go&quot;, &quot;options&quot;: { &quot;cwd&quot;: &quot;${workspaceRoot}\\\\&quot;, &quot;env&quot;: { &quot;GOPATH&quot;: &quot;D:\\\\go&quot; } }, &quot;args&quot;: [ &quot;run&quot;, &quot;main.go&quot; ], &quot;problemMatcher&quot;: [] } ]} 新增 debug 設定123456789101112131415161718192021222324252627D:\\go\\src\\xxx\\.vscode\\launch.json{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Launch&quot;, &quot;type&quot;: &quot;go&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;mode&quot;: &quot;auto&quot;, &quot;program&quot;: &quot;${fileDirname}&quot;, &quot;env&quot;: {}, &quot;args&quot;: [] }, { &quot;name&quot;: &quot;LaunchRoot&quot;, &quot;type&quot;: &quot;go&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;mode&quot;: &quot;debug&quot;, &quot;program&quot;: &quot;${workspaceRoot}&quot;, &quot;env&quot;: {}, &quot;args&quot;: [] } ]} - 客製化設定根據插件會有對應的設定(快速鍵 Command+ ,) 開啟 settings.json 使用者設定檔 files1234&quot;files.autoSave&quot;: &quot;onFocusChange&quot;, 當焦點移開自動儲存 &quot;files.associations&quot;: { &quot;*.js&quot;: &quot;javascriptreact&quot; 新增檔案後綴連接的檔案類型 （React用） }, editor自動存檔格式化與更改預設格式化工具 1234&quot;editor.tabCompletion&quot;: &quot;on&quot;,//type a snippet prefix (trigger text), and press Tab to insert a snippet.&quot;editor.formatOnSave&quot;: true,&quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; React JSX 自動格式化設定搭配 editor 根據檔案格式做設定 12345678&quot;[javascriptreact]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;},&quot;eslint.codeAction.showDocumentation&quot;: { &quot;enable&quot;: true}, React Hooks SnippetsReact Hooks Snippets - React Hooks程式碼區段快速產生 prettier1234'prettier.singleQuote': true,使用單引號，這個打開，格式化會幫你把&quot;&quot;變成單引號'prettier.semi': false,結束是否加分號 網路參考文章 連結 摘要 偏好的 Visual Studio Code 設定檔 非常詳細 vscode 如何自動格式化代碼？ 編輯器默認的格式化工具 How do I enable automatic prettier formatting for .jsx files in VS Code? each file type has to be individuallyNote javascriptreact as the identifier for JSX VScode Golang 编译任务 Task.json 在終端機的指令可以透過 task 安裝 Visual Studio Code 極速上手指南 vscode 插件推荐 todo-tree 15 款好用的 VS Code 插件 Visual Studio Code 之常備快捷鍵 Visual Studio Code 之常備快捷鍵","link":"/2020/09/18/vscode-plugin/"},{"title":"[React筆記 03] React 組件、函式與生命週期","text":"整理React 組件、函式與生命週期 用法重點筆記。 目錄 | Contents React component (組件)語法 props 是什麼 State的用法 生命週期 網路參考範例: React component (組件)語法 component 就像是 JavaScript 的 function ReactDOM.render 中{函式名稱}變成了&lt;函式名稱/&gt; see:Render Element Component 命名首字必須大寫，大寫駝峰的方式，否則 React 會把它當作一般的 HTML 元素處理，並跳出Warning提示，看到大寫駝峰命名變數時，可以知道是 React 組件而非一般函式。 其他 HTML 屬性、CSS 樣式屬性或一般的函式來說，則會遵行 JavaScript 以小寫駝峰來命名變數的慣例，例如在 className、maxLength、backgroundColor 等等。 props 是什麼 component 就像是 JavaScript 的 function，它接收任意的參數（稱之為「props」）並且回傳畫面的 React element。 props 通常是不可變的(唯獨Immutable)，不能修改自己的 Ref:[Components 與 Props] (https://zh-hant.reactjs.org/docs/components-and-props.html) function component vs class component接著看看兩種寫法轉換 Function 成 Class ： 使用function 來做 component 如果需要向component傳参数，可以使用 props 對象， 用return (html) function component12345678910function HelloName(props) { return &lt;h1&gt;Hello {props.name}!&lt;/h1&gt;;}ReactDOM.render( &lt;React.StrictMode&gt; &lt;HelloName name=&quot;May&quot;/&gt; &lt;/React.StrictMode&gt;, document.getElementById('example')); 使用ES6 class來做 component 也可以使用ES6 class 來 來定義 繼承React.Component且在用render(){}包一層 props 要改用 this.props 用render(){return html} class來 component123456789101112class HelloName extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; }}ReactDOM.render( &lt;React.StrictMode&gt; &lt;HelloName name=&quot;May&quot; /&gt;;, &lt;/React.StrictMode&gt;, document.getElementById('example')); 組件裡面可以再包組件，透過這樣可以重新利用範例練習: USER info React組件 ES6箭頭函式組件 寫法接著看看箭頭函式語法可以簡潔,少打很多字元 const App: () =&gt; JSX.Element //大寫駱駝命名 縮寫：如果裡面只有return 可以去掉{}與return，但通常會有一些變數存在，個人習慣保留． 箭頭函式不可以使用於建構式，可以見[JS 01] javascript 新手上路與概念筆記 使用插件快速鍵 rafc - ReactArrowFunctionComponent紀錄123const Hello = () =&gt; { return ( &lt;div&gt;hello&lt;/div&gt; )} State的用法Props 是唯讀的(Immutable)，State 類似於 prop，但它是私有且由 component 完全控制的。當state被改變時，會進入re-render的update程序，更新畫面。 class(setState) vs function(useState)1. 使用class來改state（setState） 使用 ES6 class來 來定義 繼承React.Component且在用render(){}包一層 props 要改用 this.props 如果想要更改props ，要改用setState 根據React 與 bind this 範例練習:透過一個新的按鈕去改變時間 Refresh Time 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import App from &quot;./App&quot;;const rootElement = document.getElementById(&quot;root&quot;);class Clock extends React.Component { constructor(props) { super(props); this.state = { date: new Date() }; // this.changeTime=this.changeTime.bind(this); } // changeTime(){ // this.setState({date: new Date()}) // } //根據React 與 bind this //以上可以簡化 改箭頭含式寫法 changeTime = () =&gt; { this.setState({ date: new Date() }); }; render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;button onClick={this.changeTime}&gt;刷新 &lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;React.StrictMode&gt; &lt;Clock /&gt;, &lt;/React.StrictMode&gt;, rootElement); 2.使用function component更改state（用useState） 沒有內部狀態（State），是 Stateless Components。 沒有 Lifecycle Hooks 和 refs。 如果想要更改props 要改用useState，useState-是一個基礎的Hook，是可以在function component中使用設定state，而不需要轉換成class。 hook意思是“鈎子”，在音樂上，指的是一首歌曲中最能鈎人的部分。Hook 是 React 16.8 增加的新功能。讓你不必寫 class 就能使用 state 以及其他 React 的功能。使用hook可以更簡化且被推崇使用。 useState它回傳了一對值：目前的 state 跟一個可以更新 state 的 function。 範例改寫練習 Refresh_Time_useState 123456789101112131415161718192021222324252627//1.加上useState引入import React, { useState } from 'react';import ReactDOM from &quot;react-dom&quot;;const Clock=()=&gt;{ // 2.宣告一個 state 變數，命名date。 // 傳入 useState() 的參數就是 state 起始值 const [date, changeTime] = useState(new Date());// 3-1 return中直接寫上state變數-在 function 中可以直接使用 state// 3-2 當使用者點擊，我們就呼叫 函式 並傳入新的值。 return( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 {date.toLocaleTimeString()}.&lt;/h2&gt; &lt;button onClick={()=&gt;{changeTime(new Date())}}&gt;刷新 &lt;/button&gt; &lt;/div&gt; );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render( &lt;React.StrictMode&gt; &lt;Clock/&gt; &lt;/React.StrictMode&gt;, rootElement); （延伸說明）hooks 與 Function Component使用 State Hook 用 Function Component 代替 Stateless Component 的说法，原因是：自从 Hooks 出现，函数式组件功能在不断丰富，函数式组件不再需要强调其无状态特性，因此叫 Function Component 更为恰当。 從精读《Function VS Class 组件》中可以看的使用class component,會因為使用this問題而需要修復，要follow class結構與巢狀太過雜亂，再者，而function component沒有this,如果希望拿到稳定的 props，使用 Function Component 是更好的選擇。而 Function Component + Hooks 可以实现 Class Component 做不到的 capture props、capture value，而且 React 官方也推荐 新的代码使用 Hooks 编写。 生命週期元件被安裝時(Mount)、元件被更新時(Update)、元件被移除時(Unmount)*註：原本想要一樣比較一下class 原本的用法，但還是直接介紹function component(useEffect)更簡潔． useEffect hook12345678useEffect(() =&gt; { /* componentDidMount 和 componentDidUpdate */ return () =&gt; { /* componentWillUnmount */ //在 component unmount 時，React 會執行清除。 }; }, [dependencies參數]); /* 是用來限定當哪些變數被改變時useEffect要觸發 */ Ref: 官方-hooks-effect 重點： 內有使用class與hook 的範例對比說明 很多待細讀 ＴＢＤ 我們建議使用 exhaustive-deps 規則作為我們 eslint-plugin-react-hooks package 的一部分。當不正確地指定依賴時，它會發出警告，並提出修改建議。 網路參考範例: React State(状态) @runoob基礎與線上範例**State 和生命週期 @React中文React解說【React.js入門 - 11】 開始進入class component @IT邦幫忙的系列文React 與 bind this @medium React hook @React 中文解說Hook系列使用 State Hook @React 中文解說State Hook中寫法對比","link":"/2021/02/27/react03-component-props/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"note","slug":"note","link":"/tags/note/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"cleanCode","slug":"cleanCode","link":"/tags/cleanCode/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/tags/Kubernetes/"},{"name":"CLI","slug":"CLI","link":"/tags/CLI/"},{"name":"cloud","slug":"cloud","link":"/tags/cloud/"},{"name":"storage","slug":"storage","link":"/tags/storage/"},{"name":"aws-s3","slug":"aws-s3","link":"/tags/aws-s3/"},{"name":"MinIO","slug":"MinIO","link":"/tags/MinIO/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"gitbook","slug":"gitbook","link":"/tags/gitbook/"},{"name":"docusaurus","slug":"docusaurus","link":"/tags/docusaurus/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"google_analytics","slug":"google-analytics","link":"/tags/google-analytics/"},{"name":"hugo","slug":"hugo","link":"/tags/hugo/"},{"name":"chrome-extension","slug":"chrome-extension","link":"/tags/chrome-extension/"},{"name":"tool","slug":"tool","link":"/tags/tool/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"mongo","slug":"mongo","link":"/tags/mongo/"},{"name":"file","slug":"file","link":"/tags/file/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"elasticSearch","slug":"elasticSearch","link":"/tags/elasticSearch/"},{"name":"kibana","slug":"kibana","link":"/tags/kibana/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"heroku","slug":"heroku","link":"/tags/heroku/"},{"name":"deploy","slug":"deploy","link":"/tags/deploy/"},{"name":"GUI","slug":"GUI","link":"/tags/GUI/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"Memory","slug":"Memory","link":"/tags/Memory/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"jmeter","slug":"jmeter","link":"/tags/jmeter/"},{"name":"SQA","slug":"SQA","link":"/tags/SQA/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"Prometheus","slug":"Prometheus","link":"/tags/Prometheus/"},{"name":"Grafana","slug":"Grafana","link":"/tags/Grafana/"},{"name":"monitor","slug":"monitor","link":"/tags/monitor/"},{"name":"modules","slug":"modules","link":"/tags/modules/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"ing","slug":"ing","link":"/tags/ing/"},{"name":"jest","slug":"jest","link":"/tags/jest/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"create-react-app","slug":"create-react-app","link":"/tags/create-react-app/"},{"name":"css-in-js","slug":"css-in-js","link":"/tags/css-in-js/"},{"name":"ramda","slug":"ramda","link":"/tags/ramda/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"recharts","slug":"recharts","link":"/tags/recharts/"},{"name":"scss","slug":"scss","link":"/tags/scss/"},{"name":"lint","slug":"lint","link":"/tags/lint/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"JSX","slug":"JSX","link":"/tags/JSX/"},{"name":"Babel","slug":"Babel","link":"/tags/Babel/"},{"name":"Material-ui","slug":"Material-ui","link":"/tags/Material-ui/"},{"name":"IDE","slug":"IDE","link":"/tags/IDE/"}],"categories":[{"name":"Frontend","slug":"Frontend","link":"/categories/Frontend/"},{"name":"技術工具","slug":"技術工具","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/"},{"name":"css&#x2F;html","slug":"Frontend/css-html","link":"/categories/Frontend/css-html/"},{"name":"js","slug":"Frontend/js","link":"/categories/Frontend/js/"},{"name":"Backend","slug":"Backend","link":"/categories/Backend/"},{"name":"golang","slug":"Backend/golang","link":"/categories/Backend/golang/"},{"name":"devOps","slug":"技術工具/devOps","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/devOps/"},{"name":"cloud","slug":"技術工具/cloud","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/cloud/"},{"name":"blog","slug":"技術工具/blog","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/blog/"},{"name":"chrome-extension","slug":"技術工具/chrome-extension","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/chrome-extension/"},{"name":"未分類","slug":"技術工具/未分類","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/%E6%9C%AA%E5%88%86%E9%A1%9E/"},{"name":"java","slug":"Backend/java","link":"/categories/Backend/java/"},{"name":"測試","slug":"技術工具/測試","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/%E6%B8%AC%E8%A9%A6/"},{"name":"Linux&#x2F;Mac","slug":"技術工具/Linux-Mac","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/Linux-Mac/"},{"name":"技術工具，效能","slug":"技術工具，效能","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%95%88%E8%83%BD/"},{"name":"modules","slug":"技術工具/modules","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/modules/"},{"name":"react","slug":"Frontend/react","link":"/categories/Frontend/react/"},{"name":"IDE","slug":"技術工具/IDE","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/IDE/"},{"name":"test","slug":"技術工具/test","link":"/categories/%E6%8A%80%E8%A1%93%E5%B7%A5%E5%85%B7/test/"}],"pages":[{"title":"關於 About","text":"關於 小研究式小研究式｜Mini Lab 或又稱小研備忘室|Mini Lab Memo 是用來記錄學習或是生活相關的個人部落格，大部分是程式相關，這些文章談不上教學，只是記錄自己學習的備忘筆記，學習過程中受過很多網路上大神的幫助，跌跌撞撞走到現在，持續分享與紀錄，如果這些可以意外幫助到某一個人，我也會很開心的． 關於我 後端IT工程師，Go經歷兩年 & 正在學習 React。 喜歡貓狗． 透過實作紀錄與搜集整理資料來做比較理解 本部落格持續紀錄自學筆記，如有誤還請您不吝指出與指教 部落格大多是自己學習時記錄下來的內容，有些流程中較少說明與圖片，如果不清楚的地方最後都有附上參考連結，請自行再深入研究，有時間也會再將文章補完整的． 基本資訊： 🌱 I’m currently learning React,Golang,Python 📝 I regulary write articles on https://minilabmemo.github.io/ 📫 How to reach me minilabmemo@gmail.com 經歷與技能: 後端 golang 開發經歷兩年 熟悉開發 Restful Web API 基礎網頁 HTML,CSS,JS,JQUERY 概念，正在學習前端技能:React 其他 Transfer Protocol : WebSocket、MQTT 開發經歷 資料庫 RDBMS SQL &amp; NoSQL(Mongo) 操作與使用經驗 版本控制: 基礎 Git 操作，對 Git flow 有概念 會使用 docker/docker compose 啟動服務 ＆ 撰寫 dockerfile 基礎 Kubernetes 操作 Languages and Tools: Connect with me:","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}